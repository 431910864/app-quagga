(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("get-pixels"), require("ndarray"), require("ndarray-linear-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["get-pixels", "ndarray", "ndarray-linear-interpolate"], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory(require("get-pixels"), require("ndarray"), require("ndarray-linear-interpolate"));
	else
		root["Quagga"] = factory(root["get-pixels"], root["ndarray"], root["ndarray-linear-interpolate"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_167__, __WEBPACK_EXTERNAL_MODULE_168__, __WEBPACK_EXTERNAL_MODULE_169__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 170);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BarcodeReader(config, supplements) {
    this._row = [];
    this.config = config || {};
    this.supplements = supplements;
    return this;
}

BarcodeReader.prototype._nextUnset = function (line, start) {
    var i;

    if (start === undefined) {
        start = 0;
    }
    for (i = start; i < line.length; i++) {
        if (!line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._matchPattern = function (counter, code, maxSingleError) {
    var i,
        error = 0,
        singleError = 0,
        sum = 0,
        modulo = 0,
        barWidth,
        count,
        scaled;

    maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

    for (i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
    }
    if (sum < modulo) {
        return Number.MAX_VALUE;
    }
    barWidth = sum / modulo;
    maxSingleError *= barWidth;

    for (i = 0; i < counter.length; i++) {
        count = counter[i];
        scaled = code[i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;
        if (singleError > maxSingleError) {
            return Number.MAX_VALUE;
        }
        error += singleError;
    }
    return error / modulo;
};

BarcodeReader.prototype._nextSet = function (line, offset) {
    var i;

    offset = offset || 0;
    for (i = offset; i < line.length; i++) {
        if (line[i]) {
            return i;
        }
    }
    return line.length;
};

BarcodeReader.prototype._correctBars = function (counter, correction, indices) {
    var length = indices.length,
        tmp = 0;
    while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);
        if (tmp > 1) {
            counter[indices[length]] = tmp;
        }
    }
};

BarcodeReader.prototype._matchTrace = function (cmpCounter, epsilon) {
    var counter = [],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0
    },
        error;

    if (cmpCounter) {
        for (i = 0; i < cmpCounter.length; i++) {
            counter.push(0);
        }
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                if (counterPos === counter.length - 1) {
                    error = self._matchPattern(counter, cmpCounter);

                    if (error < epsilon) {
                        bestMatch.start = i - offset;
                        bestMatch.end = i;
                        bestMatch.counter = counter;
                        return bestMatch;
                    } else {
                        return null;
                    }
                } else {
                    counterPos++;
                }
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    } else {
        counter.push(0);
        for (i = offset; i < self._row.length; i++) {
            if (self._row[i] ^ isWhite) {
                counter[counterPos]++;
            } else {
                counterPos++;
                counter.push(0);
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    // if cmpCounter was not given
    bestMatch.start = offset;
    bestMatch.end = self._row.length - 1;
    bestMatch.counter = counter;
    return bestMatch;
};

BarcodeReader.prototype.decodePattern = function (pattern) {
    var self = this,
        result;

    self._row = pattern;
    result = self._decode();
    if (result === null) {
        self._row.reverse();
        result = self._decode();
        if (result) {
            result.direction = BarcodeReader.DIRECTION.REVERSE;
            result.start = self._row.length - result.start;
            result.end = self._row.length - result.end;
        }
    } else {
        result.direction = BarcodeReader.DIRECTION.FORWARD;
    }
    if (result) {
        result.format = self.FORMAT;
    }
    return result;
};

BarcodeReader.prototype._matchRange = function (start, end, value) {
    var i;

    start = start < 0 ? 0 : start;
    for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
            return false;
        }
    }
    return true;
};

BarcodeReader.prototype._fillCounters = function (offset, end, isWhite) {
    var self = this,
        counterPos = 0,
        i,
        counters = [];

    isWhite = typeof isWhite !== 'undefined' ? isWhite : true;
    offset = typeof offset !== 'undefined' ? offset : self._nextUnset(self._row);
    end = end || self._row.length;

    counters[counterPos] = 0;
    for (i = offset; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counters[counterPos]++;
        } else {
            counterPos++;
            counters[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return counters;
};

BarcodeReader.prototype._toCounters = function (start, counter) {
    var self = this,
        numCounters = counter.length,
        end = self._row.length,
        isWhite = !self._row[start],
        i,
        counterPos = 0;

    _array_helper2.default.init(counter, 0);

    for (i = start; i < end; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            counterPos++;
            if (counterPos === numCounters) {
                break;
            } else {
                counter[counterPos] = 1;
                isWhite = !isWhite;
            }
        }
    }

    return counter;
};

Object.defineProperty(BarcodeReader.prototype, "FORMAT", {
    value: 'unknown',
    writeable: false
});

BarcodeReader.DIRECTION = {
    FORWARD: 1,
    REVERSE: -1
};

BarcodeReader.Exception = {
    StartNotFoundException: "Start-Info was not found!",
    CodeNotFoundException: "Code could not be found!",
    PatternNotFoundException: "Pattern could not be found!"
};

BarcodeReader.CONFIG_KEYS = {};

exports.default = BarcodeReader;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    init: function init(arr, val) {
        var l = arr.length;
        while (l--) {
            arr[l] = val;
        }
    },

    /**
     * Shuffles the content of an array
     * @return {Array} the array itself shuffled
     */
    shuffle: function shuffle(arr) {
        var i = arr.length - 1,
            j,
            x;
        for (i; i >= 0; i--) {
            j = Math.floor(Math.random() * i);
            x = arr[i];
            arr[i] = arr[j];
            arr[j] = x;
        }
        return arr;
    },

    toPointList: function toPointList(arr) {
        var i,
            j,
            row = [],
            rows = [];
        for (i = 0; i < arr.length; i++) {
            row = [];
            for (j = 0; j < arr[i].length; j++) {
                row[j] = arr[i][j];
            }
            rows[i] = "[" + row.join(",") + "]";
        }
        return "[" + rows.join(",\r\n") + "]";
    },

    /**
     * returns the elements which's score is bigger than the threshold
     * @return {Array} the reduced array
     */
    threshold: function threshold(arr, _threshold, scoreFunc) {
        var i,
            queue = [];
        for (i = 0; i < arr.length; i++) {
            if (scoreFunc.apply(arr, [arr[i]]) >= _threshold) {
                queue.push(arr[i]);
            }
        }
        return queue;
    },

    maxIndex: function maxIndex(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > arr[max]) {
                max = i;
            }
        }
        return max;
    },

    max: function max(arr) {
        var i,
            max = 0;
        for (i = 0; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        return max;
    },

    sum: function sum(arr) {
        var length = arr.length,
            sum = 0;

        while (length--) {
            sum += arr[length];
        }
        return sum;
    }
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _merge2 = __webpack_require__(28);

var _merge3 = _interopRequireDefault(_merge2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EANReader(opts, supplements) {
    opts = (0, _merge3.default)(getDefaulConfig(), opts);
    _barcode_reader2.default.call(this, opts, supplements);
}

function getDefaulConfig() {
    var config = {};

    Object.keys(EANReader.CONFIG_KEYS).forEach(function (key) {
        config[key] = EANReader.CONFIG_KEYS[key].default;
    });
    return config;
}

var properties = {
    CODE_L_START: { value: 0 },
    CODE_G_START: { value: 10 },
    START_PATTERN: { value: [1, 1, 1] },
    STOP_PATTERN: { value: [1, 1, 1] },
    MIDDLE_PATTERN: { value: [1, 1, 1, 1, 1] },
    EXTENSION_START_PATTERN: { value: [1, 1, 2] },
    CODE_PATTERN: { value: [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]] },
    CODE_FREQUENCY: { value: [0, 11, 13, 14, 19, 25, 28, 21, 22, 26] },
    SINGLE_CODE_ERROR: { value: 0.70 },
    AVG_CODE_ERROR: { value: 0.48 },
    FORMAT: { value: "ean_13", writeable: false }
};

EANReader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
EANReader.prototype.constructor = EANReader;

EANReader.prototype._decodeCode = function (start, coderange) {
    var counter = [0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
    },
        code,
        error;

    if (!coderange) {
        coderange = self.CODE_PATTERN.length;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                for (code = 0; code < coderange; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder, epsilon) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    if (isWhite === undefined) {
        isWhite = false;
    }

    if (tryHarder === undefined) {
        tryHarder = true;
    }

    if (epsilon === undefined) {
        epsilon = self.AVG_CODE_ERROR;
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);

                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

EANReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset);
        if (!startInfo) {
            return null;
        }
        leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

EANReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

EANReader.prototype._findEnd = function (offset, isWhite) {
    var self = this,
        endInfo = self._findPattern(self.STOP_PATTERN, offset, isWhite, false);

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

EANReader.prototype._calculateFirstDigit = function (codeFrequency) {
    var i,
        self = this;

    for (i = 0; i < self.CODE_FREQUENCY.length; i++) {
        if (codeFrequency === self.CODE_FREQUENCY[i]) {
            return i;
        }
    }
    return null;
};

EANReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0,
        firstDigit;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        } else {
            codeFrequency |= 0 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    firstDigit = self._calculateFirstDigit(codeFrequency);
    if (firstDigit === null) {
        return null;
    }
    result.unshift(firstDigit);

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

EANReader.prototype._decode = function () {
    var startInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        resultInfo = {};

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end
    };
    decodedCodes.push(code);
    code = self._decodePayload(code, result, decodedCodes);
    if (!code) {
        return null;
    }
    code = self._findEnd(code.end, false);
    if (!code) {
        return null;
    }

    decodedCodes.push(code);

    // Checksum
    if (!self._checksum(result)) {
        return null;
    }

    if (this.supplements.length > 0) {
        var ext = this._decodeExtensions(code.end);
        if (!ext) {
            return null;
        }
        var lastCode = ext.decodedCodes[ext.decodedCodes.length - 1],
            endInfo = {
            start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
            end: lastCode.end
        };
        if (!self._verifyTrailingWhitespace(endInfo)) {
            return null;
        }
        resultInfo = {
            supplement: ext,
            code: result.join("") + ext.code
        };
    }

    return _extends({
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: "",
        startInfo: startInfo,
        decodedCodes: decodedCodes
    }, resultInfo);
};

EANReader.prototype._decodeExtensions = function (offset) {
    var i,
        start = this._nextSet(this._row, offset),
        startInfo = this._findPattern(this.EXTENSION_START_PATTERN, start, false, false),
        result;

    if (startInfo === null) {
        return null;
    }

    for (i = 0; i < this.supplements.length; i++) {
        result = this.supplements[i].decode(this._row, startInfo.end);
        if (result !== null) {
            return {
                code: result.code,
                start: start,
                startInfo: startInfo,
                end: result.end,
                codeset: "",
                decodedCodes: result.decodedCodes
            };
        }
    }
    return null;
};

EANReader.prototype._checksum = function (result) {
    var sum = 0,
        i;

    for (i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = result.length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    return sum % 10 === 0;
};

EANReader.CONFIG_KEYS = {
    supplements: {
        'type': 'arrayOf(string)',
        'default': [],
        'description': 'Allowed extensions to be decoded (2 and/or 5)'
    }
};

exports.default = EANReader;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var freeGlobal = __webpack_require__(38);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),
/* 6 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = clone

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
    var out = new Float32Array(2)
    out[0] = a[0]
    out[1] = a[1]
    return out
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    getRawTag = __webpack_require__(120),
    objectToString = __webpack_require__(147);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.default = {
    drawRect: function drawRect(pos, size, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.strokeRect(pos.x, pos.y, size.x, size.y);
    },
    drawPath: function drawPath(path, def, ctx, style) {
        ctx.strokeStyle = style.color;
        ctx.fillStyle = style.color;
        ctx.lineWidth = style.lineWidth;
        ctx.beginPath();
        ctx.moveTo(path[0][def.x], path[0][def.y]);
        for (var j = 1; j < path.length; j++) {
            ctx.lineTo(path[j][def.x], path[j][def.y]);
        }
        ctx.closePath();
        ctx.stroke();
    },
    drawImage: function drawImage(imageData, size, ctx) {
        var canvasData = ctx.getImageData(0, 0, size.x, size.y),
            data = canvasData.data,
            imageDataPos = imageData.length,
            canvasDataPos = data.length,
            value;

        if (canvasDataPos / imageDataPos !== 4) {
            return false;
        }
        while (imageDataPos--) {
            value = imageData[imageDataPos];
            data[--canvasDataPos] = 255;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
            data[--canvasDataPos] = value;
        }
        ctx.putImageData(canvasData, 0, 0);
        return true;
    }
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(134),
    listCacheDelete = __webpack_require__(135),
    listCacheGet = __webpack_require__(136),
    listCacheHas = __webpack_require__(137),
    listCacheSet = __webpack_require__(138);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isKey = __webpack_require__(131),
    stringToPath = __webpack_require__(155),
    toString = __webpack_require__(166);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(132);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(97),
    isObjectLike = __webpack_require__(6);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports._dimensionsConverters = exports.ERODE = exports.DILATE = exports.Tracer = undefined;
exports.imageRef = imageRef;
exports.computeIntegralImage2 = computeIntegralImage2;
exports.computeIntegralImage = computeIntegralImage;
exports.thresholdImage = thresholdImage;
exports.computeHistogram = computeHistogram;
exports.sharpenLine = sharpenLine;
exports.determineOtsuThreshold = determineOtsuThreshold;
exports.otsuThreshold = otsuThreshold;
exports.computeBinaryImage = computeBinaryImage;
exports.cluster = cluster;
exports.dilate = dilate;
exports.erode = erode;
exports.subtract = subtract;
exports.bitwiseOr = bitwiseOr;
exports.countNonZero = countNonZero;
exports.topGeneric = topGeneric;
exports.grayArrayFromImage = grayArrayFromImage;
exports.grayArrayFromContext = grayArrayFromContext;
exports.grayAndHalfSampleFromCanvasData = grayAndHalfSampleFromCanvasData;
exports.computeGray = computeGray;
exports.loadImageArray = loadImageArray;
exports.halfSample = halfSample;
exports.hsv2rgb = hsv2rgb;
exports._computeDivisors = _computeDivisors;
exports.calculatePatchSize = calculatePatchSize;
exports._parseCSSDimensionValues = _parseCSSDimensionValues;
exports.computeImageArea = computeImageArea;

var _cluster = __webpack_require__(53);

var _cluster2 = _interopRequireDefault(_cluster);

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vec2 = {
    clone: __webpack_require__(7)
};
var vec3 = {
    clone: __webpack_require__(84)
};

/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */
function imageRef(x, y) {
    var that = {
        x: x,
        y: y,
        toVec2: function toVec2() {
            return vec2.clone([this.x, this.y]);
        },
        toVec3: function toVec3() {
            return vec3.clone([this.x, this.y, 1]);
        },
        round: function round() {
            this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
            this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
            return this;
        }
    };
    return that;
};

/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */
function computeIntegralImage2(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        posA = 0,
        posB = 0,
        posC = 0,
        posD = 0,
        x,
        y;

    // sum up first column
    posB = width;
    sum = 0;
    for (y = 1; y < height; y++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA += width;
        posB += width;
    }

    posA = 0;
    posB = 1;
    sum = 0;
    for (x = 1; x < width; x++) {
        sum += imageData[posA];
        integralImageData[posB] += sum;
        posA++;
        posB++;
    }

    for (y = 1; y < height; y++) {
        posA = y * width + 1;
        posB = (y - 1) * width + 1;
        posC = y * width;
        posD = (y - 1) * width;
        for (x = 1; x < width; x++) {
            integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
            posA++;
            posB++;
            posC++;
            posD++;
        }
    }
};

function computeIntegralImage(imageWrapper, integralWrapper) {
    var imageData = imageWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0;

    // sum up first row
    for (var i = 0; i < width; i++) {
        sum += imageData[i];
        integralImageData[i] = sum;
    }

    for (var v = 1; v < height; v++) {
        sum = 0;
        for (var u = 0; u < width; u++) {
            sum += imageData[v * width + u];
            integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
        }
    }
};

function thresholdImage(imageWrapper, threshold, targetWrapper) {
    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        targetData = targetWrapper.data;

    while (length--) {
        targetData[length] = imageData[length] < threshold ? 1 : 0;
    }
};

function computeHistogram(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var imageData = imageWrapper.data,
        length = imageData.length,
        bitShift = 8 - bitsPerPixel,
        bucketCnt = 1 << bitsPerPixel,
        hist = new Int32Array(bucketCnt);

    while (length--) {
        hist[imageData[length] >> bitShift]++;
    }
    return hist;
};

function sharpenLine(line) {
    var i,
        length = line.length,
        left = line[0],
        center = line[1],
        right;

    for (i = 1; i < length - 1; i++) {
        right = line[i + 1];
        //  -1 4 -1 kernel
        line[i - 1] = center * 2 - left - right & 255;
        left = center;
        center = right;
    }
    return line;
};

function determineOtsuThreshold(imageWrapper, bitsPerPixel) {
    if (!bitsPerPixel) {
        bitsPerPixel = 8;
    }
    var hist,
        threshold,
        bitShift = 8 - bitsPerPixel;

    function px(init, end) {
        var sum = 0,
            i;
        for (i = init; i <= end; i++) {
            sum += hist[i];
        }
        return sum;
    }

    function mx(init, end) {
        var i,
            sum = 0;

        for (i = init; i <= end; i++) {
            sum += i * hist[i];
        }

        return sum;
    }

    function determineThreshold() {
        var vet = [0],
            p1,
            p2,
            p12,
            k,
            m1,
            m2,
            m12,
            max = (1 << bitsPerPixel) - 1;

        hist = computeHistogram(imageWrapper, bitsPerPixel);
        for (k = 1; k < max; k++) {
            p1 = px(0, k);
            p2 = px(k + 1, max);
            p12 = p1 * p2;
            if (p12 === 0) {
                p12 = 1;
            }
            m1 = mx(0, k) * p2;
            m2 = mx(k + 1, max) * p1;
            m12 = m1 - m2;
            vet[k] = m12 * m12 / p12;
        }
        return _array_helper2.default.maxIndex(vet);
    }

    threshold = determineThreshold();
    return threshold << bitShift;
};

function otsuThreshold(imageWrapper, targetWrapper) {
    var threshold = determineOtsuThreshold(imageWrapper);

    thresholdImage(imageWrapper, threshold, targetWrapper);
    return threshold;
};

// local thresholding
function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
    computeIntegralImage(imageWrapper, integralWrapper);

    if (!targetWrapper) {
        targetWrapper = imageWrapper;
    }
    var imageData = imageWrapper.data;
    var targetData = targetWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var integralImageData = integralWrapper.data;
    var sum = 0,
        v,
        u,
        kernel = 3,
        A,
        B,
        C,
        D,
        avg,
        size = (kernel * 2 + 1) * (kernel * 2 + 1);

    // clear out top & bottom-border
    for (v = 0; v <= kernel; v++) {
        for (u = 0; u < width; u++) {
            targetData[v * width + u] = 0;
            targetData[(height - 1 - v) * width + u] = 0;
        }
    }

    // clear out left & right border
    for (v = kernel; v < height - kernel; v++) {
        for (u = 0; u <= kernel; u++) {
            targetData[v * width + u] = 0;
            targetData[v * width + (width - 1 - u)] = 0;
        }
    }

    for (v = kernel + 1; v < height - kernel - 1; v++) {
        for (u = kernel + 1; u < width - kernel; u++) {
            A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
            B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
            C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
            D = integralImageData[(v + kernel) * width + (u + kernel)];
            sum = D - C - B + A;
            avg = sum / size;
            targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
        }
    }
};

function cluster(points, threshold, property) {
    var i,
        k,
        cluster,
        point,
        clusters = [];

    if (!property) {
        property = "rad";
    }

    function addToCluster(newPoint) {
        var found = false;
        for (k = 0; k < clusters.length; k++) {
            cluster = clusters[k];
            if (cluster.fits(newPoint)) {
                cluster.add(newPoint);
                found = true;
            }
        }
        return found;
    }

    // iterate over each cloud
    for (i = 0; i < points.length; i++) {
        point = _cluster2.default.createPoint(points[i], i, property);
        if (!addToCluster(point)) {
            clusters.push(_cluster2.default.create(point, threshold));
        }
    }
    return clusters;
};

var Tracer = exports.Tracer = {
    trace: function trace(points, vec) {
        var iteration,
            maxIterations = 10,
            top = [],
            result = [],
            centerPos = 0,
            currentPos = 0;

        function trace(idx, forward) {
            var from,
                to,
                toIdx,
                predictedPos,
                thresholdX = 1,
                thresholdY = Math.abs(vec[1] / 10),
                found = false;

            function match(pos, predicted) {
                if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
                    return true;
                } else {
                    return false;
                }
            }

            // check if the next index is within the vec specifications
            // if not, check as long as the threshold is met

            from = points[idx];
            if (forward) {
                predictedPos = {
                    x: from.x + vec[0],
                    y: from.y + vec[1]
                };
            } else {
                predictedPos = {
                    x: from.x - vec[0],
                    y: from.y - vec[1]
                };
            }

            toIdx = forward ? idx + 1 : idx - 1;
            to = points[toIdx];
            while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
                toIdx = forward ? toIdx + 1 : toIdx - 1;
                to = points[toIdx];
            }

            return found ? toIdx : null;
        }

        for (iteration = 0; iteration < maxIterations; iteration++) {
            // randomly select point to start with
            centerPos = Math.floor(Math.random() * points.length);

            // trace forward
            top = [];
            currentPos = centerPos;
            top.push(points[currentPos]);
            while ((currentPos = trace(currentPos, true)) !== null) {
                top.push(points[currentPos]);
            }
            if (centerPos > 0) {
                currentPos = centerPos;
                while ((currentPos = trace(currentPos, false)) !== null) {
                    top.push(points[currentPos]);
                }
            }

            if (top.length > result.length) {
                result = top;
            }
        }
        return result;
    }
};

var DILATE = exports.DILATE = 1;
var ERODE = exports.ERODE = 2;

function dilate(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum > 0 ? 1 : 0;
        }
    }
};

function erode(inImageWrapper, outImageWrapper) {
    var v,
        u,
        inImageData = inImageWrapper.data,
        outImageData = outImageWrapper.data,
        height = inImageWrapper.size.y,
        width = inImageWrapper.size.x,
        sum,
        yStart1,
        yStart2,
        xStart1,
        xStart2;

    for (v = 1; v < height - 1; v++) {
        for (u = 1; u < width - 1; u++) {
            yStart1 = v - 1;
            yStart2 = v + 1;
            xStart1 = u - 1;
            xStart2 = u + 1;
            sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
            outImageData[v * width + u] = sum === 5 ? 1 : 0;
        }
    }
};

function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] - bImageData[length];
    }
};

function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
    if (!resultImageWrapper) {
        resultImageWrapper = aImageWrapper;
    }
    var length = aImageWrapper.data.length,
        aImageData = aImageWrapper.data,
        bImageData = bImageWrapper.data,
        cImageData = resultImageWrapper.data;

    while (length--) {
        cImageData[length] = aImageData[length] || bImageData[length];
    }
};

function countNonZero(imageWrapper) {
    var length = imageWrapper.data.length,
        data = imageWrapper.data,
        sum = 0;

    while (length--) {
        sum += data[length];
    }
    return sum;
};

function topGeneric(list, top, scoreFunc) {
    var i,
        minIdx = 0,
        min = 0,
        queue = [],
        score,
        hit,
        pos;

    for (i = 0; i < top; i++) {
        queue[i] = {
            score: 0,
            item: null
        };
    }

    for (i = 0; i < list.length; i++) {
        score = scoreFunc.apply(this, [list[i]]);
        if (score > min) {
            hit = queue[minIdx];
            hit.score = score;
            hit.item = list[i];
            min = Number.MAX_VALUE;
            for (pos = 0; pos < top; pos++) {
                if (queue[pos].score < min) {
                    min = queue[pos].score;
                    minIdx = pos;
                }
            }
        }
    }

    return queue;
};

function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
    ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
    var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
    computeGray(ctxData, array);
};

function grayArrayFromContext(ctx, size, offset, array) {
    var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
    computeGray(ctxData, array);
};

function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
    var topRowIdx = 0;
    var bottomRowIdx = size.x;
    var endIdx = Math.floor(canvasData.length / 4);
    var outWidth = size.x / 2;
    var outImgIdx = 0;
    var inWidth = size.x;
    var i;

    while (bottomRowIdx < endIdx) {
        for (i = 0; i < outWidth; i++) {
            outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function computeGray(imageData, outArray, config) {
    var l = imageData.length / 4 | 0,
        i,
        singleChannel = config && config.singleChannel === true;

    if (singleChannel) {
        for (i = 0; i < l; i++) {
            outArray[i] = imageData[i * 4 + 0];
        }
    } else {
        for (i = 0; i < l; i++) {
            outArray[i] = 0.299 * imageData[i * 4 + 0] + 0.587 * imageData[i * 4 + 1] + 0.114 * imageData[i * 4 + 2];
        }
    }
};

function loadImageArray(src, callback, canvas) {
    if (!canvas) {
        canvas = document.createElement('canvas');
    }
    var img = new Image();
    img.callback = callback;
    img.onload = function () {
        canvas.width = this.width;
        canvas.height = this.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(this, 0, 0);
        var array = new Uint8Array(this.width * this.height);
        ctx.drawImage(this, 0, 0);
        var data = ctx.getImageData(0, 0, this.width, this.height).data;
        computeGray(data, array);
        this.callback(array, {
            x: this.width,
            y: this.height
        }, this);
    };
    img.src = src;
};

/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */
function halfSample(inImgWrapper, outImgWrapper) {
    var inImg = inImgWrapper.data;
    var inWidth = inImgWrapper.size.x;
    var outImg = outImgWrapper.data;
    var topRowIdx = 0;
    var bottomRowIdx = inWidth;
    var endIdx = inImg.length;
    var outWidth = inWidth / 2;
    var outImgIdx = 0;
    while (bottomRowIdx < endIdx) {
        for (var i = 0; i < outWidth; i++) {
            outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
            outImgIdx++;
            topRowIdx = topRowIdx + 2;
            bottomRowIdx = bottomRowIdx + 2;
        }
        topRowIdx = topRowIdx + inWidth;
        bottomRowIdx = bottomRowIdx + inWidth;
    }
};

function hsv2rgb(hsv, rgb) {
    var h = hsv[0],
        s = hsv[1],
        v = hsv[2],
        c = v * s,
        x = c * (1 - Math.abs(h / 60 % 2 - 1)),
        m = v - c,
        r = 0,
        g = 0,
        b = 0;

    rgb = rgb || [0, 0, 0];

    if (h < 60) {
        r = c;
        g = x;
    } else if (h < 120) {
        r = x;
        g = c;
    } else if (h < 180) {
        g = c;
        b = x;
    } else if (h < 240) {
        g = x;
        b = c;
    } else if (h < 300) {
        r = x;
        b = c;
    } else if (h < 360) {
        r = c;
        b = x;
    }
    rgb[0] = (r + m) * 255 | 0;
    rgb[1] = (g + m) * 255 | 0;
    rgb[2] = (b + m) * 255 | 0;
    return rgb;
};

function _computeDivisors(n) {
    var largeDivisors = [],
        divisors = [],
        i;

    for (i = 1; i < Math.sqrt(n) + 1; i++) {
        if (n % i === 0) {
            divisors.push(i);
            if (i !== n / i) {
                largeDivisors.unshift(Math.floor(n / i));
            }
        }
    }
    return divisors.concat(largeDivisors);
};

function _computeIntersection(arr1, arr2) {
    var i = 0,
        j = 0,
        result = [];

    while (i < arr1.length && j < arr2.length) {
        if (arr1[i] === arr2[j]) {
            result.push(arr1[i]);
            i++;
            j++;
        } else if (arr1[i] > arr2[j]) {
            j++;
        } else {
            i++;
        }
    }
    return result;
};

function calculatePatchSize(patchSize, imgSize) {
    var divisorsX = _computeDivisors(imgSize.x),
        divisorsY = _computeDivisors(imgSize.y),
        wideSide = Math.max(imgSize.x, imgSize.y),
        common = _computeIntersection(divisorsX, divisorsY),
        nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80],
        nrOfPatchesMap = {
        "x-small": 5,
        "small": 4,
        "medium": 3,
        "large": 2,
        "x-large": 1
    },
        nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium,
        nrOfPatches = nrOfPatchesList[nrOfPatchesIdx],
        desiredPatchSize = Math.floor(wideSide / nrOfPatches),
        optimalPatchSize;

    function findPatchSizeForDivisors(divisors) {
        var i = 0,
            found = divisors[Math.floor(divisors.length / 2)];

        while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
            i++;
        }
        if (i > 0) {
            if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
                found = divisors[i - 1];
            } else {
                found = divisors[i];
            }
        }
        if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
            return { x: found, y: found };
        }
        return null;
    }

    optimalPatchSize = findPatchSizeForDivisors(common);
    if (!optimalPatchSize) {
        optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));
        if (!optimalPatchSize) {
            optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
        }
    }
    return optimalPatchSize;
};

function _parseCSSDimensionValues(value) {
    var dimension = {
        value: parseFloat(value),
        unit: value.indexOf("%") === value.length - 1 ? "%" : "%"
    };

    return dimension;
};

var _dimensionsConverters = exports._dimensionsConverters = {
    top: function top(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height * (dimension.value / 100));
        }
    },
    right: function right(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width - context.width * (dimension.value / 100));
        }
    },
    bottom: function bottom(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.height - context.height * (dimension.value / 100));
        }
    },
    left: function left(dimension, context) {
        if (dimension.unit === "%") {
            return Math.floor(context.width * (dimension.value / 100));
        }
    }
};

function computeImageArea(inputWidth, inputHeight, area) {
    var context = { width: inputWidth, height: inputHeight };

    var parsedArea = Object.keys(area).reduce(function (result, key) {
        var value = area[key],
            parsed = _parseCSSDimensionValues(value),
            calculated = _dimensionsConverters[key](parsed, context);

        result[key] = calculated;
        return result;
    }, {});

    return {
        sx: parsedArea.left,
        sy: parsedArea.top,
        sw: parsedArea.right - parsedArea.left,
        sh: parsedArea.bottom - parsedArea.top
    };
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _subImage = __webpack_require__(56);

var _subImage2 = _interopRequireDefault(_subImage);

var _cv_utils = __webpack_require__(19);

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vec2 = {
    clone: __webpack_require__(7)
};

/**
 * Represents a basic image combining the data and size.
 * In addition, some methods for manipulation are contained.
 * @param size {x,y} The size of the image in pixel
 * @param data {Array} If given, a flat array containing the pixel data
 * @param ArrayType {Type} If given, the desired DataType of the Array (may be typed/non-typed)
 * @param initialize {Boolean} Indicating if the array should be initialized on creation.
 * @returns {ImageWrapper}
 */
function ImageWrapper(size, data, ArrayType, initialize) {
    if (!data) {
        if (ArrayType) {
            this.data = new ArrayType(size.x * size.y);
            if (ArrayType === Array && initialize) {
                _array_helper2.default.init(this.data, 0);
            }
        } else {
            this.data = new Uint8Array(size.x * size.y);
            if (Uint8Array === Array && initialize) {
                _array_helper2.default.init(this.data, 0);
            }
        }
    } else {
        this.data = data;
    }
    this.size = size;
}

/**
 * tests if a position is within the image with a given offset
 * @param imgRef {x, y} The location to test
 * @param border Number the padding value in pixel
 * @returns {Boolean} true if location inside the image's border, false otherwise
 * @see cvd/image.h
 */
ImageWrapper.prototype.inImageWithBorder = function (imgRef, border) {
    return imgRef.x >= border && imgRef.y >= border && imgRef.x < this.size.x - border && imgRef.y < this.size.y - border;
};

/**
 * Performs bilinear sampling
 * @param inImg Image to extract sample from
 * @param x the x-coordinate
 * @param y the y-coordinate
 * @returns the sampled value
 * @see cvd/vision.h
 */
ImageWrapper.sample = function (inImg, x, y) {
    var lx = Math.floor(x);
    var ly = Math.floor(y);
    var w = inImg.size.x;
    var base = ly * inImg.size.x + lx;
    var a = inImg.data[base + 0];
    var b = inImg.data[base + 1];
    var c = inImg.data[base + w];
    var d = inImg.data[base + w + 1];
    var e = a - b;
    x -= lx;
    y -= ly;

    var result = Math.floor(x * (y * (e - c + d) - e) + y * (c - a) + a);
    return result;
};

/**
 * Initializes a given array. Sets each element to zero.
 * @param array {Array} The array to initialize
 */
ImageWrapper.clearArray = function (array) {
    var l = array.length;
    while (l--) {
        array[l] = 0;
    }
};

/**
 * Creates a {SubImage} from the current image ({this}).
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @returns {SubImage} A shared part of the original image
 */
ImageWrapper.prototype.subImage = function (from, size) {
    return new _subImage2.default(from, size, this);
};

/**
 * Creates an {ImageWrapper) and copies the needed underlying image-data area
 * @param imageWrapper {ImageWrapper} The target {ImageWrapper} where the data should be copied
 * @param from {ImageRef} The location where to copy from (top-left location)
 */
ImageWrapper.prototype.subImageAsCopy = function (imageWrapper, from) {
    var sizeY = imageWrapper.size.y,
        sizeX = imageWrapper.size.x;
    var x, y;
    for (x = 0; x < sizeX; x++) {
        for (y = 0; y < sizeY; y++) {
            imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
    }
};

ImageWrapper.prototype.copyTo = function (imageWrapper) {
    var length = this.data.length,
        srcData = this.data,
        dstData = imageWrapper.data;

    while (length--) {
        dstData[length] = srcData[length];
    }
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.get = function (x, y) {
    return this.data[y * this.size.x + x];
};

/**
 * Retrieves a given pixel position from the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
ImageWrapper.prototype.getSafe = function (x, y) {
    var i;

    if (!this.indexMapping) {
        this.indexMapping = {
            x: [],
            y: []
        };
        for (i = 0; i < this.size.x; i++) {
            this.indexMapping.x[i] = i;
            this.indexMapping.x[i + this.size.x] = i;
        }
        for (i = 0; i < this.size.y; i++) {
            this.indexMapping.y[i] = i;
            this.indexMapping.y[i + this.size.y] = i;
        }
    }
    return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
};

/**
 * Sets a given pixel position in the image
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @param value {Number} The grayscale value to set
 * @returns {ImageWrapper} The Image itself (for possible chaining)
 */
ImageWrapper.prototype.set = function (x, y, value) {
    this.data[y * this.size.x + x] = value;
    return this;
};

/**
 * Sets the border of the image (1 pixel) to zero
 */
ImageWrapper.prototype.zeroBorder = function () {
    var i,
        width = this.size.x,
        height = this.size.y,
        data = this.data;
    for (i = 0; i < width; i++) {
        data[i] = data[(height - 1) * width + i] = 0;
    }
    for (i = 1; i < height - 1; i++) {
        data[i * width] = data[i * width + (width - 1)] = 0;
    }
};

/**
 * Inverts a binary image in place
 */
ImageWrapper.prototype.invert = function () {
    var data = this.data,
        length = data.length;

    while (length--) {
        data[length] = data[length] ? 0 : 1;
    }
};

ImageWrapper.prototype.convolve = function (kernel) {
    var x,
        y,
        kx,
        ky,
        kSize = kernel.length / 2 | 0,
        accu = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            accu = 0;
            for (ky = -kSize; ky <= kSize; ky++) {
                for (kx = -kSize; kx <= kSize; kx++) {
                    accu += kernel[ky + kSize][kx + kSize] * this.getSafe(x + kx, y + ky);
                }
            }
            this.data[y * this.size.x + x] = accu;
        }
    }
};

ImageWrapper.prototype.moments = function (labelcount) {
    var data = this.data,
        x,
        y,
        height = this.size.y,
        width = this.size.x,
        val,
        ysq,
        labelsum = [],
        i,
        label,
        mu11,
        mu02,
        mu20,
        x_,
        y_,
        tmp,
        result = [],
        PI = Math.PI,
        PI_4 = PI / 4;

    if (labelcount <= 0) {
        return result;
    }

    for (i = 0; i < labelcount; i++) {
        labelsum[i] = {
            m00: 0,
            m01: 0,
            m10: 0,
            m11: 0,
            m02: 0,
            m20: 0,
            theta: 0,
            rad: 0
        };
    }

    for (y = 0; y < height; y++) {
        ysq = y * y;
        for (x = 0; x < width; x++) {
            val = data[y * width + x];
            if (val > 0) {
                label = labelsum[val - 1];
                label.m00 += 1;
                label.m01 += y;
                label.m10 += x;
                label.m11 += x * y;
                label.m02 += ysq;
                label.m20 += x * x;
            }
        }
    }

    for (i = 0; i < labelcount; i++) {
        label = labelsum[i];
        if (!isNaN(label.m00) && label.m00 !== 0) {
            x_ = label.m10 / label.m00;
            y_ = label.m01 / label.m00;
            mu11 = label.m11 / label.m00 - x_ * y_;
            mu02 = label.m02 / label.m00 - y_ * y_;
            mu20 = label.m20 / label.m00 - x_ * x_;
            tmp = (mu02 - mu20) / (2 * mu11);
            tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI;
            label.theta = (tmp * 180 / PI + 90) % 180 - 90;
            if (label.theta < 0) {
                label.theta += 180;
            }
            label.rad = tmp > PI ? tmp - PI : tmp;
            label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
            result.push(label);
        }
    }

    return result;
};

/**
 * Displays the {ImageWrapper} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, pixel, x, y;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    //frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
ImageWrapper.prototype.overlay = function (canvas, scale, from) {
    if (!scale || scale < 0 || scale > 360) {
        scale = 360;
    }
    var hsv = [0, 1, 1];
    var rgb = [0, 0, 0];
    var whiteRgb = [255, 255, 255];
    var blackRgb = [0, 0, 0];
    var result = [];
    var ctx = canvas.getContext('2d');
    var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
    var data = frame.data;
    var length = this.data.length;
    while (length--) {
        hsv[0] = this.data[length] * scale;
        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : (0, _cv_utils.hsv2rgb)(hsv, rgb);
        data[length * 4 + 0] = result[0];
        data[length * 4 + 1] = result[1];
        data[length * 4 + 2] = result[2];
        data[length * 4 + 3] = 255;
    }
    ctx.putImageData(frame, from.x, from.y);
};

exports.default = ImageWrapper;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(37);

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(98),
    getValue = __webpack_require__(121);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isLength = __webpack_require__(26);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObject = __webpack_require__(0);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),
/* 26 */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var baseMerge = __webpack_require__(101),
    createAssigner = __webpack_require__(117);

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
    searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            searchDirections = this.searchDirections,
            width = imageWrapper.size.x,
            pos;

        function _trace(current, color, label, edgelabel) {
            var i, y, x;

            for (i = 0; i < 7; i++) {
                y = current.cy + searchDirections[current.dir][0];
                x = current.cx + searchDirections[current.dir][1];
                pos = y * width + x;
                if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
                    labelData[pos] = label;
                    current.cy = y;
                    current.cx = x;
                    return true;
                } else {
                    if (labelData[pos] === 0) {
                        labelData[pos] = edgelabel;
                    }
                    current.dir = (current.dir + 1) % 8;
                }
            }
            return false;
        }

        function vertex2D(x, y, dir) {
            return {
                dir: dir,
                x: x,
                y: y,
                next: null,
                prev: null
            };
        }

        function _contourTracing(sy, sx, label, color, edgelabel) {
            var Fv = null,
                Cv,
                P,
                ldir,
                current = {
                cx: sx,
                cy: sy,
                dir: 0
            };

            if (_trace(current, color, label, edgelabel)) {
                Fv = vertex2D(sx, sy, current.dir);
                Cv = Fv;
                ldir = current.dir;
                P = vertex2D(current.cx, current.cy, 0);
                P.prev = Cv;
                Cv.next = P;
                P.next = null;
                Cv = P;
                do {
                    current.dir = (current.dir + 6) % 8;
                    _trace(current, color, label, edgelabel);
                    if (ldir !== current.dir) {
                        Cv.dir = current.dir;
                        P = vertex2D(current.cx, current.cy, 0);
                        P.prev = Cv;
                        Cv.next = P;
                        P.next = null;
                        Cv = P;
                    } else {
                        Cv.dir = ldir;
                        Cv.x = current.cx;
                        Cv.y = current.cy;
                    }
                    ldir = current.dir;
                } while (current.cx !== sx || current.cy !== sy);
                Fv.prev = Cv.prev;
                Cv.prev.next = Fv;
            }
            return Fv;
        }

        return {
            trace: function trace(current, color, label, edgelabel) {
                return _trace(current, color, label, edgelabel);
            },
            contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
                return _contourTracing(sy, sx, label, color, edgelabel);
            }
        };
    }
};

exports.default = Tracer;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Code39Reader() {
    _barcode_reader2.default.call(this);
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 45, 46, 32, 42, 36, 47, 43, 37] },
    CHARACTER_ENCODINGS: { value: [0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A] },
    ASTERISK: { value: 0x094 },
    FORMAT: { value: "code_39", writeable: false }
};

Code39Reader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
Code39Reader.prototype.constructor = Code39Reader;

Code39Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += _array_helper2.default.sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
    }

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code39Reader.prototype._verifyTrailingWhitespace = function (lastStart, nextStart, counters) {
    var trailingWhitespaceEnd,
        patternSize = _array_helper2.default.sum(counters);

    trailingWhitespaceEnd = nextStart - lastStart - patternSize;
    if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
    }
    return false;
};

Code39Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code39Reader.prototype._findNextWidth = function (counters, current) {
    var i,
        minWidth = Number.MAX_VALUE;

    for (i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
            minWidth = counters[i];
        }
    }

    return minWidth;
};

Code39Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length,
        maxNarrowWidth = 0,
        numWideBars = numCounters,
        wideBarWidth = 0,
        self = this,
        pattern,
        i;

    while (numWideBars > 3) {
        maxNarrowWidth = self._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        pattern = 0;
        for (i = 0; i < numCounters; i++) {
            if (counters[i] > maxNarrowWidth) {
                pattern |= 1 << numCounters - 1 - i;
                numWideBars++;
                wideBarWidth += counters[i];
            }
        }

        if (numWideBars === 3) {
            for (i = 0; i < numCounters && numWideBars > 0; i++) {
                if (counters[i] > maxNarrowWidth) {
                    numWideBars--;
                    if (counters[i] * 2 >= wideBarWidth) {
                        return -1;
                    }
                }
            }
            return pattern;
        }
    }
    return -1;
};

Code39Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 7; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[7] = 0;
                counter[8] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

exports.default = Code39Reader;

/***/ }),
/* 32 */
/***/ (function(module, exports) {

module.exports = dot

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1]
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22),
    root = __webpack_require__(5);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(139),
    mapCacheDelete = __webpack_require__(140),
    mapCacheGet = __webpack_require__(141),
    mapCacheHas = __webpack_require__(142),
    mapCacheSet = __webpack_require__(143);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(21),
    eq = __webpack_require__(17);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(22);

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(148);

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),
/* 40 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(88);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),
/* 42 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key`, unless `key` is "__proto__".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  return key == '__proto__'
    ? undefined
    : object[key];
}

module.exports = safeGet;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(107),
    shortOut = __webpack_require__(149);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),
/* 44 */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5),
    stubFalse = __webpack_require__(164);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(99),
    baseUnary = __webpack_require__(110),
    nodeUtil = __webpack_require__(146);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(89),
    baseKeysIn = __webpack_require__(100),
    isArrayLike = __webpack_require__(24);

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _merge2 = __webpack_require__(28);

var _merge3 = _interopRequireDefault(_merge2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; // eslint-disable-line no-unused-vars


var _typedefs = __webpack_require__(57);

var _typedefs2 = _interopRequireDefault(_typedefs);

var _image_wrapper = __webpack_require__(20);

var _image_wrapper2 = _interopRequireDefault(_image_wrapper);

var _barcode_locator = __webpack_require__(64);

var _barcode_locator2 = _interopRequireDefault(_barcode_locator);

var _barcode_decoder = __webpack_require__(60);

var _barcode_decoder2 = _interopRequireDefault(_barcode_decoder);

var _events = __webpack_require__(54);

var _events2 = _interopRequireDefault(_events);

var _camera_access = __webpack_require__(62);

var _camera_access2 = _interopRequireDefault(_camera_access);

var _image_debug = __webpack_require__(9);

var _image_debug2 = _interopRequireDefault(_image_debug);

var _result_collector = __webpack_require__(52);

var _result_collector2 = _interopRequireDefault(_result_collector);

var _config2 = __webpack_require__(58);

var _config3 = _interopRequireDefault(_config2);

var _input_stream = __webpack_require__(51);

var _input_stream2 = _interopRequireDefault(_input_stream);

var _frame_grabber = __webpack_require__(50);

var _frame_grabber2 = _interopRequireDefault(_frame_grabber);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vec2 = {
    clone: __webpack_require__(7)
};

var _inputStream,
    _framegrabber,
    _stopped,
    _canvasContainer = {
    ctx: {
        image: null,
        overlay: null
    },
    dom: {
        image: null,
        overlay: null
    }
},
    _inputImageWrapper,
    _boxSize,
    _decoder,
    _workerPool = [],
    _onUIThread = true,
    _resultCollector,
    _config = {};

function initializeData(imageWrapper) {
    initBuffers(imageWrapper);
    _decoder = _barcode_decoder2.default.create(_config.decoder, _inputImageWrapper);
}

function initInputStream(cb) {
    var video;
    if (_config.inputStream.type === "VideoStream") {
        video = document.createElement("video");
        _inputStream = _input_stream2.default.createVideoStream(video);
    } else if (_config.inputStream.type === "ImageStream") {
        _inputStream = _input_stream2.default.createImageStream();
    } else if (_config.inputStream.type === "LiveStream") {
        var $viewport = getViewPort();
        if ($viewport) {
            video = $viewport.querySelector("video");
            if (!video) {
                video = document.createElement("video");
                $viewport.appendChild(video);
            }
        }
        _inputStream = _input_stream2.default.createLiveStream(video);
        _camera_access2.default.request(video, _config.inputStream.constraints).then(function () {
            _inputStream.trigger("canrecord");
        }).catch(function (err) {
            return cb(err);
        });
    }

    _inputStream.setAttribute("preload", "auto");
    _inputStream.setInputStream(_config.inputStream);
    _inputStream.addEventListener("canrecord", canRecord.bind(undefined, cb));
}

function getViewPort() {
    var target = _config.inputStream.target;
    // Check if target is already a DOM element
    if (target && target.nodeName && target.nodeType === 1) {
        return target;
    } else {
        // Use '#interactive.viewport' as a fallback selector (backwards compatibility)
        var selector = typeof target === 'string' ? target : '#interactive.viewport';
        return document.querySelector(selector);
    }
}

function canRecord(cb) {
    _barcode_locator2.default.checkImageConstraints(_inputStream, _config.locator);
    initCanvas(_config);
    _framegrabber = _frame_grabber2.default.create(_inputStream, _canvasContainer.dom.image);

    adjustWorkerPool(_config.numOfWorkers, function () {
        if (_config.numOfWorkers === 0) {
            initializeData();
        }
        ready(cb);
    });
}

function ready(cb) {
    _inputStream.play();
    cb();
}

function initCanvas() {
    if (typeof document !== "undefined") {
        var $viewport = getViewPort();
        _canvasContainer.dom.image = document.querySelector("canvas.imgBuffer");
        if (!_canvasContainer.dom.image) {
            _canvasContainer.dom.image = document.createElement("canvas");
            _canvasContainer.dom.image.className = "imgBuffer";
            if ($viewport && _config.inputStream.type === "ImageStream") {
                $viewport.appendChild(_canvasContainer.dom.image);
            }
        }
        _canvasContainer.ctx.image = _canvasContainer.dom.image.getContext("2d");
        _canvasContainer.dom.image.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.image.height = _inputStream.getCanvasSize().y;

        _canvasContainer.dom.overlay = document.querySelector("canvas.drawingBuffer");
        if (!_canvasContainer.dom.overlay) {
            _canvasContainer.dom.overlay = document.createElement("canvas");
            _canvasContainer.dom.overlay.className = "drawingBuffer";
            if ($viewport) {
                $viewport.appendChild(_canvasContainer.dom.overlay);
            }
            var clearFix = document.createElement("br");
            clearFix.setAttribute("clear", "all");
            if ($viewport) {
                $viewport.appendChild(clearFix);
            }
        }
        _canvasContainer.ctx.overlay = _canvasContainer.dom.overlay.getContext("2d");
        _canvasContainer.dom.overlay.width = _inputStream.getCanvasSize().x;
        _canvasContainer.dom.overlay.height = _inputStream.getCanvasSize().y;
    }
}

function initBuffers(imageWrapper) {
    if (imageWrapper) {
        _inputImageWrapper = imageWrapper;
    } else {
        _inputImageWrapper = new _image_wrapper2.default({
            x: _inputStream.getWidth(),
            y: _inputStream.getHeight()
        });
    }

    if (false) {
        console.log(_inputImageWrapper.size);
    }
    _boxSize = [vec2.clone([0, 0]), vec2.clone([0, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, _inputImageWrapper.size.y]), vec2.clone([_inputImageWrapper.size.x, 0])];
    _barcode_locator2.default.init(_inputImageWrapper, _config.locator);
}

function getBoundingBoxes() {
    if (_config.locate) {
        return _barcode_locator2.default.locate();
    } else {
        return [[vec2.clone(_boxSize[0]), vec2.clone(_boxSize[1]), vec2.clone(_boxSize[2]), vec2.clone(_boxSize[3])]];
    }
}

function transformResult(result) {
    var topRight = _inputStream.getTopRight(),
        xOffset = topRight.x,
        yOffset = topRight.y,
        i;

    if (xOffset === 0 && yOffset === 0) {
        return;
    }

    if (result.barcodes) {
        for (i = 0; i < result.barcodes.length; i++) {
            transformResult(result.barcodes[i]);
        }
    }

    if (result.line && result.line.length === 2) {
        moveLine(result.line);
    }

    if (result.box) {
        moveBox(result.box);
    }

    if (result.boxes && result.boxes.length > 0) {
        for (i = 0; i < result.boxes.length; i++) {
            moveBox(result.boxes[i]);
        }
    }

    function moveBox(box) {
        var corner = box.length;

        while (corner--) {
            box[corner][0] += xOffset;
            box[corner][1] += yOffset;
        }
    }

    function moveLine(line) {
        line[0].x += xOffset;
        line[0].y += yOffset;
        line[1].x += xOffset;
        line[1].y += yOffset;
    }
}

function addResult(result, imageData) {
    if (!imageData || !_resultCollector) {
        return;
    }

    if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
            return barcode.codeResult;
        }).forEach(function (barcode) {
            return addResult(barcode, imageData);
        });
    } else if (result.codeResult) {
        _resultCollector.addResult(imageData, _inputStream.getCanvasSize(), result.codeResult);
    }
}

function hasCodeResult(result) {
    return result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
    }) : result.codeResult);
}

function publishResult(result, imageData) {
    var resultToPublish = result;

    if (result && _onUIThread) {
        transformResult(result);
        addResult(result, imageData);
        resultToPublish = result.barcodes || result;
    }

    _events2.default.publish("processed", resultToPublish);
    if (hasCodeResult(result)) {
        _events2.default.publish("detected", resultToPublish);
    }
}

function locateAndDecode() {
    var result, boxes;

    boxes = getBoundingBoxes();
    if (boxes) {
        result = _decoder.decodeFromBoundingBoxes(boxes);
        result = result || {};
        result.boxes = boxes;
        publishResult(result, _inputImageWrapper.data);
    } else {
        publishResult();
    }
}

function update() {
    var availableWorker;

    if (_onUIThread) {
        if (_workerPool.length > 0) {
            availableWorker = _workerPool.filter(function (workerThread) {
                return !workerThread.busy;
            })[0];
            if (availableWorker) {
                _framegrabber.attachData(availableWorker.imageData);
            } else {
                return; // all workers are busy
            }
        } else {
            _framegrabber.attachData(_inputImageWrapper.data);
        }
        if (_framegrabber.grab()) {
            if (availableWorker) {
                availableWorker.busy = true;
                availableWorker.worker.postMessage({
                    cmd: 'process',
                    imageData: availableWorker.imageData
                }, [availableWorker.imageData.buffer]);
            } else {
                locateAndDecode();
            }
        }
    } else {
        locateAndDecode();
    }
}

function startContinuousUpdate() {
    var next = null,
        delay = 1000 / (_config.frequency || 60);

    _stopped = false;
    (function frame(timestamp) {
        next = next || timestamp;
        if (!_stopped) {
            if (timestamp >= next) {
                next += delay;
                update();
            }
            window.requestAnimFrame(frame);
        }
    })(performance.now());
}

function _start() {
    if (_onUIThread && _config.inputStream.type === "LiveStream") {
        startContinuousUpdate();
    } else {
        update();
    }
}

function initWorker(cb) {
    var blobURL,
        workerThread = {
        worker: undefined,
        imageData: new Uint8Array(_inputStream.getWidth() * _inputStream.getHeight()),
        busy: true
    };

    blobURL = generateWorkerBlob();
    workerThread.worker = new Worker(blobURL);

    workerThread.worker.onmessage = function (e) {
        if (e.data.event === 'initialized') {
            URL.revokeObjectURL(blobURL);
            workerThread.busy = false;
            workerThread.imageData = new Uint8Array(e.data.imageData);
            if (false) {
                console.log("Worker initialized");
            }
            return cb(workerThread);
        } else if (e.data.event === 'processed') {
            workerThread.imageData = new Uint8Array(e.data.imageData);
            workerThread.busy = false;
            publishResult(e.data.result, workerThread.imageData);
        } else if (e.data.event === 'error') {
            if (false) {
                console.log("Worker error: " + e.data.message);
            }
        }
    };

    workerThread.worker.postMessage({
        cmd: 'init',
        size: { x: _inputStream.getWidth(), y: _inputStream.getHeight() },
        imageData: workerThread.imageData,
        config: configForWorker(_config)
    }, [workerThread.imageData.buffer]);
}

function configForWorker(config) {
    return _extends({}, config, {
        inputStream: _extends({}, config.inputStream, {
            target: null
        })
    });
}

function workerInterface(factory) {
    /* eslint-disable no-undef*/
    if (factory) {
        var Quagga = factory().default;
        if (!Quagga) {
            self.postMessage({ 'event': 'error', message: 'Quagga could not be created' });
            return;
        }
    }
    var imageWrapper;

    self.onmessage = function (e) {
        if (e.data.cmd === 'init') {
            var config = e.data.config;
            config.numOfWorkers = 0;
            imageWrapper = new Quagga.ImageWrapper({
                x: e.data.size.x,
                y: e.data.size.y
            }, new Uint8Array(e.data.imageData));
            Quagga.init(config, ready, imageWrapper);
            Quagga.onProcessed(onProcessed);
        } else if (e.data.cmd === 'process') {
            imageWrapper.data = new Uint8Array(e.data.imageData);
            Quagga.start();
        } else if (e.data.cmd === 'setReaders') {
            Quagga.setReaders(e.data.readers);
        }
    };

    function onProcessed(result) {
        self.postMessage({
            'event': 'processed',
            imageData: imageWrapper.data,
            result: result
        }, [imageWrapper.data.buffer]);
    }

    function ready() {
        // eslint-disable-line
        self.postMessage({ 'event': 'initialized', imageData: imageWrapper.data }, [imageWrapper.data.buffer]);
    }

    /* eslint-enable */
}

function generateWorkerBlob() {
    var blob, factorySource;

    /* jshint ignore:start */
    if (typeof __factorySource__ !== 'undefined') {
        factorySource = __factorySource__; // eslint-disable-line no-undef
    }
    /* jshint ignore:end */

    blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], { type: 'text/javascript' });

    return window.URL.createObjectURL(blob);
}

function _setReaders(readers) {
    if (_decoder) {
        _decoder.setReaders(readers);
    } else if (_onUIThread && _workerPool.length > 0) {
        _workerPool.forEach(function (workerThread) {
            workerThread.worker.postMessage({ cmd: 'setReaders', readers: readers });
        });
    }
}

function adjustWorkerPool(capacity, cb) {
    var increaseBy = capacity - _workerPool.length;
    if (increaseBy === 0) {
        return cb && cb();
    }
    if (increaseBy < 0) {
        var workersToTerminate = _workerPool.slice(increaseBy);
        workersToTerminate.forEach(function (workerThread) {
            workerThread.worker.terminate();
            if (false) {
                console.log("Worker terminated!");
            }
        });
        _workerPool = _workerPool.slice(0, increaseBy);
        return cb && cb();
    } else {
        var workerInitialized = function workerInitialized(workerThread) {
            _workerPool.push(workerThread);
            if (_workerPool.length >= capacity) {
                cb && cb();
            }
        };

        for (var i = 0; i < increaseBy; i++) {
            initWorker(workerInitialized);
        }
    }
}

exports.default = {
    init: function init(config, cb, imageWrapper) {
        _config = (0, _merge3.default)({}, _config3.default, config);
        if (imageWrapper) {
            _onUIThread = false;
            initializeData(imageWrapper);
            return cb();
        } else {
            initInputStream(cb);
        }
    },
    start: function start() {
        _start();
    },
    stop: function stop() {
        _stopped = true;
        adjustWorkerPool(0);
        if (_config.inputStream.type === "LiveStream") {
            _camera_access2.default.release();
            _inputStream.clearEventHandlers();
        }
    },
    pause: function pause() {
        _stopped = true;
    },
    onDetected: function onDetected(callback) {
        _events2.default.subscribe("detected", callback);
    },
    offDetected: function offDetected(callback) {
        _events2.default.unsubscribe("detected", callback);
    },
    onProcessed: function onProcessed(callback) {
        _events2.default.subscribe("processed", callback);
    },
    offProcessed: function offProcessed(callback) {
        _events2.default.unsubscribe("processed", callback);
    },
    setReaders: function setReaders(readers) {
        _setReaders(readers);
    },
    registerResultCollector: function registerResultCollector(resultCollector) {
        if (resultCollector && typeof resultCollector.addResult === 'function') {
            _resultCollector = resultCollector;
        }
    },
    canvas: _canvasContainer,
    decodeSingle: function decodeSingle(config, resultCallback) {
        var _this = this;

        config = (0, _merge3.default)({
            inputStream: {
                type: "ImageStream",
                sequence: false,
                size: 800,
                src: config.src
            },
            numOfWorkers:  false ? 0 : 1,
            locator: {
                halfSample: false
            }
        }, config);
        this.init(config, function () {
            _events2.default.once("processed", function (result) {
                _this.stop();
                resultCallback.call(null, result);
            }, true);
            _start();
        });
    },
    ImageWrapper: _image_wrapper2.default,
    ImageDebug: _image_debug2.default,
    ResultCollector: _result_collector2.default,
    CameraAccess: _camera_access2.default
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CVUtils = __webpack_require__(19),
    Ndarray = __webpack_require__(168),
    Interp2D = __webpack_require__(169).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream) {
    var _that = {},
        _streamConfig = inputStream.getConfig(),
        _video_size = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight()),
        _canvasSize = inputStream.getCanvasSize(),
        _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight()),
        _topRight = inputStream.getTopRight(),
        _data = new Uint8Array(_size.x * _size.y),
        _grayData = new Uint8Array(_video_size.x * _video_size.y),
        _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y),
        _grayImageArray = Ndarray(_grayData, [_video_size.y, _video_size.x]).transpose(1, 0),
        _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0),
        _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y),
        _stepSizeX = _video_size.x / _canvasSize.x,
        _stepSizeY = _video_size.y / _canvasSize.y;

    console.log("FrameGrabber", JSON.stringify({
        videoSize: _grayImageArray.shape,
        canvasSize: _canvasImageArray.shape,
        stepSize: [_stepSizeX, _stepSizeY],
        size: _targetImageArray.shape,
        topRight: _topRight
    }));

    /**
     * Uses the given array as frame-buffer
     */
    _that.attachData = function (data) {
        _data = data;
    };

    /**
     * Returns the used frame-buffer
     */
    _that.getData = function () {
        return _data;
    };

    /**
     * Fetches a frame from the input-stream and puts into the frame-buffer.
     * The image-data is converted to gray-scale and then half-sampled if configured.
     */
    _that.grab = function () {
        var frame = inputStream.getFrame();

        if (frame) {
            this.scaleAndCrop(frame);
            return true;
        } else {
            return false;
        }
    };

    _that.scaleAndCrop = function (frame) {
        var x, y;

        // 1. compute full-sized gray image
        CVUtils.computeGray(frame.data, _grayData);

        // 2. interpolate
        for (y = 0; y < _canvasSize.y; y++) {
            for (x = 0; x < _canvasSize.x; x++) {
                _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
            }
        }

        // targetImageArray must be equal to targetSize
        if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
            throw new Error("Shapes do not match!");
        }

        // 3. crop
        for (y = 0; y < _size.y; y++) {
            for (x = 0; x < _size.x; x++) {
                _data[y * _size.x + x] = _targetImageArray.get(x, y);
            }
        }
    }, _that.getSize = function () {
        return _size;
    };

    return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetPixels = __webpack_require__(167);

var InputStream = {};

InputStream.createImageStream = function () {
    var that = {};
    var _config = null;

    var width = 0,
        height = 0,
        frameIdx = 0,
        paused = true,
        loaded = false,
        frame = null,
        baseUrl,
        ended = false,
        size,
        calculatedWidth,
        calculatedHeight,
        _eventNames = ['canrecord', 'ended'],
        _eventHandlers = {},
        _topRight = { x: 0, y: 0 },
        _canvasSize = { x: 0, y: 0 };

    function loadImages() {
        loaded = false;
        GetPixels(baseUrl, _config.mime, function (err, pixels) {
            if (err) {
                console.log(err);
                exit(1);
            }
            loaded = true;
            console.log(pixels.shape);
            frame = pixels;
            width = pixels.shape[0];
            height = pixels.shape[1];
            calculatedWidth = _config.size ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width;
            calculatedHeight = _config.size ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;

            _canvasSize.x = calculatedWidth;
            _canvasSize.y = calculatedHeight;

            setTimeout(function () {
                publishEvent("canrecord", []);
            }, 0);
        });
    }

    function publishEvent(eventName, args) {
        var j,
            handlers = _eventHandlers[eventName];

        if (handlers && handlers.length > 0) {
            for (j = 0; j < handlers.length; j++) {
                handlers[j].apply(that, args);
            }
        }
    }

    that.trigger = publishEvent;

    that.getWidth = function () {
        return calculatedWidth;
    };

    that.getHeight = function () {
        return calculatedHeight;
    };

    that.setWidth = function (width) {
        calculatedWidth = width;
    };

    that.setHeight = function (height) {
        calculatedHeight = height;
    };

    that.getRealWidth = function () {
        return width;
    };

    that.getRealHeight = function () {
        return height;
    };

    that.setInputStream = function (stream) {
        _config = stream;
        baseUrl = _config.src;
        size = 1;
        loadImages();
    };

    that.ended = function () {
        return ended;
    };

    that.setAttribute = function () {};

    that.getConfig = function () {
        return _config;
    };

    that.pause = function () {
        paused = true;
    };

    that.play = function () {
        paused = false;
    };

    that.setCurrentTime = function (time) {
        frameIdx = time;
    };

    that.addEventListener = function (event, f) {
        if (_eventNames.indexOf(event) !== -1) {
            if (!_eventHandlers[event]) {
                _eventHandlers[event] = [];
            }
            _eventHandlers[event].push(f);
        }
    };

    that.setTopRight = function (topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
    };

    that.getTopRight = function () {
        return _topRight;
    };

    that.setCanvasSize = function (size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
    };

    that.getCanvasSize = function () {
        return _canvasSize;
    };

    that.getFrame = function () {
        if (!loaded) {
            return null;
        }
        return frame;
    };

    return that;
};

module.exports = InputStream;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _image_debug = __webpack_require__(9);

var _image_debug2 = _interopRequireDefault(_image_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function contains(codeResult, list) {
    if (list) {
        return list.some(function (item) {
            return Object.keys(item).every(function (key) {
                return item[key] === codeResult[key];
            });
        });
    }
    return false;
}

function passesFilter(codeResult, filter) {
    if (typeof filter === 'function') {
        return filter(codeResult);
    }
    return true;
}

exports.default = {
    create: function create(config) {
        var canvas = document.createElement("canvas"),
            ctx = canvas.getContext("2d"),
            results = [],
            capacity = config.capacity || 20,
            capture = config.capture === true;

        function matchesConstraints(codeResult) {
            return capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
        }

        return {
            addResult: function addResult(data, imageSize, codeResult) {
                var result = {};

                if (matchesConstraints(codeResult)) {
                    capacity--;
                    result.codeResult = codeResult;
                    if (capture) {
                        canvas.width = imageSize.x;
                        canvas.height = imageSize.y;
                        _image_debug2.default.drawImage(data, imageSize, ctx);
                        result.frame = canvas.toDataURL();
                    }
                    results.push(result);
                }
            },
            getResults: function getResults() {
                return results;
            }
        };
    }
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32)
    /**
     * Creates a cluster for grouping similar orientations of datapoints
     */
};exports.default = {
    create: function create(point, threshold) {
        var points = [],
            center = {
            rad: 0,
            vec: vec2.clone([0, 0])
        },
            pointMap = {};

        function init() {
            _add(point);
            updateCenter();
        }

        function _add(pointToAdd) {
            pointMap[pointToAdd.id] = pointToAdd;
            points.push(pointToAdd);
        }

        function updateCenter() {
            var i,
                sum = 0;
            for (i = 0; i < points.length; i++) {
                sum += points[i].rad;
            }
            center.rad = sum / points.length;
            center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
        }

        init();

        return {
            add: function add(pointToAdd) {
                if (!pointMap[pointToAdd.id]) {
                    _add(pointToAdd);
                    updateCenter();
                }
            },
            fits: function fits(otherPoint) {
                // check cosine similarity to center-angle
                var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));
                if (similarity > threshold) {
                    return true;
                }
                return false;
            },
            getPoints: function getPoints() {
                return points;
            },
            getCenter: function getCenter() {
                return center;
            }
        };
    },
    createPoint: function createPoint(newPoint, id, property) {
        return {
            rad: newPoint[property],
            point: newPoint,
            id: id
        };
    }
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function () {
    var events = {};

    function getEvent(eventName) {
        if (!events[eventName]) {
            events[eventName] = {
                subscribers: []
            };
        }
        return events[eventName];
    }

    function clearEvents() {
        events = {};
    }

    function publishSubscription(subscription, data) {
        if (subscription.async) {
            setTimeout(function () {
                subscription.callback(data);
            }, 4);
        } else {
            subscription.callback(data);
        }
    }

    function _subscribe(event, callback, async) {
        var subscription;

        if (typeof callback === "function") {
            subscription = {
                callback: callback,
                async: async
            };
        } else {
            subscription = callback;
            if (!subscription.callback) {
                throw "Callback was not specified on options";
            }
        }

        getEvent(event).subscribers.push(subscription);
    }

    return {
        subscribe: function subscribe(event, callback, async) {
            return _subscribe(event, callback, async);
        },
        publish: function publish(eventName, data) {
            var event = getEvent(eventName),
                subscribers = event.subscribers;

            // Publish one-time subscriptions
            subscribers.filter(function (subscriber) {
                return !!subscriber.once;
            }).forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });

            // remove them from the subscriber
            event.subscribers = subscribers.filter(function (subscriber) {
                return !subscriber.once;
            });

            // publish the rest
            event.subscribers.forEach(function (subscriber) {
                publishSubscription(subscriber, data);
            });
        },
        once: function once(event, callback, async) {
            _subscribe(event, {
                callback: callback,
                async: async,
                once: true
            });
        },
        unsubscribe: function unsubscribe(eventName, callback) {
            var event;

            if (eventName) {
                event = getEvent(eventName);
                if (event && callback) {
                    event.subscribers = event.subscribers.filter(function (subscriber) {
                        return subscriber.callback !== callback;
                    });
                } else {
                    event.subscribers = [];
                }
            } else {
                clearEvents();
            }
        }
    };
}();

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.enumerateDevices = enumerateDevices;
exports.getUserMedia = getUserMedia;
function enumerateDevices() {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.enumerateDevices === 'function') {
        return navigator.mediaDevices.enumerateDevices();
    }
    return Promise.reject(new Error('enumerateDevices is not defined'));
};

function getUserMedia(constraints) {
    if (navigator.mediaDevices && typeof navigator.mediaDevices.getUserMedia === 'function') {
        return navigator.mediaDevices.getUserMedia(constraints);
    }
    return Promise.reject(new Error('getUserMedia is not defined'));
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/**
 * Construct representing a part of another {ImageWrapper}. Shares data
 * between the parent and the child.
 * @param from {ImageRef} The position where to start the {SubImage} from. (top-left corner)
 * @param size {ImageRef} The size of the resulting image
 * @param I {ImageWrapper} The {ImageWrapper} to share from
 * @returns {SubImage} A shared part of the original image
 */
function SubImage(from, size, I) {
    if (!I) {
        I = {
            data: null,
            size: size
        };
    }
    this.data = I.data;
    this.originalSize = I.size;
    this.I = I;

    this.from = from;
    this.size = size;
}

/**
 * Displays the {SubImage} in a given canvas
 * @param canvas {Canvas} The canvas element to write to
 * @param scale {Number} Scale which is applied to each pixel-value
 */
SubImage.prototype.show = function (canvas, scale) {
    var ctx, frame, data, current, y, x, pixel;

    if (!scale) {
        scale = 1.0;
    }
    ctx = canvas.getContext('2d');
    canvas.width = this.size.x;
    canvas.height = this.size.y;
    frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
    data = frame.data;
    current = 0;
    for (y = 0; y < this.size.y; y++) {
        for (x = 0; x < this.size.x; x++) {
            pixel = y * this.size.x + x;
            current = this.get(x, y) * scale;
            data[pixel * 4 + 0] = current;
            data[pixel * 4 + 1] = current;
            data[pixel * 4 + 2] = current;
            data[pixel * 4 + 3] = 255;
        }
    }
    frame.data = data;
    ctx.putImageData(frame, 0, 0);
};

/**
 * Retrieves a given pixel position from the {SubImage}
 * @param x {Number} The x-position
 * @param y {Number} The y-position
 * @returns {Number} The grayscale value at the pixel-position
 */
SubImage.prototype.get = function (x, y) {
    return this.data[(this.from.y + y) * this.originalSize.x + this.from.x + x];
};

/**
 * Updates the underlying data from a given {ImageWrapper}
 * @param image {ImageWrapper} The updated image
 */
SubImage.prototype.updateData = function (image) {
    this.originalSize = image.size;
    this.data = image.data;
};

/**
 * Updates the position of the shared area
 * @param from {x,y} The new location
 * @returns {SubImage} returns {this} for possible chaining
 */
SubImage.prototype.updateFrom = function (from) {
    this.from = from;
    return this;
};

exports.default = SubImage;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * typedefs.js
 * Normalizes browser-specific prefixes
 */

if (typeof window !== 'undefined') {
    window.requestAnimFrame = function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    }();
}
Math.imul = Math.imul || function (a, b) {
    var ah = a >>> 16 & 0xffff,
        al = a & 0xffff,
        bh = b >>> 16 & 0xffff,
        bl = b & 0xffff;
    // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
};

if (typeof Object.assign !== 'function') {
    Object.assign = function (target) {
        // .length of function is 2
        'use strict';

        if (target === null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var to = Object(target);

        for (var index = 1; index < arguments.length; index++) {
            var nextSource = arguments[index];

            if (nextSource !== null) {
                // Skip over if undefined or null
                for (var nextKey in nextSource) {
                    // Avoid bugs when hasOwnProperty is shadowed
                    if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
        return to;
    };
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var config = void 0;

if (false) {
    config = require('./config.dev.js');
} else if (true) {
    config = __webpack_require__(59);
} else {
    config = require('./config.prod.js');
}

exports.default = config;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
    inputStream: {
        type: "ImageStream",
        sequence: false,
        size: 800,
        area: {
            top: "0%",
            right: "0%",
            left: "0%",
            bottom: "0%"
        },
        singleChannel: false // true: only the red color-channel is read
    },
    locate: true,
    numOfWorkers: 0,
    decoder: {
        readers: ['code_128_reader']
    },
    locator: {
        halfSample: true,
        patchSize: "medium" // x-small, small, medium, large, x-large
    }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _bresenham = __webpack_require__(61);

var _bresenham2 = _interopRequireDefault(_bresenham);

var _image_debug = __webpack_require__(9);

var _image_debug2 = _interopRequireDefault(_image_debug);

var _code_128_reader = __webpack_require__(69);

var _code_128_reader2 = _interopRequireDefault(_code_128_reader);

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

var _code_39_reader = __webpack_require__(31);

var _code_39_reader2 = _interopRequireDefault(_code_39_reader);

var _code_39_vin_reader = __webpack_require__(70);

var _code_39_vin_reader2 = _interopRequireDefault(_code_39_vin_reader);

var _codabar_reader = __webpack_require__(68);

var _codabar_reader2 = _interopRequireDefault(_codabar_reader);

var _upc_reader = __webpack_require__(78);

var _upc_reader2 = _interopRequireDefault(_upc_reader);

var _ean_8_reader = __webpack_require__(74);

var _ean_8_reader2 = _interopRequireDefault(_ean_8_reader);

var _ean_2_reader = __webpack_require__(72);

var _ean_2_reader2 = _interopRequireDefault(_ean_2_reader);

var _ean_5_reader = __webpack_require__(73);

var _ean_5_reader2 = _interopRequireDefault(_ean_5_reader);

var _upc_e_reader = __webpack_require__(77);

var _upc_e_reader2 = _interopRequireDefault(_upc_e_reader);

var _i2of5_reader = __webpack_require__(75);

var _i2of5_reader2 = _interopRequireDefault(_i2of5_reader);

var _of5_reader = __webpack_require__(67);

var _of5_reader2 = _interopRequireDefault(_of5_reader);

var _code_93_reader = __webpack_require__(71);

var _code_93_reader2 = _interopRequireDefault(_code_93_reader);

var _qr_code_reader = __webpack_require__(76);

var _qr_code_reader2 = _interopRequireDefault(_qr_code_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var READERS = {
    code_128_reader: _code_128_reader2.default,
    ean_reader: _ean_reader2.default,
    ean_5_reader: _ean_5_reader2.default,
    ean_2_reader: _ean_2_reader2.default,
    ean_8_reader: _ean_8_reader2.default,
    code_39_reader: _code_39_reader2.default,
    code_39_vin_reader: _code_39_vin_reader2.default,
    codabar_reader: _codabar_reader2.default,
    upc_reader: _upc_reader2.default,
    upc_e_reader: _upc_e_reader2.default,
    i2of5_reader: _i2of5_reader2.default,
    '2of5_reader': _of5_reader2.default,
    code_93_reader: _code_93_reader2.default,
    qr_code_reader: _qr_code_reader2.default
};
exports.default = {
    create: function create(config, inputImageWrapper) {
        var _canvas = {
            ctx: {
                frequency: null,
                pattern: null,
                overlay: null
            },
            dom: {
                frequency: null,
                pattern: null,
                overlay: null
            }
        },
            _barcodeReaders = [];

        initCanvas();
        initReaders();
        initConfig();

        function initCanvas() {
            if (false) {
                var $debug = document.querySelector("#debug.detection");
                _canvas.dom.frequency = document.querySelector("canvas.frequency");
                if (!_canvas.dom.frequency) {
                    _canvas.dom.frequency = document.createElement("canvas");
                    _canvas.dom.frequency.className = "frequency";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.frequency);
                    }
                }
                _canvas.ctx.frequency = _canvas.dom.frequency.getContext("2d");

                _canvas.dom.pattern = document.querySelector("canvas.patternBuffer");
                if (!_canvas.dom.pattern) {
                    _canvas.dom.pattern = document.createElement("canvas");
                    _canvas.dom.pattern.className = "patternBuffer";
                    if ($debug) {
                        $debug.appendChild(_canvas.dom.pattern);
                    }
                }
                _canvas.ctx.pattern = _canvas.dom.pattern.getContext("2d");

                _canvas.dom.overlay = document.querySelector("canvas.drawingBuffer");
                if (_canvas.dom.overlay) {
                    _canvas.ctx.overlay = _canvas.dom.overlay.getContext("2d");
                }
            }
        }

        function initReaders() {
            config.readers.forEach(function (readerConfig) {
                var reader,
                    configuration = {},
                    supplements = [];

                if ((typeof readerConfig === 'undefined' ? 'undefined' : _typeof(readerConfig)) === 'object') {
                    reader = readerConfig.format;
                    configuration = readerConfig.config;
                } else if (typeof readerConfig === 'string') {
                    reader = readerConfig;
                }
                if (false) {
                    console.log("Before registering reader: ", reader);
                }
                if (configuration.supplements) {
                    supplements = configuration.supplements.map(function (supplement) {
                        return new READERS[supplement]();
                    });
                }
                _barcodeReaders.push(new READERS[reader](configuration, supplements));
            });
            if (false) {
                console.log("Registered Readers: " + _barcodeReaders.map(function (reader) {
                    return JSON.stringify({ format: reader.FORMAT, config: reader.config });
                }).join(', '));
            }
        }

        function initConfig() {
            if (false) {
                var i,
                    vis = [{
                    node: _canvas.dom.frequency,
                    prop: config.debug.showFrequency
                }, {
                    node: _canvas.dom.pattern,
                    prop: config.debug.showPattern
                }];

                for (i = 0; i < vis.length; i++) {
                    if (vis[i].prop === true) {
                        vis[i].node.style.display = "block";
                    } else {
                        vis[i].node.style.display = "none";
                    }
                }
            }
        }

        /**
         * extend the line on both ends
         * @param {Array} line
         * @param {Number} angle
         */
        function getExtendedLine(line, angle, ext) {
            function extendLine(amount) {
                var extension = {
                    y: amount * Math.sin(angle),
                    x: amount * Math.cos(angle)
                };

                line[0].y -= extension.y;
                line[0].x -= extension.x;
                line[1].y += extension.y;
                line[1].x += extension.x;
            }

            // check if inside image
            extendLine(ext);
            while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0], 0) || !inputImageWrapper.inImageWithBorder(line[1], 0))) {
                ext -= Math.ceil(ext / 2);
                extendLine(-ext);
            }
            return line;
        }

        function getLine(box) {
            return [{
                x: (box[1][0] - box[0][0]) / 2 + box[0][0],
                y: (box[1][1] - box[0][1]) / 2 + box[0][1]
            }, {
                x: (box[3][0] - box[2][0]) / 2 + box[2][0],
                y: (box[3][1] - box[2][1]) / 2 + box[2][1]
            }];
        }

        function tryDecode(line) {
            var result = null,
                i,
                barcodeLine = _bresenham2.default.getBarcodeLine(inputImageWrapper, line[0], line[1]);

            if (false) {
                _image_debug2.default.drawPath(line, { x: 'x', y: 'y' }, _canvas.ctx.overlay, { color: 'red', lineWidth: 3 });
                _bresenham2.default.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
            }

            _bresenham2.default.toBinaryLine(barcodeLine);

            if (false) {
                _bresenham2.default.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
            }

            for (i = 0; i < _barcodeReaders.length && result === null; i++) {
                result = _barcodeReaders[i].decodePattern(barcodeLine.line, inputImageWrapper);
            }
            if (result === null) {
                return null;
            }
            return {
                codeResult: result,
                barcodeLine: barcodeLine
            };
        }

        /**
         * This method slices the given area apart and tries to detect a barcode-pattern
         * for each slice. It returns the decoded barcode, or null if nothing was found
         * @param {Array} box
         * @param {Array} line
         * @param {Number} lineAngle
         */
        function tryDecodeBruteForce(box, line, lineAngle) {
            var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2)),
                i,
                slices = 16,
                result = null,
                dir,
                extension,
                xdir = Math.sin(lineAngle),
                ydir = Math.cos(lineAngle);

            for (i = 1; i < slices && result === null; i++) {
                // move line perpendicular to angle
                dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
                extension = {
                    y: dir * xdir,
                    x: dir * ydir
                };
                line[0].y += extension.x;
                line[0].x -= extension.y;
                line[1].y += extension.x;
                line[1].x -= extension.y;

                result = tryDecode(line);
            }
            return result;
        }

        function getLineLength(line) {
            return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
        }

        /**
         * With the help of the configured readers (Code128 or EAN) this function tries to detect a
         * valid barcode pattern within the given area.
         * @param {Object} box The area to search in
         * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
         */
        function _decodeFromBoundingBox(box) {
            var line,
                lineAngle,
                ctx = _canvas.ctx.overlay,
                result,
                lineLength;

            if (false) {
                if (config.debug.drawBoundingBox && ctx) {
                    _image_debug2.default.drawPath(box, { x: 0, y: 1 }, ctx, { color: "blue", lineWidth: 2 });
                }
            }

            line = getLine(box);
            lineLength = getLineLength(line);
            lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
            line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));
            if (line === null) {
                return null;
            }

            result = tryDecode(line);
            if (result === null) {
                result = tryDecodeBruteForce(box, line, lineAngle);
            }

            if (result === null) {
                return null;
            }

            if (false) {
                _image_debug2.default.drawPath(line, { x: 'x', y: 'y' }, ctx, { color: 'red', lineWidth: 3 });
            }

            return {
                codeResult: result.codeResult,
                line: line,
                angle: lineAngle,
                pattern: result.barcodeLine.line,
                threshold: result.barcodeLine.threshold
            };
        }

        return {
            decodeFromBoundingBox: function decodeFromBoundingBox(box) {
                return _decodeFromBoundingBox(box);
            },
            decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
                var i,
                    result,
                    barcodes = [],
                    multiple = config.multiple;

                for (i = 0; i < boxes.length; i++) {
                    var box = boxes[i];
                    result = _decodeFromBoundingBox(box) || {};
                    result.box = box;

                    if (multiple) {
                        barcodes.push(result);
                    } else if (result.codeResult) {
                        return result;
                    }
                }

                if (multiple) {
                    return {
                        barcodes: barcodes
                    };
                }
            },
            setReaders: function setReaders(readers) {
                config.readers = readers;
                _barcodeReaders.length = 0;
                initReaders();
            }
        };
    }
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _image_wrapper = __webpack_require__(20);

var _image_wrapper2 = _interopRequireDefault(_image_wrapper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Bresenham = {};

var Slope = {
    DIR: {
        UP: 1,
        DOWN: -1
    }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */
Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
    var x0 = p1.x | 0,
        y0 = p1.y | 0,
        x1 = p2.x | 0,
        y1 = p2.y | 0,
        steep = Math.abs(y1 - y0) > Math.abs(x1 - x0),
        deltax,
        deltay,
        error,
        ystep,
        y,
        tmp,
        x,
        line = [],
        imageData = imageWrapper.data,
        width = imageWrapper.size.x,
        sum = 0,
        val,
        min = 255,
        max = 0;

    function read(a, b) {
        val = imageData[b * width + a];
        sum += val;
        min = val < min ? val : min;
        max = val > max ? val : max;
        line.push(val);
    }

    if (steep) {
        tmp = x0;
        x0 = y0;
        y0 = tmp;

        tmp = x1;
        x1 = y1;
        y1 = tmp;
    }
    if (x0 > x1) {
        tmp = x0;
        x0 = x1;
        x1 = tmp;

        tmp = y0;
        y0 = y1;
        y1 = tmp;
    }
    deltax = x1 - x0;
    deltay = Math.abs(y1 - y0);
    error = deltax / 2 | 0;
    y = y0;
    ystep = y0 < y1 ? 1 : -1;
    for (x = x0; x < x1; x++) {
        if (steep) {
            read(y, x);
        } else {
            read(x, y);
        }
        error = error - deltay;
        if (error < 0) {
            y = y + ystep;
            error = error + deltax;
        }
    }

    return {
        line: line,
        min: min,
        max: max
    };
};

/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */
Bresenham.toBinaryLine = function (result) {
    var min = result.min,
        max = result.max,
        line = result.line,
        slope,
        slope2,
        center = min + (max - min) / 2,
        extrema = [],
        currentDir,
        dir,
        threshold = (max - min) / 12,
        rThreshold = -threshold,
        i,
        j;

    // 1. find extrema
    currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
    extrema.push({
        pos: 0,
        val: line[0]
    });
    for (i = 0; i < line.length - 2; i++) {
        slope = line[i + 1] - line[i];
        slope2 = line[i + 2] - line[i + 1];
        if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
            dir = Slope.DIR.DOWN;
        } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
            dir = Slope.DIR.UP;
        } else {
            dir = currentDir;
        }

        if (currentDir !== dir) {
            extrema.push({
                pos: i,
                val: line[i]
            });
            currentDir = dir;
        }
    }
    extrema.push({
        pos: line.length,
        val: line[line.length - 1]
    });

    for (j = extrema[0].pos; j < extrema[1].pos; j++) {
        line[j] = line[j] > center ? 0 : 1;
    }

    // iterate over extrema and convert to binary based on avg between minmax
    for (i = 1; i < extrema.length - 1; i++) {
        if (extrema[i + 1].val > extrema[i].val) {
            threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
        } else {
            threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
        }

        for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
            line[j] = line[j] > threshold ? 0 : 1;
        }
    }

    return {
        line: line,
        threshold: threshold
    };
};

/**
 * Used for development only
 */
Bresenham.debug = {
    printFrequency: function printFrequency(line, canvas) {
        var i,
            ctx = canvas.getContext("2d");
        canvas.width = line.length;
        canvas.height = 256;

        ctx.beginPath();
        ctx.strokeStyle = "blue";
        for (i = 0; i < line.length; i++) {
            ctx.moveTo(i, 255);
            ctx.lineTo(i, 255 - line[i]);
        }
        ctx.stroke();
        ctx.closePath();
    },

    printPattern: function printPattern(line, canvas) {
        var ctx = canvas.getContext("2d"),
            i;

        canvas.width = line.length;
        ctx.fillColor = "black";
        for (i = 0; i < line.length; i++) {
            if (line[i] === 1) {
                ctx.fillRect(i, 0, 1, 100);
            }
        }
    }
};

exports.default = Bresenham;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _pick2 = __webpack_require__(163);

var _pick3 = _interopRequireDefault(_pick2);

exports.pickConstraints = pickConstraints;

var _mediaDevices = __webpack_require__(55);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var facingMatching = {
    "user": /front/i,
    "environment": /back/i
};

var streamRef;

function waitForVideo(video) {
    return new Promise(function (resolve, reject) {
        var attempts = 10;

        function checkVideo() {
            if (attempts > 0) {
                if (video.videoWidth > 10 && video.videoHeight > 10) {
                    if (false) {
                        console.log(video.videoWidth + "px x " + video.videoHeight + "px");
                    }
                    resolve();
                } else {
                    window.setTimeout(checkVideo, 500);
                }
            } else {
                reject('Unable to play video stream. Is webcam working?');
            }
            attempts--;
        }
        checkVideo();
    });
}

/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */
function initCamera(video, constraints) {
    return (0, _mediaDevices.getUserMedia)(constraints).then(function (stream) {
        return new Promise(function (resolve) {
            streamRef = stream;
            video.setAttribute("autoplay", true);
            video.setAttribute('muted', true);
            video.setAttribute('playsinline', true);
            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
                video.play();
                resolve();
            });
        });
    }).then(waitForVideo.bind(null, video));
}

function deprecatedConstraints(videoConstraints) {
    var normalized = (0, _pick3.default)(videoConstraints, ["width", "height", "facingMode", "aspectRatio", "deviceId"]);

    if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
        normalized.aspectRatio = videoConstraints.minAspectRatio;
        console.log("WARNING: Constraint 'minAspectRatio' is deprecated; Use 'aspectRatio' instead");
    }
    if (typeof videoConstraints.facing !== 'undefined') {
        normalized.facingMode = videoConstraints.facing;
        console.log("WARNING: Constraint 'facing' is deprecated. Use 'facingMode' instead'");
    }
    return normalized;
}

function pickConstraints(videoConstraints) {
    var normalizedConstraints = {
        audio: false,
        video: deprecatedConstraints(videoConstraints)
    };

    if (normalizedConstraints.video.deviceId && normalizedConstraints.video.facingMode) {
        delete normalizedConstraints.video.facingMode;
    }
    return Promise.resolve(normalizedConstraints);
}

function enumerateVideoDevices() {
    return (0, _mediaDevices.enumerateDevices)().then(function (devices) {
        return devices.filter(function (device) {
            return device.kind === 'videoinput';
        });
    });
}

function getActiveTrack() {
    if (streamRef) {
        var tracks = streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            return tracks[0];
        }
    }
}

exports.default = {
    request: function request(video, videoConstraints) {
        return pickConstraints(videoConstraints).then(initCamera.bind(null, video));
    },
    release: function release() {
        var tracks = streamRef && streamRef.getVideoTracks();
        if (tracks && tracks.length) {
            tracks[0].stop();
        }
        streamRef = null;
    },
    enumerateVideoDevices: enumerateVideoDevices,
    getActiveStreamLabel: function getActiveStreamLabel() {
        var track = getActiveTrack();
        return track ? track.label : '';
    },
    getActiveTrack: getActiveTrack
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
    ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory();
})(undefined, function () {
    'use strict';

    (function (global, factory) {
        ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.QrCode = factory();
    })(undefined, function () {
        'use strict';

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function ErrorCorrectionLevel(ordinal, bits, name) {
            this.ordinal_Renamed_Field = ordinal;
            this.bits = bits;
            this.name = name;
        }

        ErrorCorrectionLevel.prototype.ordinal = function () {
            return this.ordinal_Renamed_Field;
        };

        ErrorCorrectionLevel.forBits = function (bits) {
            if (bits < 0 || bits >= FOR_BITS.length) {
                throw "ArgumentException";
            }
            return FOR_BITS[bits];
        };

        var FOR_BITS = [new ErrorCorrectionLevel(1, 0x00, "M"), new ErrorCorrectionLevel(0, 0x01, "L"), new ErrorCorrectionLevel(3, 0x02, "H"), new ErrorCorrectionLevel(2, 0x03, "Q")];

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        var FORMAT_INFO_MASK_QR = 0x5412;
        var FORMAT_INFO_DECODE_LOOKUP = [[0x5412, 0x00], [0x5125, 0x01], [0x5E7C, 0x02], [0x5B4B, 0x03], [0x45F9, 0x04], [0x40CE, 0x05], [0x4F97, 0x06], [0x4AA0, 0x07], [0x77C4, 0x08], [0x72F3, 0x09], [0x7DAA, 0x0A], [0x789D, 0x0B], [0x662F, 0x0C], [0x6318, 0x0D], [0x6C41, 0x0E], [0x6976, 0x0F], [0x1689, 0x10], [0x13BE, 0x11], [0x1CE7, 0x12], [0x19D0, 0x13], [0x0762, 0x14], [0x0255, 0x15], [0x0D0C, 0x16], [0x083B, 0x17], [0x355F, 0x18], [0x3068, 0x19], [0x3F31, 0x1A], [0x3A06, 0x1B], [0x24B4, 0x1C], [0x2183, 0x1D], [0x2EDA, 0x1E], [0x2BED, 0x1F]];
        var BITS_SET_IN_HALF_BYTE = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4];

        function FormatInformation(formatInfo) {
            this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 0x03);
            this.dataMask = formatInfo & 0x07;
        }

        FormatInformation.prototype.GetHashCode = function () {
            return this.errorCorrectionLevel.ordinal() << 3 | this.dataMask;
        };

        FormatInformation.prototype.Equals = function (o) {
            var other = o;
            return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
        };

        FormatInformation.numBitsDiffering = function (a, b) {
            a ^= b; // a now has a 1 bit exactly where its bit differs with b's
            // Count bits set quickly with a series of lookups:
            return BITS_SET_IN_HALF_BYTE[a & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 4) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 8) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 12) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 16) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 20) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 24) & 0x0F] + BITS_SET_IN_HALF_BYTE[URShift(a, 28) & 0x0F];
        };

        FormatInformation.decodeFormatInformation = function (maskedFormatInfo) {
            var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo);
            if (formatInfo !== null) {
                return formatInfo;
            }
            // Should return null, but, some QR codes apparently
            // do not mask this info. Try again by actually masking the pattern
            // first
            return FormatInformation.doDecodeFormatInformation(maskedFormatInfo ^ FORMAT_INFO_MASK_QR);
        };
        FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo) {
            // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
            var bestDifference = 0xffffffff;
            var bestFormatInfo = 0;
            for (var i = 0; i < FORMAT_INFO_DECODE_LOOKUP.length; i++) {
                var decodeInfo = FORMAT_INFO_DECODE_LOOKUP[i];
                var targetInfo = decodeInfo[0];
                if (targetInfo === maskedFormatInfo) {
                    // Found an exact match
                    return new FormatInformation(decodeInfo[1]);
                }
                var bitsDifference = this.numBitsDiffering(maskedFormatInfo, targetInfo);
                if (bitsDifference < bestDifference) {
                    bestFormatInfo = decodeInfo[1];
                    bestDifference = bitsDifference;
                }
            }
            // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits
            // differing means we found a match
            if (bestDifference <= 3) {
                return new FormatInformation(bestFormatInfo);
            }
            return null;
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function BitMatrix(width, height) {
            if (!height) height = width;
            if (width < 1 || height < 1) {
                throw "Both dimensions must be greater than 0";
            }
            this.width = width;
            this.height = height;
            var rowSize = width >> 5;
            if ((width & 0x1f) !== 0) {
                rowSize++;
            }
            this.rowSize = rowSize;
            this.bits = new Array(rowSize * height);
            for (var i = 0; i < this.bits.length; i++) {
                this.bits[i] = 0;
            }
        }

        Object.defineProperty(BitMatrix.prototype, "Dimension", {
            get: function get() {
                if (this.width !== this.height) {
                    throw "Can't call getDimension() on a non-square matrix";
                }
                return this.width;
            }
        });

        BitMatrix.prototype.get_Renamed = function (x, y) {
            var offset = y * this.rowSize + (x >> 5);
            return (URShift(this.bits[offset], x & 0x1f) & 1) !== 0;
        };

        BitMatrix.prototype.set_Renamed = function (x, y) {
            var offset = y * this.rowSize + (x >> 5);
            this.bits[offset] |= 1 << (x & 0x1f);
        };

        BitMatrix.prototype.flip = function (x, y) {
            var offset = y * this.rowSize + (x >> 5);
            this.bits[offset] ^= 1 << (x & 0x1f);
        };

        BitMatrix.prototype.clear = function () {
            var max = this.bits.length;
            for (var i = 0; i < max; i++) {
                this.bits[i] = 0;
            }
        };

        BitMatrix.prototype.setRegion = function (left, top, width, height) {
            if (top < 0 || left < 0) {
                throw "Left and top must be nonnegative";
            }
            if (height < 1 || width < 1) {
                throw "Height and width must be at least 1";
            }
            var right = left + width;
            var bottom = top + height;
            if (bottom > this.height || right > this.width) {
                throw "The region must fit inside the matrix";
            }
            for (var y = top; y < bottom; y++) {
                var offset = y * this.rowSize;
                for (var x = left; x < right; x++) {
                    this.bits[offset + (x >> 5)] |= 1 << (x & 0x1f);
                }
            }
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function ECB(count, dataCodewords) {
            this.count = count;
            this.dataCodewords = dataCodewords;
        }

        function ECBlocks(ecCodewordsPerBlock, ecBlocks1, ecBlocks2) {
            this.ecCodewordsPerBlock = ecCodewordsPerBlock;
            if (ecBlocks2) this.ecBlocks = [ecBlocks1, ecBlocks2];else this.ecBlocks = [ecBlocks1];
        }

        Object.defineProperty(ECBlocks.prototype, "TotalECCodewords", {
            get: function get() {
                return this.ecCodewordsPerBlock * this.NumBlocks;
            }
        });

        Object.defineProperty(ECBlocks.prototype, "NumBlocks", {
            get: function get() {
                var total = 0;
                for (var i = 0; i < this.ecBlocks.length; i++) {
                    total += this.ecBlocks[i].length;
                }
                return total;
            }
        });

        ECBlocks.prototype.getECBlocks = function () {
            return this.ecBlocks;
        };

        function Version(versionNumber, alignmentPatternCenters, ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4) {
            this.versionNumber = versionNumber;
            this.alignmentPatternCenters = alignmentPatternCenters;
            this.ecBlocks = [ecBlocks1, ecBlocks2, ecBlocks3, ecBlocks4];

            var total = 0;
            var ecCodewords = ecBlocks1.ecCodewordsPerBlock;
            var ecbArray = ecBlocks1.getECBlocks();
            for (var i = 0; i < ecbArray.length; i++) {
                var ecBlock = ecbArray[i];
                total += ecBlock.count * (ecBlock.dataCodewords + ecCodewords);
            }
            this.totalCodewords = total;
        }

        Object.defineProperty(Version.prototype, "DimensionForVersion", {
            get: function get() {
                return 17 + 4 * this.versionNumber;
            }
        });

        Version.prototype.buildFunctionPattern = function () {
            var dimension = this.DimensionForVersion;
            var bitMatrix = new BitMatrix(dimension);

            // Top left finder pattern + separator + format
            bitMatrix.setRegion(0, 0, 9, 9);
            // Top right finder pattern + separator + format
            bitMatrix.setRegion(dimension - 8, 0, 8, 9);
            // Bottom left finder pattern + separator + format
            bitMatrix.setRegion(0, dimension - 8, 9, 8);

            // Alignment patterns
            var max = this.alignmentPatternCenters.length;
            for (var x = 0; x < max; x++) {
                var i = this.alignmentPatternCenters[x] - 2;
                for (var y = 0; y < max; y++) {
                    if (x === 0 && (y === 0 || y === max - 1) || x === max - 1 && y === 0) {
                        // No alignment patterns near the three finder paterns
                        continue;
                    }
                    bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
                }
            }

            // Vertical timing pattern
            bitMatrix.setRegion(6, 9, 1, dimension - 17);
            // Horizontal timing pattern
            bitMatrix.setRegion(9, 6, dimension - 17, 1);

            if (this.versionNumber > 6) {
                // Version info, top right
                bitMatrix.setRegion(dimension - 11, 0, 3, 6);
                // Version info, bottom left
                bitMatrix.setRegion(0, dimension - 11, 6, 3);
            }

            return bitMatrix;
        };

        Version.prototype.getECBlocksForLevel = function (ecLevel) {
            return this.ecBlocks[ecLevel.ordinal()];
        };

        Version.VERSION_DECODE_INFO = [0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6, 0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78, 0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683, 0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB, 0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250, 0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B, 0x2542E, 0x26A64, 0x27541, 0x28C69];

        Version.VERSIONS = buildVersions();

        Version.getVersionForNumber = function (versionNumber) {
            if (versionNumber < 1 || versionNumber > 40) {
                throw "ArgumentException";
            }
            return Version.VERSIONS[versionNumber - 1];
        };

        Version.getProvisionalVersionForDimension = function (dimension) {
            if (dimension % 4 !== 1) {
                throw "Error getProvisionalVersionForDimension";
            }
            try {
                return Version.getVersionForNumber(dimension - 17 >> 2);
            } catch (iae) {
                throw "Error getVersionForNumber";
            }
        };

        Version.decodeVersionInformation = function (versionBits) {
            var bestDifference = 0xffffffff;
            var bestVersion = 0;
            for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
                var targetVersion = Version.VERSION_DECODE_INFO[i];
                // Do the version info bits match exactly? done.
                if (targetVersion === versionBits) {
                    return this.getVersionForNumber(i + 7);
                }
                // Otherwise see if this is the closest to a real version info bit string
                // we have seen so far
                var bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
                if (bitsDifference < bestDifference) {
                    bestVersion = i + 7;
                    bestDifference = bitsDifference;
                }
            }
            // We can tolerate up to 3 bits of error since no two version info codewords will
            // differ in less than 4 bits.
            if (bestDifference <= 3) {
                return this.getVersionForNumber(bestVersion);
            }
            // If we didn't find a close enough match, fail
            return null;
        };

        function buildVersions() {
            return [new Version(1, [], new ECBlocks(7, new ECB(1, 19)), new ECBlocks(10, new ECB(1, 16)), new ECBlocks(13, new ECB(1, 13)), new ECBlocks(17, new ECB(1, 9))), new Version(2, [6, 18], new ECBlocks(10, new ECB(1, 34)), new ECBlocks(16, new ECB(1, 28)), new ECBlocks(22, new ECB(1, 22)), new ECBlocks(28, new ECB(1, 16))), new Version(3, [6, 22], new ECBlocks(15, new ECB(1, 55)), new ECBlocks(26, new ECB(1, 44)), new ECBlocks(18, new ECB(2, 17)), new ECBlocks(22, new ECB(2, 13))), new Version(4, [6, 26], new ECBlocks(20, new ECB(1, 80)), new ECBlocks(18, new ECB(2, 32)), new ECBlocks(26, new ECB(2, 24)), new ECBlocks(16, new ECB(4, 9))), new Version(5, [6, 30], new ECBlocks(26, new ECB(1, 108)), new ECBlocks(24, new ECB(2, 43)), new ECBlocks(18, new ECB(2, 15), new ECB(2, 16)), new ECBlocks(22, new ECB(2, 11), new ECB(2, 12))), new Version(6, [6, 34], new ECBlocks(18, new ECB(2, 68)), new ECBlocks(16, new ECB(4, 27)), new ECBlocks(24, new ECB(4, 19)), new ECBlocks(28, new ECB(4, 15))), new Version(7, [6, 22, 38], new ECBlocks(20, new ECB(2, 78)), new ECBlocks(18, new ECB(4, 31)), new ECBlocks(18, new ECB(2, 14), new ECB(4, 15)), new ECBlocks(26, new ECB(4, 13), new ECB(1, 14))), new Version(8, [6, 24, 42], new ECBlocks(24, new ECB(2, 97)), new ECBlocks(22, new ECB(2, 38), new ECB(2, 39)), new ECBlocks(22, new ECB(4, 18), new ECB(2, 19)), new ECBlocks(26, new ECB(4, 14), new ECB(2, 15))), new Version(9, [6, 26, 46], new ECBlocks(30, new ECB(2, 116)), new ECBlocks(22, new ECB(3, 36), new ECB(2, 37)), new ECBlocks(20, new ECB(4, 16), new ECB(4, 17)), new ECBlocks(24, new ECB(4, 12), new ECB(4, 13))), new Version(10, [6, 28, 50], new ECBlocks(18, new ECB(2, 68), new ECB(2, 69)), new ECBlocks(26, new ECB(4, 43), new ECB(1, 44)), new ECBlocks(24, new ECB(6, 19), new ECB(2, 20)), new ECBlocks(28, new ECB(6, 15), new ECB(2, 16))), new Version(11, [6, 30, 54], new ECBlocks(20, new ECB(4, 81)), new ECBlocks(30, new ECB(1, 50), new ECB(4, 51)), new ECBlocks(28, new ECB(4, 22), new ECB(4, 23)), new ECBlocks(24, new ECB(3, 12), new ECB(8, 13))), new Version(12, [6, 32, 58], new ECBlocks(24, new ECB(2, 92), new ECB(2, 93)), new ECBlocks(22, new ECB(6, 36), new ECB(2, 37)), new ECBlocks(26, new ECB(4, 20), new ECB(6, 21)), new ECBlocks(28, new ECB(7, 14), new ECB(4, 15))), new Version(13, [6, 34, 62], new ECBlocks(26, new ECB(4, 107)), new ECBlocks(22, new ECB(8, 37), new ECB(1, 38)), new ECBlocks(24, new ECB(8, 20), new ECB(4, 21)), new ECBlocks(22, new ECB(12, 11), new ECB(4, 12))), new Version(14, [6, 26, 46, 66], new ECBlocks(30, new ECB(3, 115), new ECB(1, 116)), new ECBlocks(24, new ECB(4, 40), new ECB(5, 41)), new ECBlocks(20, new ECB(11, 16), new ECB(5, 17)), new ECBlocks(24, new ECB(11, 12), new ECB(5, 13))), new Version(15, [6, 26, 48, 70], new ECBlocks(22, new ECB(5, 87), new ECB(1, 88)), new ECBlocks(24, new ECB(5, 41), new ECB(5, 42)), new ECBlocks(30, new ECB(5, 24), new ECB(7, 25)), new ECBlocks(24, new ECB(11, 12), new ECB(7, 13))), new Version(16, [6, 26, 50, 74], new ECBlocks(24, new ECB(5, 98), new ECB(1, 99)), new ECBlocks(28, new ECB(7, 45), new ECB(3, 46)), new ECBlocks(24, new ECB(15, 19), new ECB(2, 20)), new ECBlocks(30, new ECB(3, 15), new ECB(13, 16))), new Version(17, [6, 30, 54, 78], new ECBlocks(28, new ECB(1, 107), new ECB(5, 108)), new ECBlocks(28, new ECB(10, 46), new ECB(1, 47)), new ECBlocks(28, new ECB(1, 22), new ECB(15, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(17, 15))), new Version(18, [6, 30, 56, 82], new ECBlocks(30, new ECB(5, 120), new ECB(1, 121)), new ECBlocks(26, new ECB(9, 43), new ECB(4, 44)), new ECBlocks(28, new ECB(17, 22), new ECB(1, 23)), new ECBlocks(28, new ECB(2, 14), new ECB(19, 15))), new Version(19, [6, 30, 58, 86], new ECBlocks(28, new ECB(3, 113), new ECB(4, 114)), new ECBlocks(26, new ECB(3, 44), new ECB(11, 45)), new ECBlocks(26, new ECB(17, 21), new ECB(4, 22)), new ECBlocks(26, new ECB(9, 13), new ECB(16, 14))), new Version(20, [6, 34, 62, 90], new ECBlocks(28, new ECB(3, 107), new ECB(5, 108)), new ECBlocks(26, new ECB(3, 41), new ECB(13, 42)), new ECBlocks(30, new ECB(15, 24), new ECB(5, 25)), new ECBlocks(28, new ECB(15, 15), new ECB(10, 16))), new Version(21, [6, 28, 50, 72, 94], new ECBlocks(28, new ECB(4, 116), new ECB(4, 117)), new ECBlocks(26, new ECB(17, 42)), new ECBlocks(28, new ECB(17, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(19, 16), new ECB(6, 17))), new Version(22, [6, 26, 50, 74, 98], new ECBlocks(28, new ECB(2, 111), new ECB(7, 112)), new ECBlocks(28, new ECB(17, 46)), new ECBlocks(30, new ECB(7, 24), new ECB(16, 25)), new ECBlocks(24, new ECB(34, 13))), new Version(23, [6, 30, 54, 74, 102], new ECBlocks(30, new ECB(4, 121), new ECB(5, 122)), new ECBlocks(28, new ECB(4, 47), new ECB(14, 48)), new ECBlocks(30, new ECB(11, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(16, 15), new ECB(14, 16))), new Version(24, [6, 28, 54, 80, 106], new ECBlocks(30, new ECB(6, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(6, 45), new ECB(14, 46)), new ECBlocks(30, new ECB(11, 24), new ECB(16, 25)), new ECBlocks(30, new ECB(30, 16), new ECB(2, 17))), new Version(25, [6, 32, 58, 84, 110], new ECBlocks(26, new ECB(8, 106), new ECB(4, 107)), new ECBlocks(28, new ECB(8, 47), new ECB(13, 48)), new ECBlocks(30, new ECB(7, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(13, 16))), new Version(26, [6, 30, 58, 86, 114], new ECBlocks(28, new ECB(10, 114), new ECB(2, 115)), new ECBlocks(28, new ECB(19, 46), new ECB(4, 47)), new ECBlocks(28, new ECB(28, 22), new ECB(6, 23)), new ECBlocks(30, new ECB(33, 16), new ECB(4, 17))), new Version(27, [6, 34, 62, 90, 118], new ECBlocks(30, new ECB(8, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(22, 45), new ECB(3, 46)), new ECBlocks(30, new ECB(8, 23), new ECB(26, 24)), new ECBlocks(30, new ECB(12, 15), new ECB(28, 16))), new Version(28, [6, 26, 50, 74, 98, 122], new ECBlocks(30, new ECB(3, 117), new ECB(10, 118)), new ECBlocks(28, new ECB(3, 45), new ECB(23, 46)), new ECBlocks(30, new ECB(4, 24), new ECB(31, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(31, 16))), new Version(29, [6, 30, 54, 78, 102, 126], new ECBlocks(30, new ECB(7, 116), new ECB(7, 117)), new ECBlocks(28, new ECB(21, 45), new ECB(7, 46)), new ECBlocks(30, new ECB(1, 23), new ECB(37, 24)), new ECBlocks(30, new ECB(19, 15), new ECB(26, 16))), new Version(30, [6, 26, 52, 78, 104, 130], new ECBlocks(30, new ECB(5, 115), new ECB(10, 116)), new ECBlocks(28, new ECB(19, 47), new ECB(10, 48)), new ECBlocks(30, new ECB(15, 24), new ECB(25, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(25, 16))), new Version(31, [6, 30, 56, 82, 108, 134], new ECBlocks(30, new ECB(13, 115), new ECB(3, 116)), new ECBlocks(28, new ECB(2, 46), new ECB(29, 47)), new ECBlocks(30, new ECB(42, 24), new ECB(1, 25)), new ECBlocks(30, new ECB(23, 15), new ECB(28, 16))), new Version(32, [6, 34, 60, 86, 112, 138], new ECBlocks(30, new ECB(17, 115)), new ECBlocks(28, new ECB(10, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(10, 24), new ECB(35, 25)), new ECBlocks(30, new ECB(19, 15), new ECB(35, 16))), new Version(33, [6, 30, 58, 86, 114, 142], new ECBlocks(30, new ECB(17, 115), new ECB(1, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(21, 47)), new ECBlocks(30, new ECB(29, 24), new ECB(19, 25)), new ECBlocks(30, new ECB(11, 15), new ECB(46, 16))), new Version(34, [6, 34, 62, 90, 118, 146], new ECBlocks(30, new ECB(13, 115), new ECB(6, 116)), new ECBlocks(28, new ECB(14, 46), new ECB(23, 47)), new ECBlocks(30, new ECB(44, 24), new ECB(7, 25)), new ECBlocks(30, new ECB(59, 16), new ECB(1, 17))), new Version(35, [6, 30, 54, 78, 102, 126, 150], new ECBlocks(30, new ECB(12, 121), new ECB(7, 122)), new ECBlocks(28, new ECB(12, 47), new ECB(26, 48)), new ECBlocks(30, new ECB(39, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(22, 15), new ECB(41, 16))), new Version(36, [6, 24, 50, 76, 102, 128, 154], new ECBlocks(30, new ECB(6, 121), new ECB(14, 122)), new ECBlocks(28, new ECB(6, 47), new ECB(34, 48)), new ECBlocks(30, new ECB(46, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(2, 15), new ECB(64, 16))), new Version(37, [6, 28, 54, 80, 106, 132, 158], new ECBlocks(30, new ECB(17, 122), new ECB(4, 123)), new ECBlocks(28, new ECB(29, 46), new ECB(14, 47)), new ECBlocks(30, new ECB(49, 24), new ECB(10, 25)), new ECBlocks(30, new ECB(24, 15), new ECB(46, 16))), new Version(38, [6, 32, 58, 84, 110, 136, 162], new ECBlocks(30, new ECB(4, 122), new ECB(18, 123)), new ECBlocks(28, new ECB(13, 46), new ECB(32, 47)), new ECBlocks(30, new ECB(48, 24), new ECB(14, 25)), new ECBlocks(30, new ECB(42, 15), new ECB(32, 16))), new Version(39, [6, 26, 54, 82, 110, 138, 166], new ECBlocks(30, new ECB(20, 117), new ECB(4, 118)), new ECBlocks(28, new ECB(40, 47), new ECB(7, 48)), new ECBlocks(30, new ECB(43, 24), new ECB(22, 25)), new ECBlocks(30, new ECB(10, 15), new ECB(67, 16))), new Version(40, [6, 30, 58, 86, 114, 142, 170], new ECBlocks(30, new ECB(19, 118), new ECB(6, 119)), new ECBlocks(28, new ECB(18, 47), new ECB(31, 48)), new ECBlocks(30, new ECB(34, 24), new ECB(34, 25)), new ECBlocks(30, new ECB(20, 15), new ECB(61, 16)))];
        }

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function AlignmentPattern(posX, posY, estimatedModuleSize) {
            this.x = posX;
            this.y = posY;
            this.count = 1;
            this.estimatedModuleSize = estimatedModuleSize;
        }

        Object.defineProperty(AlignmentPattern.prototype, "X", {
            get: function get() {
                return Math.floor(this.x);
            }
        });

        Object.defineProperty(AlignmentPattern.prototype, "Y", {
            get: function get() {
                return Math.floor(this.y);
            }
        });

        AlignmentPattern.prototype.incrementCount = function () {
            this.count++;
        };

        AlignmentPattern.prototype.aboutEquals = function (moduleSize, i, j) {
            if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {
                var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
                return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;
            }
            return false;
        };

        function AlignmentPatternFinder(image, startX, startY, width, height, moduleSize, resultPointCallback) {
            this.image = image;
            this.possibleCenters = [];
            this.startX = startX;
            this.startY = startY;
            this.width = width;
            this.height = height;
            this.moduleSize = moduleSize;
            this.crossCheckStateCount = [0, 0, 0];
            this.resultPointCallback = resultPointCallback;
        }

        AlignmentPatternFinder.prototype.centerFromEnd = function (stateCount, end) {
            return end - stateCount[2] - stateCount[1] / 2.0;
        };

        AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {
            var moduleSize = this.moduleSize;
            var maxVariance = moduleSize / 2.0;
            for (var i = 0; i < 3; i++) {
                if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
                    return false;
                }
            }
            return true;
        };

        AlignmentPatternFinder.prototype.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {
            var image = this.image;

            var maxI = image.height;
            var stateCount = this.crossCheckStateCount;
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;

            // Start counting up from center
            var i = startI;
            while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i--;
            }
            // If already too many modules in this state or ran off the edge:
            if (i < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {
                stateCount[0]++;
                i--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }

            // Now also count down from center
            i = startI + 1;
            while (i < maxI && image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i++;
            }
            if (i === maxI || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[2] <= maxCount) {
                stateCount[2]++;
                i++;
            }
            if (stateCount[2] > maxCount) {
                return NaN;
            }

            var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
                return NaN;
            }

            return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;
        };

        AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i, j) {
            var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
            var centerJ = this.centerFromEnd(stateCount, j);
            var centerI = this.crossCheckVertical(i, Math.floor(centerJ), 2 * stateCount[1], stateCountTotal);
            if (!isNaN(centerI)) {
                var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
                var max = this.possibleCenters.length;
                for (var index = 0; index < max; index++) {
                    var center = this.possibleCenters[index];
                    // Look for about the same center and module size:
                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                        return new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
                    }
                }
                // Hadn't found this before; save it
                var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
                this.possibleCenters.push(point);
                if (this.resultPointCallback !== null) {
                    this.resultPointCallback.foundPossibleResultPoint(point);
                }
            }
            return null;
        };

        AlignmentPatternFinder.prototype.find = function () {
            var image = this.image;
            var startX = this.startX;
            var height = this.height;
            var maxJ = startX + this.width;
            var middleI = this.startY + (height >> 1);
            // We are looking for black/white/black modules in 1:1:1 ratio;
            // this tracks the number of black/white/black modules seen so far
            var stateCount = [0, 0, 0];
            for (var iGen = 0; iGen < height; iGen++) {
                // Search from middle outwards
                var i = middleI + ((iGen & 0x01) === 0 ? iGen + 1 >> 1 : -(iGen + 1 >> 1));
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                var j = startX;
                // Burn off leading white pixels before anything else; if we start in the middle of
                // a white run, it doesn't make sense to count its length, since we don't know if the
                // white run continued to the left of the start point
                while (j < maxJ && !image.data[j + image.width * i]) {
                    j++;
                }
                var currentState = 0;
                while (j < maxJ) {
                    if (image.data[j + i * image.width]) {
                        // Black pixel
                        if (currentState === 1) {
                            // Counting black pixels
                            stateCount[currentState]++;
                        } else {
                            // Counting white pixels
                            if (currentState === 2) {
                                // A winner?
                                if (this.foundPatternCross(stateCount)) {
                                    // Yes
                                    var confirmed = this.handlePossibleCenter(stateCount, i, j);
                                    if (confirmed !== null) {
                                        return confirmed;
                                    }
                                }
                                stateCount[0] = stateCount[2];
                                stateCount[1] = 1;
                                stateCount[2] = 0;
                                currentState = 1;
                            } else {
                                stateCount[++currentState]++;
                            }
                        }
                    } else {
                        // White pixel
                        if (currentState === 1) {
                            // Counting black pixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    }
                    j++;
                }
                if (this.foundPatternCross(stateCount)) {
                    var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                    if (confirmed !== null) {
                        return confirmed;
                    }
                }
            }

            // Hmm, nothing we saw was observed and confirmed twice. If we had
            // any guess at all, return it.
            if (!(this.possibleCenters.length === 0)) {
                return this.possibleCenters[0];
            }

            throw "Couldn't find enough alignment patterns";
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        var GridSampler = {};

        GridSampler.checkAndNudgePoints = function (image, points) {
            var width = image.width;
            var height = image.height;
            // Check and nudge points from start until we see some that are OK:
            var nudged = true;
            for (var offset = 0; offset < points.length && nudged; offset += 2) {
                var x = Math.floor(points[offset]);
                var y = Math.floor(points[offset + 1]);
                if (x < -1 || x > width || y < -1 || y > height) {
                    throw "Error.checkAndNudgePoints ";
                }
                nudged = false;
                if (x === -1) {
                    points[offset] = 0.0;
                    nudged = true;
                } else if (x === width) {
                    points[offset] = width - 1;
                    nudged = true;
                }
                if (y === -1) {
                    points[offset + 1] = 0.0;
                    nudged = true;
                } else if (y === height) {
                    points[offset + 1] = height - 1;
                    nudged = true;
                }
            }
            // Check and nudge points from end:
            nudged = true;
            for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
                var x = Math.floor(points[offset]);
                var y = Math.floor(points[offset + 1]);
                if (x < -1 || x > width || y < -1 || y > height) {
                    throw "Error.checkAndNudgePoints ";
                }
                nudged = false;
                if (x === -1) {
                    points[offset] = 0.0;
                    nudged = true;
                } else if (x === width) {
                    points[offset] = width - 1;
                    nudged = true;
                }
                if (y === -1) {
                    points[offset + 1] = 0.0;
                    nudged = true;
                } else if (y === height) {
                    points[offset + 1] = height - 1;
                    nudged = true;
                }
            }
        };

        GridSampler.sampleGrid3 = function (image, dimension, transform) {
            var bits = new BitMatrix(dimension);
            var points = new Array(dimension << 1);
            for (var y = 0; y < dimension; y++) {
                var max = points.length;
                var iValue = y + 0.5;
                for (var x = 0; x < max; x += 2) {
                    points[x] = (x >> 1) + 0.5;
                    points[x + 1] = iValue;
                }
                transform.transformPoints1(points);
                // Quick check to see if points transformed to something inside the image
                // sufficient to check the endpoints
                GridSampler.checkAndNudgePoints(image, points);
                try {
                    for (var x = 0; x < max; x += 2) {
                        var bit = image.data[Math.floor(points[x]) + image.width * Math.floor(points[x + 1])];
                        if (bit) bits.set_Renamed(x >> 1, y);
                    }
                } catch (aioobe) {
                    // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
                    // transform gets "twisted" such that it maps a straight line of points to a set of points
                    // whose endpoints are in bounds, but others are not. There is probably some mathematical
                    // way to detect this about the transformation that I don't know yet.
                    // This results in an ugly runtime exception despite our clever checks above -- can't have
                    // that. We could check each point's coordinates but that feels duplicative. We settle for
                    // catching and wrapping ArrayIndexOutOfBoundsException.
                    throw "Error.checkAndNudgePoints";
                }
            }
            return bits;
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        var MIN_SKIP = 3;
        var MAX_MODULES = 57;
        var INTEGER_MATH_SHIFT = 8;
        var CENTER_QUORUM = 2;

        function orderBestPatterns(patterns) {

            function distance(pattern1, pattern2) {
                var xDiff = pattern1.X - pattern2.X;
                var yDiff = pattern1.Y - pattern2.Y;
                return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
            }

            /// <summary> Returns the z component of the cross product between vectors BC and BA.</summary>
            function crossProductZ(pointA, pointB, pointC) {
                var bX = pointB.x;
                var bY = pointB.y;
                return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
            }

            // Find distances between pattern centers
            var zeroOneDistance = distance(patterns[0], patterns[1]);
            var oneTwoDistance = distance(patterns[1], patterns[2]);
            var zeroTwoDistance = distance(patterns[0], patterns[2]);

            var pointA, pointB, pointC;
            // Assume one closest to other two is B; A and C will just be guesses at first
            if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
                pointB = patterns[0];
                pointA = patterns[1];
                pointC = patterns[2];
            } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
                pointB = patterns[1];
                pointA = patterns[0];
                pointC = patterns[2];
            } else {
                pointB = patterns[2];
                pointA = patterns[0];
                pointC = patterns[1];
            }

            // Use cross product to figure out whether A and C are correct or flipped.
            // This asks whether BC x BA has a positive z component, which is the arrangement
            // we want for A, B, C. If it's negative, then we've got it flipped around and
            // should swap A and C.
            if (crossProductZ(pointA, pointB, pointC) < 0.0) {
                var temp = pointA;
                pointA = pointC;
                pointC = temp;
            }

            patterns[0] = pointA;
            patterns[1] = pointB;
            patterns[2] = pointC;
        }

        function FinderPattern(posX, posY, estimatedModuleSize) {
            this.x = posX;
            this.y = posY;
            this.count = 1;
            this.estimatedModuleSize = estimatedModuleSize;
        }

        Object.defineProperty(FinderPattern.prototype, "X", {
            get: function get() {
                return this.x;
            }
        });

        Object.defineProperty(FinderPattern.prototype, "Y", {
            get: function get() {
                return this.y;
            }
        });

        FinderPattern.prototype.incrementCount = function () {
            this.count++;
        };

        FinderPattern.prototype.aboutEquals = function (moduleSize, i, j) {
            if (Math.abs(i - this.y) <= moduleSize && Math.abs(j - this.x) <= moduleSize) {
                var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
                return moduleSizeDiff <= 1.0 || moduleSizeDiff / this.estimatedModuleSize <= 1.0;
            }
            return false;
        };

        function FinderPatternInfo(patternCenters) {
            this.bottomLeft = patternCenters[0];
            this.topLeft = patternCenters[1];
            this.topRight = patternCenters[2];
        }

        function FinderPatternFinder() {
            this.image = null;
            this.possibleCenters = [];
            this.hasSkipped = false;
            this.crossCheckStateCount = [0, 0, 0, 0, 0];
            this.resultPointCallback = null;
        }

        Object.defineProperty(FinderPatternFinder.prototype, "CrossCheckStateCount", {
            get: function get() {
                this.crossCheckStateCount[0] = 0;
                this.crossCheckStateCount[1] = 0;
                this.crossCheckStateCount[2] = 0;
                this.crossCheckStateCount[3] = 0;
                this.crossCheckStateCount[4] = 0;
                return this.crossCheckStateCount;
            }
        });

        FinderPatternFinder.prototype.foundPatternCross = function (stateCount) {
            var totalModuleSize = 0;
            for (var i = 0; i < 5; i++) {
                var count = stateCount[i];
                if (count === 0) {
                    return false;
                }
                totalModuleSize += count;
            }
            if (totalModuleSize < 7) {
                return false;
            }
            var moduleSize = Math.floor((totalModuleSize << INTEGER_MATH_SHIFT) / 7);
            var maxVariance = Math.floor(moduleSize / 2);
            // Allow less than 50% variance from 1-1-3-1-1 proportions
            return Math.abs(moduleSize - (stateCount[0] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[1] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(3 * moduleSize - (stateCount[2] << INTEGER_MATH_SHIFT)) < 3 * maxVariance && Math.abs(moduleSize - (stateCount[3] << INTEGER_MATH_SHIFT)) < maxVariance && Math.abs(moduleSize - (stateCount[4] << INTEGER_MATH_SHIFT)) < maxVariance;
        };

        FinderPatternFinder.prototype.centerFromEnd = function (stateCount, end) {
            return end - stateCount[4] - stateCount[3] - stateCount[2] / 2.0;
        };

        FinderPatternFinder.prototype.crossCheckVertical = function (startI, centerJ, maxCount, originalStateCountTotal) {
            var image = this.image;

            var maxI = image.height;
            var stateCount = this.CrossCheckStateCount;

            // Start counting up from center
            var i = startI;
            while (i >= 0 && image.data[centerJ + i * image.width]) {
                stateCount[2]++;
                i--;
            }
            if (i < 0) {
                return NaN;
            }
            while (i >= 0 && !image.data[centerJ + i * image.width] && stateCount[1] <= maxCount) {
                stateCount[1]++;
                i--;
            }
            // If already too many modules in this state or ran off the edge:
            if (i < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (i >= 0 && image.data[centerJ + i * image.width] && stateCount[0] <= maxCount) {
                stateCount[0]++;
                i--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }

            // Now also count down from center
            i = startI + 1;
            while (i < maxI && image.data[centerJ + i * image.width]) {
                stateCount[2]++;
                i++;
            }
            if (i === maxI) {
                return NaN;
            }
            while (i < maxI && !image.data[centerJ + i * image.width] && stateCount[3] < maxCount) {
                stateCount[3]++;
                i++;
            }
            if (i === maxI || stateCount[3] >= maxCount) {
                return NaN;
            }
            while (i < maxI && image.data[centerJ + i * image.width] && stateCount[4] < maxCount) {
                stateCount[4]++;
                i++;
            }
            if (stateCount[4] >= maxCount) {
                return NaN;
            }

            // If we found a finder-pattern-like section, but its size is more than 40% different than
            // the original, assume it's a false positive
            var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
                return NaN;
            }

            return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, i) : NaN;
        };

        FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ, centerI, maxCount, originalStateCountTotal) {
            var image = this.image;

            var maxJ = image.width;
            var stateCount = this.CrossCheckStateCount;

            var j = startJ;
            while (j >= 0 && image.data[j + centerI * image.width]) {
                stateCount[2]++;
                j--;
            }
            if (j < 0) {
                return NaN;
            }
            while (j >= 0 && !image.data[j + centerI * image.width] && stateCount[1] <= maxCount) {
                stateCount[1]++;
                j--;
            }
            if (j < 0 || stateCount[1] > maxCount) {
                return NaN;
            }
            while (j >= 0 && image.data[j + centerI * image.width] && stateCount[0] <= maxCount) {
                stateCount[0]++;
                j--;
            }
            if (stateCount[0] > maxCount) {
                return NaN;
            }

            j = startJ + 1;
            while (j < maxJ && image.data[j + centerI * image.width]) {
                stateCount[2]++;
                j++;
            }
            if (j === maxJ) {
                return NaN;
            }
            while (j < maxJ && !image.data[j + centerI * image.width] && stateCount[3] < maxCount) {
                stateCount[3]++;
                j++;
            }
            if (j === maxJ || stateCount[3] >= maxCount) {
                return NaN;
            }
            while (j < maxJ && image.data[j + centerI * image.width] && stateCount[4] < maxCount) {
                stateCount[4]++;
                j++;
            }
            if (stateCount[4] >= maxCount) {
                return NaN;
            }

            // If we found a finder-pattern-like section, but its size is significantly different than
            // the original, assume it's a false positive
            var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
                return NaN;
            }

            return this.foundPatternCross(stateCount) ? this.centerFromEnd(stateCount, j) : NaN;
        };

        FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i, j) {
            var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
            var centerJ = this.centerFromEnd(stateCount, j); //float
            var centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal); //float
            if (!isNaN(centerI)) {
                // Re-cross check
                centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);
                if (!isNaN(centerJ)) {
                    var estimatedModuleSize = stateCountTotal / 7.0;
                    var found = false;
                    var max = this.possibleCenters.length;
                    for (var index = 0; index < max; index++) {
                        var center = this.possibleCenters[index];
                        // Look for about the same center and module size:
                        if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                            center.incrementCount();
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        var point = new FinderPattern(centerJ, centerI, estimatedModuleSize);
                        this.possibleCenters.push(point);
                        if (this.resultPointCallback !== null) {
                            this.resultPointCallback.foundPossibleResultPoint(point);
                        }
                    }
                    return true;
                }
            }
            return false;
        };

        FinderPatternFinder.prototype.selectBestPatterns = function () {

            var startSize = this.possibleCenters.length;
            if (startSize < 3) {
                // Couldn't find enough finder patterns
                throw "Couldn't find enough finder patterns:" + startSize + " patterns found";
            }

            // Filter outlier possibilities whose module size is too different
            if (startSize > 3) {
                // But we can only afford to do so if we have at least 4 possibilities to choose from
                var totalModuleSize = 0.0;
                var square = 0.0;
                for (var i = 0; i < startSize; i++) {
                    var centerValue = this.possibleCenters[i].estimatedModuleSize;
                    totalModuleSize += centerValue;
                    square += centerValue * centerValue;
                }
                var average = totalModuleSize / startSize;
                this.possibleCenters.sort(function (center1, center2) {
                    var dA = Math.abs(center2.estimatedModuleSize - average);
                    var dB = Math.abs(center1.estimatedModuleSize - average);
                    if (dA < dB) {
                        return -1;
                    } else if (dA === dB) {
                        return 0;
                    } else {
                        return 1;
                    }
                });

                var stdDev = Math.sqrt(square / startSize - average * average);
                var limit = Math.max(0.2 * average, stdDev);
                for (var i = this.possibleCenters - 1; i >= 0; i--) {
                    var pattern = this.possibleCenters[i];
                    if (Math.abs(pattern.estimatedModuleSize - average) > limit) {
                        this.possibleCenters.splice(i, 1);
                    }
                }
            }

            if (this.possibleCenters.length > 3) {
                // Throw away all but those first size candidate points we found.
                this.possibleCenters.sort(function (a, b) {
                    if (a.count > b.count) return -1;
                    if (a.count < b.count) return 1;
                    return 0;
                });
            }

            return [this.possibleCenters[0], this.possibleCenters[1], this.possibleCenters[2]];
        };

        FinderPatternFinder.prototype.findRowSkip = function () {
            var max = this.possibleCenters.length;
            if (max <= 1) {
                return 0;
            }
            var firstConfirmedCenter = null;
            for (var i = 0; i < max; i++) {
                var center = this.possibleCenters[i];
                if (center.count >= CENTER_QUORUM) {
                    if (firstConfirmedCenter === null) {
                        firstConfirmedCenter = center;
                    } else {
                        // We have two confirmed centers
                        // How far down can we skip before resuming looking for the next
                        // pattern? In the worst case, only the difference between the
                        // difference in the x / y coordinates of the two centers.
                        // This is the case where you find top left last.
                        this.hasSkipped = true;
                        return Math.floor((Math.abs(firstConfirmedCenter.X - center.X) - Math.abs(firstConfirmedCenter.Y - center.Y)) / 2);
                    }
                }
            }
            return 0;
        };

        FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {
            var confirmedCount = 0;
            var totalModuleSize = 0.0;
            var max = this.possibleCenters.length;
            for (var i = 0; i < max; i++) {
                var pattern = this.possibleCenters[i];
                if (pattern.count >= CENTER_QUORUM) {
                    confirmedCount++;
                    totalModuleSize += pattern.estimatedModuleSize;
                }
            }
            if (confirmedCount < 3) {
                return false;
            }
            // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"
            // and that we need to keep looking. We detect this by asking if the estimated module sizes
            // vary too much. We arbitrarily say that when the total deviation from average exceeds
            // 5% of the total module size estimates, it's too much.
            var average = totalModuleSize / max;
            var totalDeviation = 0.0;
            for (var i = 0; i < max; i++) {
                pattern = this.possibleCenters[i];
                totalDeviation += Math.abs(pattern.estimatedModuleSize - average);
            }
            return totalDeviation <= 0.05 * totalModuleSize;
        };

        FinderPatternFinder.prototype.findFinderPattern = function (image) {
            var tryHarder = false;
            this.image = image;
            var maxI = image.height;
            var maxJ = image.width;
            var iSkip = Math.floor(3 * maxI / (4 * MAX_MODULES));
            if (iSkip < MIN_SKIP || tryHarder) {
                iSkip = MIN_SKIP;
            }

            var done = false;
            var stateCount = new Array(5);
            for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
                // Get a row of black/white values
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                stateCount[3] = 0;
                stateCount[4] = 0;
                var currentState = 0;
                for (var j = 0; j < maxJ; j++) {
                    if (image.data[j + i * image.width]) {
                        // Black pixel
                        if ((currentState & 1) === 1) {
                            // Counting white pixels
                            currentState++;
                        }
                        stateCount[currentState]++;
                    } else {
                        // White pixel
                        if ((currentState & 1) === 0) {
                            // Counting black pixels
                            if (currentState === 4) {
                                // A winner?
                                if (this.foundPatternCross(stateCount)) {
                                    // Yes
                                    var confirmed = this.handlePossibleCenter(stateCount, i, j);
                                    if (confirmed) {
                                        // Start examining every other line. Checking each line turned out to be too
                                        // expensive and didn't improve performance.
                                        iSkip = 2;
                                        if (this.hasSkipped) {
                                            done = this.haveMultiplyConfirmedCenters();
                                        } else {
                                            var rowSkip = this.findRowSkip();
                                            if (rowSkip > stateCount[2]) {
                                                // Skip rows between row of lower confirmed center
                                                // and top of presumed third confirmed center
                                                // but back up a bit to get a full chance of detecting
                                                // it, entire width of center of finder pattern

                                                // Skip by rowSkip, but back off by stateCount[2] (size of last center
                                                // of pattern we saw) to be conservative, and also back off by iSkip which
                                                // is about to be re-added
                                                i += rowSkip - stateCount[2] - iSkip;
                                                j = maxJ - 1;
                                            }
                                        }
                                    } else {
                                        // Advance to next black pixel
                                        do {
                                            j++;
                                        } while (j < maxJ && !image.data[j + i * image.width]);
                                        j--; // back up to that last white pixel
                                    }
                                    // Clear state to start looking again
                                    currentState = 0;
                                    stateCount[0] = 0;
                                    stateCount[1] = 0;
                                    stateCount[2] = 0;
                                    stateCount[3] = 0;
                                    stateCount[4] = 0;
                                } else {
                                    // No, shift counts back by two
                                    stateCount[0] = stateCount[2];
                                    stateCount[1] = stateCount[3];
                                    stateCount[2] = stateCount[4];
                                    stateCount[3] = 1;
                                    stateCount[4] = 0;
                                    currentState = 3;
                                }
                            } else {
                                stateCount[++currentState]++;
                            }
                        } else {
                            // Counting white pixels
                            stateCount[currentState]++;
                        }
                    }
                }
                if (this.foundPatternCross(stateCount)) {
                    var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                    if (confirmed) {
                        iSkip = stateCount[0];
                        if (this.hasSkipped) {
                            // Found a third one
                            done = this.haveMultiplyConfirmedCenters();
                        }
                    }
                }
            }

            var patternInfo = this.selectBestPatterns();
            orderBestPatterns(patternInfo);

            return new FinderPatternInfo(patternInfo);
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function PerspectiveTransform(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
            this.a11 = a11;
            this.a12 = a12;
            this.a13 = a13;
            this.a21 = a21;
            this.a22 = a22;
            this.a23 = a23;
            this.a31 = a31;
            this.a32 = a32;
            this.a33 = a33;
        }

        PerspectiveTransform.prototype.transformPoints1 = function (points) {
            var max = points.length;
            var a11 = this.a11;
            var a12 = this.a12;
            var a13 = this.a13;
            var a21 = this.a21;
            var a22 = this.a22;
            var a23 = this.a23;
            var a31 = this.a31;
            var a32 = this.a32;
            var a33 = this.a33;
            for (var i = 0; i < max; i += 2) {
                var x = points[i];
                var y = points[i + 1];
                var denominator = a13 * x + a23 * y + a33;
                points[i] = (a11 * x + a21 * y + a31) / denominator;
                points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
            }
        };

        PerspectiveTransform.prototype.transformPoints2 = function (xValues, yValues) {
            var n = xValues.length;
            for (var i = 0; i < n; i++) {
                var x = xValues[i];
                var y = yValues[i];
                var denominator = this.a13 * x + this.a23 * y + this.a33;
                xValues[i] = (this.a11 * x + this.a21 * y + this.a31) / denominator;
                yValues[i] = (this.a12 * x + this.a22 * y + this.a32) / denominator;
            }
        };

        PerspectiveTransform.prototype.buildAdjoint = function () {
            // Adjoint is the transpose of the cofactor matrix:
            return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
        };

        PerspectiveTransform.prototype.times = function (other) {
            return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
        };

        PerspectiveTransform.quadrilateralToQuadrilateral = function (x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {

            var qToS = this.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
            var sToQ = this.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
            return sToQ.times(qToS);
        };

        PerspectiveTransform.squareToQuadrilateral = function (x0, y0, x1, y1, x2, y2, x3, y3) {
            var dy2 = y3 - y2;
            var dy3 = y0 - y1 + y2 - y3;
            if (dy2 === 0.0 && dy3 === 0.0) {
                return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
            } else {
                var dx1 = x1 - x2;
                var dx2 = x3 - x2;
                var dx3 = x0 - x1 + x2 - x3;
                var dy1 = y1 - y2;
                var denominator = dx1 * dy2 - dx2 * dy1;
                var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
                var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
                return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
            }
        };

        PerspectiveTransform.quadrilateralToSquare = function (x0, y0, x1, y1, x2, y2, x3, y3) {
            // Here, the adjoint serves as the inverse:
            return this.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
        };

        function DetectorResult(bits, points) {
            this.bits = bits;
            this.points = points;
        }

        function Detector(image) {
            this.image = image;
            this.resultPointCallback = null;
        }

        Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX, fromY, toX, toY) {
            // Mild variant of Bresenham's algorithm;
            // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
            var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
            if (steep) {
                var temp = fromX;
                fromX = fromY;
                fromY = temp;
                temp = toX;
                toX = toY;
                toY = temp;
            }

            var dx = Math.abs(toX - fromX);
            var dy = Math.abs(toY - fromY);
            var error = -dx >> 1;
            var ystep = fromY < toY ? 1 : -1;
            var xstep = fromX < toX ? 1 : -1;
            var state = 0; // In black pixels, looking for white, first or second time
            for (var x = fromX, y = fromY; x !== toX; x += xstep) {

                var realX = steep ? y : x;
                var realY = steep ? x : y;
                if (state === 1) {
                    // In white pixels, looking for black
                    if (this.image.data[realX + realY * this.image.width]) {
                        state++;
                    }
                } else {
                    if (!this.image.data[realX + realY * this.image.width]) {
                        state++;
                    }
                }

                if (state === 3) {
                    // Found black, white, black, and stumbled back onto white; done
                    var diffX = x - fromX;
                    var diffY = y - fromY;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                error += dy;
                if (error > 0) {
                    if (y === toY) {
                        break;
                    }
                    y += ystep;
                    error -= dx;
                }
            }
            var diffX2 = toX - fromX;
            var diffY2 = toY - fromY;
            return Math.sqrt(diffX2 * diffX2 + diffY2 * diffY2);
        };

        Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX, fromY, toX, toY) {

            var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);

            // Now count other way -- don't run off image though of course
            var scale = 1.0;
            var otherToX = fromX - (toX - fromX);
            if (otherToX < 0) {
                scale = fromX / (fromX - otherToX);
                otherToX = 0;
            } else if (otherToX >= this.image.width) {
                scale = (this.image.width - 1 - fromX) / (otherToX - fromX);
                otherToX = this.image.width - 1;
            }
            var otherToY = Math.floor(fromY - (toY - fromY) * scale);

            scale = 1.0;
            if (otherToY < 0) {
                scale = fromY / (fromY - otherToY);
                otherToY = 0;
            } else if (otherToY >= this.image.height) {
                scale = (this.image.height - 1 - fromY) / (otherToY - fromY);
                otherToY = this.image.height - 1;
            }
            otherToX = Math.floor(fromX + (otherToX - fromX) * scale);

            result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
            return result - 1.0; // -1 because we counted the middle pixel twice
        };

        Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {
            var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.X), Math.floor(pattern.Y), Math.floor(otherPattern.X), Math.floor(otherPattern.Y));
            var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.X), Math.floor(otherPattern.Y), Math.floor(pattern.X), Math.floor(pattern.Y));
            if (isNaN(moduleSizeEst1)) {
                return moduleSizeEst2 / 7.0;
            }
            if (isNaN(moduleSizeEst2)) {
                return moduleSizeEst1 / 7.0;
            }
            // Average them, and divide by 7 since we've counted the width of 3 black modules,
            // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
            return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
        };

        Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {
            // Take the average
            return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
        };

        Detector.prototype.distance = function (pattern1, pattern2) {
            var xDiff = pattern1.X - pattern2.X;
            var yDiff = pattern1.Y - pattern2.Y;
            return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
        };

        Detector.prototype.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize) {
            var tltrCentersDimension = Math.round(this.distance(topLeft, topRight) / moduleSize);
            var tlblCentersDimension = Math.round(this.distance(topLeft, bottomLeft) / moduleSize);
            var dimension = (tltrCentersDimension + tlblCentersDimension >> 1) + 7;
            switch (dimension & 0x03) {
                // mod 4
                case 0:
                    dimension++;
                    break;
                // 1? do nothing

                case 2:
                    dimension--;
                    break;

                case 3:
                    throw "Error";
            }
            return dimension;
        };

        Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
            // Look for an alignment pattern (3 modules in size) around where it
            // should be
            var allowance = Math.floor(allowanceFactor * overallEstModuleSize);
            var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
            var alignmentAreaRightX = Math.min(this.image.width - 1, estAlignmentX + allowance);
            if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
                throw "Error";
            }

            var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
            var alignmentAreaBottomY = Math.min(this.image.height - 1, estAlignmentY + allowance);

            var alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
            return alignmentFinder.find();
        };

        Detector.prototype.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
            var dimMinusThree = dimension - 3.5;
            var bottomRightX;
            var bottomRightY;
            var sourceBottomRightX;
            var sourceBottomRightY;
            if (alignmentPattern !== null) {
                bottomRightX = alignmentPattern.X;
                bottomRightY = alignmentPattern.Y;
                sourceBottomRightX = sourceBottomRightY = dimMinusThree - 3.0;
            } else {
                // Don't have an alignment pattern, just make up the bottom-right point
                bottomRightX = topRight.X - topLeft.X + bottomLeft.X;
                bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;
                sourceBottomRightX = sourceBottomRightY = dimMinusThree;
            }

            var transform = PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.X, topLeft.Y, topRight.X, topRight.Y, bottomRightX, bottomRightY, bottomLeft.X, bottomLeft.Y);

            return transform;
        };

        Detector.prototype.sampleGrid = function (image, transform, dimension) {

            var sampler = GridSampler;
            return sampler.sampleGrid3(image, dimension, transform);
        };

        Detector.prototype.processFinderPatternInfo = function (info) {

            var topLeft = info.topLeft;
            var topRight = info.topRight;
            var bottomLeft = info.bottomLeft;

            var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
            if (moduleSize < 1.0) {
                throw "Error";
            }
            var dimension = this.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
            var provisionalVersion = Version.getProvisionalVersionForDimension(dimension);
            var modulesBetweenFPCenters = provisionalVersion.DimensionForVersion - 7;

            var alignmentPattern = null;
            // Anything above version 1 has an alignment pattern
            if (provisionalVersion.alignmentPatternCenters.length > 0) {

                // Guess where a "bottom right" finder pattern would have been
                var bottomRightX = topRight.X - topLeft.X + bottomLeft.X;
                var bottomRightY = topRight.Y - topLeft.Y + bottomLeft.Y;

                // Estimate that alignment pattern is closer by 3 modules
                // from "bottom right" to known top left location
                var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
                var estAlignmentX = Math.floor(topLeft.X + correctionToTopLeft * (bottomRightX - topLeft.X));
                var estAlignmentY = Math.floor(topLeft.Y + correctionToTopLeft * (bottomRightY - topLeft.Y));

                // Kind of arbitrary -- expand search radius before giving up
                for (var i = 4; i <= 16; i <<= 1) {
                    //try
                    //{
                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
                    break;
                    //}
                    //catch (re)
                    //{
                    // try next round
                    //}
                }
                // If we didn't find alignment pattern... well try anyway without it
            }

            var transform = this.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);

            var bits = this.sampleGrid(this.image, transform, dimension);

            var points;
            if (alignmentPattern === null) {
                points = [bottomLeft, topLeft, topRight];
            } else {
                points = [bottomLeft, topLeft, topRight, alignmentPattern];
            }
            return new DetectorResult(bits, points);
        };

        Detector.prototype.detect = function () {
            var info = new FinderPatternFinder().findFinderPattern(this.image);

            return this.processFinderPatternInfo(info);
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function GF256Poly(field, coefficients) {
            if (coefficients === null || coefficients.length === 0) {
                throw "System.ArgumentException";
            }
            this.field = field;
            var coefficientsLength = coefficients.length;
            if (coefficientsLength > 1 && coefficients[0] === 0) {
                // Leading term must be non-zero for anything except the constant polynomial "0"
                var firstNonZero = 1;
                while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                    firstNonZero++;
                }
                if (firstNonZero === coefficientsLength) {
                    this.coefficients = field.Zero.coefficients;
                } else {
                    this.coefficients = new Array(coefficientsLength - firstNonZero);
                    for (var i = 0; i < this.coefficients.length; i++) {
                        this.coefficients[i] = 0;
                    }for (var ci = 0; ci < this.coefficients.length; ci++) {
                        this.coefficients[ci] = coefficients[firstNonZero + ci];
                    }
                }
            } else {
                this.coefficients = coefficients;
            }
        }

        Object.defineProperty(GF256Poly.prototype, "Zero", {
            get: function get() {
                return this.coefficients[0] === 0;
            }
        });

        Object.defineProperty(GF256Poly.prototype, "Degree", {
            get: function get() {
                return this.coefficients.length - 1;
            }
        });

        GF256Poly.prototype.getCoefficient = function (degree) {
            return this.coefficients[this.coefficients.length - 1 - degree];
        };

        GF256Poly.prototype.evaluateAt = function (a) {
            if (a === 0) {
                // Just return the x^0 coefficient
                return this.getCoefficient(0);
            }
            var size = this.coefficients.length;
            if (a === 1) {
                // Just the sum of the coefficients
                var result = 0;
                for (var i = 0; i < size; i++) {
                    result = this.field.addOrSubtract(result, this.coefficients[i]);
                }
                return result;
            }
            var result2 = this.coefficients[0];
            for (var i = 1; i < size; i++) {
                result2 = this.field.addOrSubtract(this.field.multiply(a, result2), this.coefficients[i]);
            }
            return result2;
        };

        GF256Poly.prototype.addOrSubtract = function (other) {
            if (this.field !== other.field) {
                throw "GF256Polys do not have same GF256 field";
            }
            if (this.Zero) {
                return other;
            }
            if (other.Zero) {
                return this;
            }

            var smallerCoefficients = this.coefficients;
            var largerCoefficients = other.coefficients;
            if (smallerCoefficients.length > largerCoefficients.length) {
                var temp = smallerCoefficients;
                smallerCoefficients = largerCoefficients;
                largerCoefficients = temp;
            }
            var sumDiff = new Array(largerCoefficients.length);
            var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
            // Copy high-order terms only found in higher-degree polynomial's coefficients
            for (var ci = 0; ci < lengthDiff; ci++) {
                sumDiff[ci] = largerCoefficients[ci];
            }for (var i = lengthDiff; i < largerCoefficients.length; i++) {
                sumDiff[i] = this.field.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
            }

            return new GF256Poly(this.field, sumDiff);
        };

        GF256Poly.prototype.multiply1 = function (other) {
            if (this.field !== other.field) {
                throw "GF256Polys do not have same GF256 field";
            }
            if (this.Zero || other.Zero) {
                return this.field.Zero;
            }
            var aCoefficients = this.coefficients;
            var aLength = aCoefficients.length;
            var bCoefficients = other.coefficients;
            var bLength = bCoefficients.length;
            var product = new Array(aLength + bLength - 1);
            for (var i = 0; i < aLength; i++) {
                var aCoeff = aCoefficients[i];
                for (var j = 0; j < bLength; j++) {
                    product[i + j] = this.field.addOrSubtract(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
                }
            }
            return new GF256Poly(this.field, product);
        };

        GF256Poly.prototype.multiply2 = function (scalar) {
            if (scalar === 0) {
                return this.field.Zero;
            }
            if (scalar === 1) {
                return this;
            }
            var size = this.coefficients.length;
            var product = new Array(size);
            for (var i = 0; i < size; i++) {
                product[i] = this.field.multiply(this.coefficients[i], scalar);
            }
            return new GF256Poly(this.field, product);
        };

        GF256Poly.prototype.multiplyByMonomial = function (degree, coefficient) {
            if (degree < 0) {
                throw "System.ArgumentException";
            }
            if (coefficient === 0) {
                return this.field.Zero;
            }
            var size = this.coefficients.length;
            var product = new Array(size + degree);
            for (var i = 0; i < product.length; i++) {
                product[i] = 0;
            }for (var i = 0; i < size; i++) {
                product[i] = this.field.multiply(this.coefficients[i], coefficient);
            }
            return new GF256Poly(this.field, product);
        };

        GF256Poly.prototype.divide = function (other) {
            if (this.field !== other.field) {
                throw "GF256Polys do not have same GF256 field";
            }
            if (other.Zero) {
                throw "Divide by 0";
            }

            var quotient = this.field.Zero;
            var remainder = this;

            var denominatorLeadingTerm = other.getCoefficient(other.Degree);
            var inverseDenominatorLeadingTerm = this.field.inverse(denominatorLeadingTerm);

            while (remainder.Degree >= other.Degree && !remainder.Zero) {
                var degreeDifference = remainder.Degree - other.Degree;
                var scale = this.field.multiply(remainder.getCoefficient(remainder.Degree), inverseDenominatorLeadingTerm);
                var term = other.multiplyByMonomial(degreeDifference, scale);
                var iterationQuotient = this.field.buildMonomial(degreeDifference, scale);
                quotient = quotient.addOrSubtract(iterationQuotient);
                remainder = remainder.addOrSubtract(term);
            }

            return [quotient, remainder];
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function GF256(primitive) {
            this.expTable = new Array(256);
            this.logTable = new Array(256);
            var x = 1;
            for (var i = 0; i < 256; i++) {
                this.expTable[i] = x;
                x <<= 1; // x = x * 2; we're assuming the generator alpha is 2
                if (x >= 0x100) {
                    x ^= primitive;
                }
            }
            for (var i = 0; i < 255; i++) {
                this.logTable[this.expTable[i]] = i;
            }
            // logTable[0] == 0 but this should never be used
            var at0 = new Array(1);at0[0] = 0;
            this.zero = new GF256Poly(this, new Array(at0));
            var at1 = new Array(1);at1[0] = 1;
            this.one = new GF256Poly(this, new Array(at1));
        }

        Object.defineProperty(GF256.prototype, "Zero", {
            get: function get() {
                return this.zero;
            }
        });

        Object.defineProperty(GF256.prototype, "One", {
            get: function get() {
                return this.one;
            }
        });

        GF256.prototype.buildMonomial = function (degree, coefficient) {
            if (degree < 0) {
                throw "System.ArgumentException";
            }
            if (coefficient === 0) {
                return this.zero;
            }
            var coefficients = new Array(degree + 1);
            for (var i = 0; i < coefficients.length; i++) {
                coefficients[i] = 0;
            }coefficients[0] = coefficient;
            return new GF256Poly(this, coefficients);
        };

        GF256.prototype.exp = function (a) {
            return this.expTable[a];
        };

        GF256.prototype.log = function (a) {
            if (a === 0) {
                throw "System.ArgumentException";
            }
            return this.logTable[a];
        };

        GF256.prototype.inverse = function (a) {
            if (a === 0) {
                throw "System.ArithmeticException";
            }
            return this.expTable[255 - this.logTable[a]];
        };

        GF256.prototype.addOrSubtract = function (a, b) {
            return a ^ b;
        };

        GF256.prototype.multiply = function (a, b) {
            if (a === 0 || b === 0) {
                return 0;
            }
            if (a === 1) {
                return b;
            }
            if (b === 1) {
                return a;
            }
            return this.expTable[(this.logTable[a] + this.logTable[b]) % 255];
        };

        GF256.QR_CODE_FIELD = new GF256(0x011D);
        GF256.DATA_MATRIX_FIELD = new GF256(0x012D);

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function ReedSolomonDecoder(field) {
            this.field = field;
        }

        ReedSolomonDecoder.prototype.decode = function (received, twoS) {
            var poly = new GF256Poly(this.field, received);
            var syndromeCoefficients = new Array(twoS);
            for (var i = 0; i < syndromeCoefficients.length; i++) {
                syndromeCoefficients[i] = 0;
            }var dataMatrix = false; //this.field.Equals(GF256.DATA_MATRIX_FIELD);
            var noError = true;
            for (var i = 0; i < twoS; i++) {
                // Thanks to sanfordsquires for this fix:
                var _eval = poly.evaluateAt(this.field.exp(dataMatrix ? i + 1 : i));
                syndromeCoefficients[syndromeCoefficients.length - 1 - i] = _eval;
                if (_eval !== 0) {
                    noError = false;
                }
            }
            if (noError) {
                return;
            }
            var syndrome = new GF256Poly(this.field, syndromeCoefficients);
            var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(twoS, 1), syndrome, twoS);
            var sigma = sigmaOmega[0];
            var omega = sigmaOmega[1];
            var errorLocations = this.findErrorLocations(sigma);
            var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations, dataMatrix);
            for (var i = 0; i < errorLocations.length; i++) {
                var position = received.length - 1 - this.field.log(errorLocations[i]);
                if (position < 0) {
                    throw "ReedSolomonException Bad error location";
                }
                received[position] = GF256.prototype.addOrSubtract(received[position], errorMagnitudes[i]);
            }
        };

        ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R) {
            // Assume a's degree is >= b's
            if (a.Degree < b.Degree) {
                var temp = a;
                a = b;
                b = temp;
            }

            var rLast = a;
            var r = b;
            var sLast = this.field.One;
            var s = this.field.Zero;
            var tLast = this.field.Zero;
            var t = this.field.One;

            // Run Euclidean algorithm until r's degree is less than R/2
            while (r.Degree >= Math.floor(R / 2)) {
                var rLastLast = rLast;
                var sLastLast = sLast;
                var tLastLast = tLast;
                rLast = r;
                sLast = s;
                tLast = t;

                // Divide rLastLast by rLast, with quotient in q and remainder in r
                if (rLast.Zero) {
                    // Oops, Euclidean algorithm already terminated?
                    throw "r_{i-1} was zero";
                }
                r = rLastLast;
                var q = this.field.Zero;
                var denominatorLeadingTerm = rLast.getCoefficient(rLast.Degree);
                var dltInverse = this.field.inverse(denominatorLeadingTerm);
                while (r.Degree >= rLast.Degree && !r.Zero) {
                    var degreeDiff = r.Degree - rLast.Degree;
                    var scale = this.field.multiply(r.getCoefficient(r.Degree), dltInverse);
                    q = q.addOrSubtract(this.field.buildMonomial(degreeDiff, scale));
                    r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
                }

                s = q.multiply1(sLast).addOrSubtract(sLastLast);
                t = q.multiply1(tLast).addOrSubtract(tLastLast);
            }

            var sigmaTildeAtZero = t.getCoefficient(0);
            if (sigmaTildeAtZero === 0) {
                throw "ReedSolomonException sigmaTilde(0) was zero";
            }

            var inverse = this.field.inverse(sigmaTildeAtZero);
            var sigma = t.multiply2(inverse);
            var omega = r.multiply2(inverse);
            return [sigma, omega];
        };

        ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {
            // This is a direct application of Chien's search
            var numErrors = errorLocator.Degree;
            if (numErrors === 1) {
                // shortcut
                return new Array(errorLocator.getCoefficient(1));
            }
            var result = new Array(numErrors);
            var e = 0;
            for (var i = 1; i < 256 && e < numErrors; i++) {
                if (errorLocator.evaluateAt(i) === 0) {
                    result[e] = this.field.inverse(i);
                    e++;
                }
            }
            if (e !== numErrors) {
                throw "Error locator degree does not match number of roots";
            }
            return result;
        };

        ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations, dataMatrix) {
            // This is directly applying Forney's Formula
            var s = errorLocations.length;
            var result = new Array(s);
            for (var i = 0; i < s; i++) {
                var xiInverse = this.field.inverse(errorLocations[i]);
                var denominator = 1;
                for (var j = 0; j < s; j++) {
                    if (i !== j) {
                        denominator = this.field.multiply(denominator, GF256.prototype.addOrSubtract(1, this.field.multiply(errorLocations[j], xiInverse)));
                    }
                }
                result[i] = this.field.multiply(errorEvaluator.evaluateAt(xiInverse), this.field.inverse(denominator));
                // Thanks to sanfordsquires for this fix:
                if (dataMatrix) {
                    result[i] = this.field.multiply(result[i], xiInverse);
                }
            }
            return result;
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        var DataMask = {};

        DataMask.forReference = function (reference) {
            if (reference < 0 || reference > 7) {
                throw "System.ArgumentException";
            }
            return DataMask.DATA_MASKS[reference];
        };

        function DataMask000() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return (i + j & 0x01) === 0;
            };
        }

        function DataMask001() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return (i & 0x01) === 0;
            };
        }

        function DataMask010() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return j % 3 === 0;
            };
        }

        function DataMask011() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return (i + j) % 3 === 0;
            };
        }

        function DataMask100() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return (URShift(i, 1) + j / 3 & 0x01) === 0;
            };
        }

        function DataMask101() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                var temp = i * j;
                return (temp & 0x01) + temp % 3 === 0;
            };
        }

        function DataMask110() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                var temp = i * j;
                return ((temp & 0x01) + temp % 3 & 0x01) === 0;
            };
        }
        function DataMask111() {
            this.unmaskBitMatrix = function (bits, dimension) {
                for (var i = 0; i < dimension; i++) {
                    for (var j = 0; j < dimension; j++) {
                        if (this.isMasked(i, j)) {
                            bits.flip(j, i);
                        }
                    }
                }
            };
            this.isMasked = function (i, j) {
                return ((i + j & 0x01) + i * j % 3 & 0x01) === 0;
            };
        }

        DataMask.DATA_MASKS = [new DataMask000(), new DataMask001(), new DataMask010(), new DataMask011(), new DataMask100(), new DataMask101(), new DataMask110(), new DataMask111()];

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function BitMatrixParser(bitMatrix) {
            var dimension = bitMatrix.Dimension;
            if (dimension < 21 || (dimension & 0x03) !== 1) {
                throw "Error BitMatrixParser";
            }
            this.bitMatrix = bitMatrix;
            this.parsedVersion = null;
            this.parsedFormatInfo = null;
        }

        BitMatrixParser.prototype.copyBit = function (i, j, versionBits) {
            return this.bitMatrix.get_Renamed(i, j) ? versionBits << 1 | 0x1 : versionBits << 1;
        };

        BitMatrixParser.prototype.readFormatInformation = function () {
            if (this.parsedFormatInfo !== null) {
                return this.parsedFormatInfo;
            }

            // Read top-left format info bits
            var formatInfoBits = 0;
            for (var i = 0; i < 6; i++) {
                formatInfoBits = this.copyBit(i, 8, formatInfoBits);
            }
            // .. and skip a bit in the timing pattern ...
            formatInfoBits = this.copyBit(7, 8, formatInfoBits);
            formatInfoBits = this.copyBit(8, 8, formatInfoBits);
            formatInfoBits = this.copyBit(8, 7, formatInfoBits);
            // .. and skip a bit in the timing pattern ...
            for (var j = 5; j >= 0; j--) {
                formatInfoBits = this.copyBit(8, j, formatInfoBits);
            }

            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
            if (this.parsedFormatInfo !== null) {
                return this.parsedFormatInfo;
            }

            // Hmm, failed. Try the top-right/bottom-left pattern
            var dimension = this.bitMatrix.Dimension;
            formatInfoBits = 0;
            var iMin = dimension - 8;
            for (var i = dimension - 1; i >= iMin; i--) {
                formatInfoBits = this.copyBit(i, 8, formatInfoBits);
            }
            for (var j = dimension - 7; j < dimension; j++) {
                formatInfoBits = this.copyBit(8, j, formatInfoBits);
            }

            this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits);
            if (this.parsedFormatInfo !== null) {
                return this.parsedFormatInfo;
            }
            throw "Error readFormatInformation";
        };

        BitMatrixParser.prototype.readVersion = function () {
            if (this.parsedVersion !== null) {
                return this.parsedVersion;
            }

            var dimension = this.bitMatrix.Dimension;

            var provisionalVersion = dimension - 17 >> 2;
            if (provisionalVersion <= 6) {
                return Version.getVersionForNumber(provisionalVersion);
            }

            // Read top-right version info: 3 wide by 6 tall
            var versionBits = 0;
            var ijMin = dimension - 11;
            for (var j = 5; j >= 0; j--) {
                for (var i = dimension - 9; i >= ijMin; i--) {
                    versionBits = this.copyBit(i, j, versionBits);
                }
            }

            this.parsedVersion = Version.decodeVersionInformation(versionBits);
            if (this.parsedVersion !== null && this.parsedVersion.DimensionForVersion === dimension) {
                return this.parsedVersion;
            }

            // Hmm, failed. Try bottom left: 6 wide by 3 tall
            versionBits = 0;
            for (var i = 5; i >= 0; i--) {
                for (var j = dimension - 9; j >= ijMin; j--) {
                    versionBits = this.copyBit(i, j, versionBits);
                }
            }

            this.parsedVersion = Version.decodeVersionInformation(versionBits);
            if (this.parsedVersion !== null && this.parsedVersion.DimensionForVersion === dimension) {
                return this.parsedVersion;
            }
            throw "Error readVersion";
        };

        BitMatrixParser.prototype.readCodewords = function () {
            var formatInfo = this.readFormatInformation();
            var version = this.readVersion();

            // Get the data mask for the format used in this QR Code. This will exclude
            // some bits from reading as we wind through the bit matrix.
            var dataMask = DataMask.forReference(formatInfo.dataMask);
            var dimension = this.bitMatrix.Dimension;
            dataMask.unmaskBitMatrix(this.bitMatrix, dimension);

            var functionPattern = version.buildFunctionPattern();

            var readingUp = true;
            var result = new Array(version.totalCodewords);
            var resultOffset = 0;
            var currentByte = 0;
            var bitsRead = 0;
            // Read columns in pairs, from right to left
            for (var j = dimension - 1; j > 0; j -= 2) {
                if (j === 6) {
                    // Skip whole column with vertical alignment pattern;
                    // saves time and makes the other code proceed more cleanly
                    j--;
                }
                // Read alternatingly from bottom to top then top to bottom
                for (var count = 0; count < dimension; count++) {
                    var i = readingUp ? dimension - 1 - count : count;
                    for (var col = 0; col < 2; col++) {
                        // Ignore bits covered by the function pattern
                        if (!functionPattern.get_Renamed(j - col, i)) {
                            // Read a bit
                            bitsRead++;
                            currentByte <<= 1;
                            if (this.bitMatrix.get_Renamed(j - col, i)) {
                                currentByte |= 1;
                            }
                            // If we've made a whole byte, save it off
                            if (bitsRead === 8) {
                                result[resultOffset++] = currentByte;
                                bitsRead = 0;
                                currentByte = 0;
                            }
                        }
                    }
                }
                readingUp ^= true; // readingUp = !readingUp; // switch directions
            }
            if (resultOffset !== version.totalCodewords) {
                throw "Error readCodewords";
            }
            return result;
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function DataBlock(numDataCodewords, codewords) {
            this.numDataCodewords = numDataCodewords;
            this.codewords = codewords;
        }

        DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {

            if (rawCodewords.length !== version.totalCodewords) {
                throw "ArgumentException";
            }

            // Figure out the number and size of data blocks used by this version and
            // error correction level
            var ecBlocks = version.getECBlocksForLevel(ecLevel);

            // First count the total number of data blocks
            var totalBlocks = 0;
            var ecBlockArray = ecBlocks.getECBlocks();
            for (var i = 0; i < ecBlockArray.length; i++) {
                totalBlocks += ecBlockArray[i].count;
            }

            // Now establish DataBlocks of the appropriate size and number of data codewords
            var result = new Array(totalBlocks);
            var numResultBlocks = 0;
            for (var j = 0; j < ecBlockArray.length; j++) {
                var ecBlock = ecBlockArray[j];
                for (var i = 0; i < ecBlock.count; i++) {
                    var numDataCodewords = ecBlock.dataCodewords;
                    var numBlockCodewords = ecBlocks.ecCodewordsPerBlock + numDataCodewords;
                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Array(numBlockCodewords));
                }
            }

            // All blocks have the same amount of data, except that the last n
            // (where n may be 0) have 1 more byte. Figure out where these start.
            var shorterBlocksTotalCodewords = result[0].codewords.length;
            var longerBlocksStartAt = result.length - 1;
            while (longerBlocksStartAt >= 0) {
                var numCodewords = result[longerBlocksStartAt].codewords.length;
                if (numCodewords === shorterBlocksTotalCodewords) {
                    break;
                }
                longerBlocksStartAt--;
            }
            longerBlocksStartAt++;

            var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.ecCodewordsPerBlock;
            // The last elements of result may be 1 element longer;
            // first fill out as many elements as all of them have
            var rawCodewordsOffset = 0;
            for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
                for (var j = 0; j < numResultBlocks; j++) {
                    result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
                }
            }
            // Fill out the last data block in the longer ones
            for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
                result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
            }
            // Now add in error correction blocks
            var max = result[0].codewords.length;
            for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
                for (var j = 0; j < numResultBlocks; j++) {
                    var iOffset = j < longerBlocksStartAt ? i : i + 1;
                    result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
                }
            }
            return result;
        };

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        function QRCodeDataBlockReader(blocks, version, numErrorCorrectionCode) {
            this.blockPointer = 0;
            this.bitPointer = 7;
            this.dataLength = 0;
            this.blocks = blocks;
            this.numErrorCorrectionCode = numErrorCorrectionCode;
            if (version <= 9) this.dataLengthMode = 0;else if (version >= 10 && version <= 26) this.dataLengthMode = 1;else if (version >= 27 && version <= 40) this.dataLengthMode = 2;
        }

        QRCodeDataBlockReader.prototype.getNextBits = function (numBits) {
            var bits = 0;
            if (numBits < this.bitPointer + 1) {
                // next word fits into current data block
                var mask = 0;
                for (var i = 0; i < numBits; i++) {
                    mask += 1 << i;
                }
                mask <<= this.bitPointer - numBits + 1;

                bits = (this.blocks[this.blockPointer] & mask) >> this.bitPointer - numBits + 1;
                this.bitPointer -= numBits;
                return bits;
            } else if (numBits < this.bitPointer + 1 + 8) {
                // next word crosses 2 data blocks
                var mask1 = 0;
                for (var i = 0; i < this.bitPointer + 1; i++) {
                    mask1 += 1 << i;
                }
                bits = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);
                this.blockPointer++;
                bits += this.blocks[this.blockPointer] >> 8 - (numBits - (this.bitPointer + 1));

                this.bitPointer = this.bitPointer - numBits % 8;
                if (this.bitPointer < 0) {
                    this.bitPointer = 8 + this.bitPointer;
                }
                return bits;
            } else if (numBits < this.bitPointer + 1 + 16) {
                // next word crosses 3 data blocks
                var mask1 = 0; // mask of first block
                var mask3 = 0; // mask of 3rd block
                //bitPointer + 1 : number of bits of the 1st block
                //8 : number of the 2nd block (note that use already 8bits because next word uses 3 data blocks)
                //numBits - (bitPointer + 1 + 8) : number of bits of the 3rd block
                for (var i = 0; i < this.bitPointer + 1; i++) {
                    mask1 += 1 << i;
                }
                var bitsFirstBlock = (this.blocks[this.blockPointer] & mask1) << numBits - (this.bitPointer + 1);
                this.blockPointer++;

                var bitsSecondBlock = this.blocks[this.blockPointer] << numBits - (this.bitPointer + 1 + 8);
                this.blockPointer++;

                for (var i = 0; i < numBits - (this.bitPointer + 1 + 8); i++) {
                    mask3 += 1 << i;
                }
                mask3 <<= 8 - (numBits - (this.bitPointer + 1 + 8));
                var bitsThirdBlock = (this.blocks[this.blockPointer] & mask3) >> 8 - (numBits - (this.bitPointer + 1 + 8));

                bits = bitsFirstBlock + bitsSecondBlock + bitsThirdBlock;
                this.bitPointer = this.bitPointer - (numBits - 8) % 8;
                if (this.bitPointer < 0) {
                    this.bitPointer = 8 + this.bitPointer;
                }
                return bits;
            } else {
                return 0;
            }
        };

        QRCodeDataBlockReader.prototype.NextMode = function () {
            if (this.blockPointer > this.blocks.length - this.numErrorCorrectionCode - 2) return 0;else return this.getNextBits(4);
        };

        QRCodeDataBlockReader.prototype.getDataLength = function (modeIndicator) {
            var index = 0;
            while (true) {
                if (modeIndicator >> index === 1) break;
                index++;
            }

            return this.getNextBits(qrcode.sizeOfDataLengthInfo[this.dataLengthMode][index]);
        };

        QRCodeDataBlockReader.prototype.getRomanAndFigureString = function (dataLength) {
            var length = dataLength;
            var intData = 0;
            var strData = "";
            var tableRomanAndFigure = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];
            do {
                if (length > 1) {
                    intData = this.getNextBits(11);
                    var firstLetter = Math.floor(intData / 45);
                    var secondLetter = intData % 45;
                    strData += tableRomanAndFigure[firstLetter];
                    strData += tableRomanAndFigure[secondLetter];
                    length -= 2;
                } else if (length === 1) {
                    intData = this.getNextBits(6);
                    strData += tableRomanAndFigure[intData];
                    length -= 1;
                }
            } while (length > 0);

            return strData;
        };

        QRCodeDataBlockReader.prototype.getFigureString = function (dataLength) {
            var length = dataLength;
            var intData = 0;
            var strData = "";
            do {
                if (length >= 3) {
                    intData = this.getNextBits(10);
                    if (intData < 100) strData += "0";
                    if (intData < 10) strData += "0";
                    length -= 3;
                } else if (length === 2) {
                    intData = this.getNextBits(7);
                    if (intData < 10) strData += "0";
                    length -= 2;
                } else if (length === 1) {
                    intData = this.getNextBits(4);
                    length -= 1;
                }
                strData += intData;
            } while (length > 0);

            return strData;
        };

        QRCodeDataBlockReader.prototype.get8bitByteArray = function (dataLength) {
            var length = dataLength;
            var intData = 0;
            var output = [];

            do {
                intData = this.getNextBits(8);
                output.push(intData);
                length--;
            } while (length > 0);
            return output;
        };

        QRCodeDataBlockReader.prototype.getKanjiString = function (dataLength) {
            var length = dataLength;
            var intData = 0;
            var unicodeString = "";
            do {
                intData = this.getNextBits(13);
                var lowerByte = intData % 0xC0;
                var higherByte = intData / 0xC0;

                var tempWord = (higherByte << 8) + lowerByte;
                var shiftjisWord = 0;
                if (tempWord + 0x8140 <= 0x9FFC) {
                    // between 8140 - 9FFC on Shift_JIS character set
                    shiftjisWord = tempWord + 0x8140;
                } else {
                    // between E040 - EBBF on Shift_JIS character set
                    shiftjisWord = tempWord + 0xC140;
                }

                unicodeString += String.fromCharCode(shiftjisWord);
                length--;
            } while (length > 0);

            return unicodeString;
        };

        Object.defineProperty(QRCodeDataBlockReader.prototype, "DataByte", {
            get: function get() {
                var output = [];
                var MODE_NUMBER = 1;
                var MODE_ROMAN_AND_NUMBER = 2;
                var MODE_8BIT_BYTE = 4;
                var MODE_KANJI = 8;
                do {
                    var mode = this.NextMode();
                    if (mode === 0) {
                        if (output.length > 0) break;else throw "Empty data block";
                    }
                    //if (mode != 1 && mode != 2 && mode != 4 && mode != 8)
                    //}
                    if (mode !== MODE_NUMBER && mode !== MODE_ROMAN_AND_NUMBER && mode !== MODE_8BIT_BYTE && mode !== MODE_KANJI && mode !== 7) {
                        /*          canvas.println("Invalid mode: " + mode);
                         mode = guessMode(mode);
                         canvas.println("Guessed mode: " + mode); */
                        throw "Invalid mode: " + mode + " in (block:" + this.blockPointer + " bit:" + this.bitPointer + ")";
                    }
                    var dataLength = this.getDataLength(mode);
                    if (dataLength < 1) throw "Invalid data length: " + dataLength;
                    switch (mode) {

                        case MODE_NUMBER:
                            var temp_str = this.getFigureString(dataLength);
                            var ta = new Array(temp_str.length);
                            for (var j = 0; j < temp_str.length; j++) {
                                ta[j] = temp_str.charCodeAt(j);
                            }output.push(ta);
                            break;

                        case MODE_ROMAN_AND_NUMBER:
                            var temp_str = this.getRomanAndFigureString(dataLength);
                            var ta = new Array(temp_str.length);
                            for (var j = 0; j < temp_str.length; j++) {
                                ta[j] = temp_str.charCodeAt(j);
                            }output.push(ta);
                            break;

                        case MODE_8BIT_BYTE:
                            var temp_sbyteArray3 = this.get8bitByteArray(dataLength);
                            output.push(temp_sbyteArray3);
                            break;

                        case MODE_KANJI:
                            var temp_str = this.getKanjiString(dataLength);
                            output.push(temp_str);
                            break;
                    }
                    //
                } while (true);
                return output;
            }
        });

        /*
          Ported to JavaScript by Lazar Laszlo 2011
        
          lazarsoft@gmail.com, www.lazarsoft.info
        
        */

        /*
        *
        * Copyright 2007 ZXing authors
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *      http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */

        var Decoder = {};
        Decoder.rsDecoder = new ReedSolomonDecoder(GF256.QR_CODE_FIELD);

        Decoder.correctErrors = function (codewordBytes, numDataCodewords) {
            var numCodewords = codewordBytes.length;
            // First read into an array of ints
            var codewordsInts = new Array(numCodewords);
            for (var i = 0; i < numCodewords; i++) {
                codewordsInts[i] = codewordBytes[i] & 0xFF;
            }
            var numECCodewords = codewordBytes.length - numDataCodewords;
            try {
                Decoder.rsDecoder.decode(codewordsInts, numECCodewords);
            } catch (rse) {
                throw rse;
            }
            // Copy back into array of bytes -- only need to worry about the bytes that were data
            // We don't care about errors in the error-correction codewords
            for (var i = 0; i < numDataCodewords; i++) {
                codewordBytes[i] = codewordsInts[i];
            }
        };

        Decoder.decode = function (bits) {
            var parser = new BitMatrixParser(bits);
            var version = parser.readVersion();
            var ecLevel = parser.readFormatInformation().errorCorrectionLevel;

            // Read codewords
            var codewords = parser.readCodewords();

            // Separate into data blocks
            var dataBlocks = DataBlock.getDataBlocks(codewords, version, ecLevel);

            // Count total number of data bytes
            var totalBytes = 0;
            for (var i = 0; i < dataBlocks.length; i++) {
                totalBytes += dataBlocks[i].numDataCodewords;
            }
            var resultBytes = new Array(totalBytes);
            var resultOffset = 0;

            // Error-correct and copy data blocks together into a stream of bytes
            for (var j = 0; j < dataBlocks.length; j++) {
                var dataBlock = dataBlocks[j];
                var codewordBytes = dataBlock.codewords;
                var numDataCodewords = dataBlock.numDataCodewords;
                Decoder.correctErrors(codewordBytes, numDataCodewords);
                for (var i = 0; i < numDataCodewords; i++) {
                    resultBytes[resultOffset++] = codewordBytes[i];
                }
            }

            // Decode the contents of that stream of bytes
            var reader = new QRCodeDataBlockReader(resultBytes, version.versionNumber, ecLevel.bits);
            return reader;
        };

        /*
           Copyright 2011 Lazar Laszlo (lazarsoft@gmail.com, www.lazarsoft.info)
        
           Licensed under the Apache License, Version 2.0 (the "License");
           you may not use this file except in compliance with the License.
           You may obtain a copy of the License at
        
               http://www.apache.org/licenses/LICENSE-2.0
        
           Unless required by applicable law or agreed to in writing, software
           distributed under the License is distributed on an "AS IS" BASIS,
           WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           See the License for the specific language governing permissions and
           limitations under the License.
        */

        var qrcode = {};
        qrcode.sizeOfDataLengthInfo = [[10, 9, 8, 8], [12, 11, 16, 10], [14, 13, 16, 12]];

        function QrCode$1() {

            this.imagedata = null;
            this.width = 0;
            this.height = 0;
            this.qrCodeSymbol = null;
            this.debug = false;

            this.callback = null;
        }

        QrCode$1.prototype.decode = function (src, data) {

            var decode = function () {

                try {
                    this.error = undefined;
                    this.result = this.process(this.imagedata);
                } catch (e) {
                    this.error = e;
                    this.result = undefined;
                }

                if (this.callback !== null) {
                    this.callback(this.error, this.result);
                }

                return this.result;
            }.bind(this);

            if (src !== undefined && src.width !== undefined) {
                /* decode from canvas canvas.context.getImageData */
                this.width = src.width;
                this.height = src.height;
                this.imagedata = { "data": data || src.data };
                this.imagedata.width = src.width;
                this.imagedata.height = src.height;

                return decode();
            } else {
                if (typeof Image === "undefined") {
                    throw new Error("This source format is not supported in your environment, you need to pass an image buffer with width and height (see https://github.com/edi9999/jsqrcode/blob/master/test/qrcode.js)");
                }
                /* decode from URL */

                var image = new Image();
                image.crossOrigin = "Anonymous";

                image.onload = function () {

                    var canvas_qr = document.createElement('canvas');
                    var context = canvas_qr.getContext('2d');
                    var canvas_out = document.getElementById("out-canvas");

                    if (canvas_out !== null) {

                        var outctx = canvas_out.getContext('2d');
                        outctx.clearRect(0, 0, 320, 240);
                        outctx.drawImage(image, 0, 0, 320, 240);
                    }

                    canvas_qr.width = image.width;
                    canvas_qr.height = image.height;
                    context.drawImage(image, 0, 0);
                    this.width = image.width;
                    this.height = image.height;

                    try {
                        this.imagedata = context.getImageData(0, 0, image.width, image.height);
                    } catch (e) {
                        this.result = "Cross domain image reading not supported in your browser! Save it to your computer then drag and drop the file!";
                        if (this.callback !== null) return this.callback(null, this.result);
                    }

                    decode();
                }.bind(this);

                image.src = src;
            }
        };

        QrCode$1.prototype.decode_utf8 = function (s) {
            return decodeURIComponent(escape(s));
        };

        QrCode$1.prototype.process = function (imageData) {
            var start = new Date().getTime();

            var image = this.grayScaleToBitmap(imageData);

            var detector = new Detector(image);

            var qRCodeMatrix = detector.detect();

            /*for (var y = 0; y < qRCodeMatrix.bits.height; y++)
             {
             for (var x = 0; x < qRCodeMatrix.bits.width; x++)
             {
             var point = (x * 4*2) + (y*2 * imageData.width * 4);
             imageData.data[point] = qRCodeMatrix.bits.get_Renamed(x,y)?0:0;
             imageData.data[point+1] = qRCodeMatrix.bits.get_Renamed(x,y)?0:0;
             imageData.data[point+2] = qRCodeMatrix.bits.get_Renamed(x,y)?255:0;
             }
             }*/

            var reader = Decoder.decode(qRCodeMatrix.bits);
            var data = reader.DataByte;
            var str = "";
            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].length; j++) {
                    str += String.fromCharCode(data[i][j]);
                }
            }

            var end = new Date().getTime();
            var time = end - start;
            if (this.debug) {
                console.log('QR Code processing time (ms): ' + time);
            }
            return { result: this.decode_utf8(str), points: qRCodeMatrix.points };
        };

        QrCode$1.prototype.getPixel = function (imageData, x, y) {
            if (imageData.width < x) {
                throw "point error";
            }
            if (imageData.height < y) {
                throw "point error";
            }
            var point = x * 4 + y * imageData.width * 4;
            return (imageData.data[point] * 33 + imageData.data[point + 1] * 34 + imageData.data[point + 2] * 33) / 100;
        };

        QrCode$1.prototype.binarize = function (th) {
            var ret = new Array(this.width * this.height);
            for (var y = 0; y < this.height; y++) {
                for (var x = 0; x < this.width; x++) {
                    var gray = this.getPixel(x, y);

                    ret[x + y * this.width] = gray <= th;
                }
            }
            return ret;
        };

        QrCode$1.prototype.getMiddleBrightnessPerArea = function (imageData) {
            var numSqrtArea = 4;
            //obtain middle brightness((min + max) / 2) per area
            var areaWidth = Math.floor(imageData.width / numSqrtArea);
            var areaHeight = Math.floor(imageData.height / numSqrtArea);
            var minmax = new Array(numSqrtArea);
            for (var i = 0; i < numSqrtArea; i++) {
                minmax[i] = new Array(numSqrtArea);
                for (var i2 = 0; i2 < numSqrtArea; i2++) {
                    minmax[i][i2] = [0, 0];
                }
            }
            for (var ay = 0; ay < numSqrtArea; ay++) {
                for (var ax = 0; ax < numSqrtArea; ax++) {
                    minmax[ax][ay][0] = 0xFF;
                    for (var dy = 0; dy < areaHeight; dy++) {
                        for (var dx = 0; dx < areaWidth; dx++) {
                            var target = imageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * imageData.width];
                            if (target < minmax[ax][ay][0]) minmax[ax][ay][0] = target;
                            if (target > minmax[ax][ay][1]) minmax[ax][ay][1] = target;
                        }
                    }
                }
            }
            var middle = new Array(numSqrtArea);
            for (var i3 = 0; i3 < numSqrtArea; i3++) {
                middle[i3] = new Array(numSqrtArea);
            }
            for (var ay = 0; ay < numSqrtArea; ay++) {
                for (var ax = 0; ax < numSqrtArea; ax++) {
                    middle[ax][ay] = Math.floor((minmax[ax][ay][0] + minmax[ax][ay][1]) / 2);
                }
            }

            return middle;
        };

        QrCode$1.prototype.grayScaleToBitmap = function (grayScaleImageData) {
            var middle = this.getMiddleBrightnessPerArea(grayScaleImageData);
            var sqrtNumArea = middle.length;
            var areaWidth = Math.floor(grayScaleImageData.width / sqrtNumArea);
            var areaHeight = Math.floor(grayScaleImageData.height / sqrtNumArea);

            for (var ay = 0; ay < sqrtNumArea; ay++) {
                for (var ax = 0; ax < sqrtNumArea; ax++) {
                    for (var dy = 0; dy < areaHeight; dy++) {
                        for (var dx = 0; dx < areaWidth; dx++) {
                            grayScaleImageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * grayScaleImageData.width] = grayScaleImageData.data[areaWidth * ax + dx + (areaHeight * ay + dy) * grayScaleImageData.width] < middle[ax][ay];
                        }
                    }
                }
            }
            return grayScaleImageData;
        };

        QrCode$1.prototype.grayscale = function (imageData) {
            var ret = new Array(imageData.width * imageData.height);

            for (var y = 0; y < imageData.height; y++) {
                for (var x = 0; x < imageData.width; x++) {
                    var gray = this.getPixel(imageData, x, y);

                    ret[x + y * imageData.width] = gray;
                }
            }

            return {
                height: imageData.height,
                width: imageData.width,
                data: ret
            };
        };

        function URShift(number, bits) {
            if (number >= 0) return number >> bits;else return (number >> bits) + (2 << ~bits);
        }

        return QrCode$1;
    });
});
//# sourceMappingURL=index.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

exports.__esModule = true;

var _image_wrapper = __webpack_require__(20);

var _image_wrapper2 = _interopRequireDefault(_image_wrapper);

var _cv_utils = __webpack_require__(19);

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

var _image_debug = __webpack_require__(9);

var _image_debug2 = _interopRequireDefault(_image_debug);

var _rasterizer = __webpack_require__(65);

var _rasterizer2 = _interopRequireDefault(_rasterizer);

var _tracer = __webpack_require__(30);

var _tracer2 = _interopRequireDefault(_tracer);

var _skeletonizer2 = __webpack_require__(66);

var _skeletonizer3 = _interopRequireDefault(_skeletonizer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var vec2 = {
    clone: __webpack_require__(7),
    dot: __webpack_require__(32),
    scale: __webpack_require__(82),
    transformMat2: __webpack_require__(83)
};
var mat2 = {
    copy: __webpack_require__(79),
    create: __webpack_require__(80),
    invert: __webpack_require__(81)
};

var _config,
    _currentImageWrapper,
    _skelImageWrapper,
    _subImageWrapper,
    _labelImageWrapper,
    _patchGrid,
    _patchLabelGrid,
    _imageToPatchGrid,
    _binaryImageWrapper,
    _patchSize,
    _canvasContainer = {
    ctx: {
        binary: null
    },
    dom: {
        binary: null
    }
},
    _numPatches = { x: 0, y: 0 },
    _inputImageWrapper,
    _skeletonizer;

function initBuffers() {
    var skeletonImageData;

    if (_config.halfSample) {
        _currentImageWrapper = new _image_wrapper2.default({
            x: _inputImageWrapper.size.x / 2 | 0,
            y: _inputImageWrapper.size.y / 2 | 0
        });
    } else {
        _currentImageWrapper = _inputImageWrapper;
    }

    _patchSize = (0, _cv_utils.calculatePatchSize)(_config.patchSize, _currentImageWrapper.size);

    _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0;
    _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;

    _binaryImageWrapper = new _image_wrapper2.default(_currentImageWrapper.size, undefined, Uint8Array, false);

    _labelImageWrapper = new _image_wrapper2.default(_patchSize, undefined, Array, true);

    skeletonImageData = new ArrayBuffer(64 * 1024);
    _subImageWrapper = new _image_wrapper2.default(_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
    _skelImageWrapper = new _image_wrapper2.default(_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
    _skeletonizer = (0, _skeletonizer3.default)(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
        size: _patchSize.x
    }, skeletonImageData);

    _imageToPatchGrid = new _image_wrapper2.default({
        x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
        y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
    }, undefined, Array, true);
    _patchGrid = new _image_wrapper2.default(_imageToPatchGrid.size, undefined, undefined, true);
    _patchLabelGrid = new _image_wrapper2.default(_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
    if (_config.useWorker || typeof document === 'undefined') {
        return;
    }
    _canvasContainer.dom.binary = document.createElement("canvas");
    _canvasContainer.dom.binary.className = "binaryBuffer";
    if (false) {
        document.querySelector("#debug").appendChild(_canvasContainer.dom.binary);
    }
    _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext("2d");
    _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
    _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}

/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */
function boxFromPatches(patches) {
    var overAvg,
        i,
        j,
        patch,
        transMat,
        minx = _binaryImageWrapper.size.x,
        miny = _binaryImageWrapper.size.y,
        maxx = -_binaryImageWrapper.size.x,
        maxy = -_binaryImageWrapper.size.y,
        box,
        scale;

    // draw all patches which are to be taken into consideration
    overAvg = 0;
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        overAvg += patch.rad;
        if (false) {
            _image_debug2.default.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "red" });
        }
    }

    overAvg /= patches.length;
    overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;
    if (overAvg < 0) {
        overAvg += 180;
    }

    overAvg = (180 - overAvg) * Math.PI / 180;
    transMat = mat2.copy(mat2.create(), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]);

    // iterate over patches and rotate by angle
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            vec2.transformMat2(patch.box[j], patch.box[j], transMat);
        }

        if (false) {
            _image_debug2.default.drawPath(patch.box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#99ff00', lineWidth: 2 });
        }
    }

    // find bounding box
    for (i = 0; i < patches.length; i++) {
        patch = patches[i];
        for (j = 0; j < 4; j++) {
            if (patch.box[j][0] < minx) {
                minx = patch.box[j][0];
            }
            if (patch.box[j][0] > maxx) {
                maxx = patch.box[j][0];
            }
            if (patch.box[j][1] < miny) {
                miny = patch.box[j][1];
            }
            if (patch.box[j][1] > maxy) {
                maxy = patch.box[j][1];
            }
        }
    }

    box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

    if (false) {
        _image_debug2.default.drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    scale = _config.halfSample ? 2 : 1;
    // reverse rotation;
    transMat = mat2.invert(transMat, transMat);
    for (j = 0; j < 4; j++) {
        vec2.transformMat2(box[j], box[j], transMat);
    }

    if (false) {
        _image_debug2.default.drawPath(box, { x: 0, y: 1 }, _canvasContainer.ctx.binary, { color: '#ff0000', lineWidth: 2 });
    }

    for (j = 0; j < 4; j++) {
        vec2.scale(box[j], box[j], scale);
    }

    return box;
}

/**
 * Creates a binary image of the current image
 */
function binarizeImage() {
    (0, _cv_utils.otsuThreshold)(_currentImageWrapper, _binaryImageWrapper);
    _binaryImageWrapper.zeroBorder();
    if (false) {
        _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
    }
}

/**
 * Iterate over the entire image
 * extract patches
 */
function findPatches() {
    var i,
        j,
        x,
        y,
        moments,
        patchesFound = [],
        rasterizer,
        rasterResult,
        patch;
    for (i = 0; i < _numPatches.x; i++) {
        for (j = 0; j < _numPatches.y; j++) {
            x = _subImageWrapper.size.x * i;
            y = _subImageWrapper.size.y * j;

            // seperate parts
            skeletonize(x, y);

            // Rasterize, find individual bars
            _skelImageWrapper.zeroBorder();
            _array_helper2.default.init(_labelImageWrapper.data, 0);
            rasterizer = _rasterizer2.default.create(_skelImageWrapper, _labelImageWrapper);
            rasterResult = rasterizer.rasterize(0);

            if (false) {
                _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), { x: x, y: y });
            }

            // calculate moments from the skeletonized patch
            moments = _labelImageWrapper.moments(rasterResult.count);

            // extract eligible patches
            patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
        }
    }

    if (false) {
        for (i = 0; i < patchesFound.length; i++) {
            patch = patchesFound[i];
            _image_debug2.default.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "#99ff00", lineWidth: 2 });
        }
    }

    return patchesFound;
}

/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */
function findBiggestConnectedAreas(maxLabel) {
    var i,
        sum,
        labelHist = [],
        topLabels = [];

    for (i = 0; i < maxLabel; i++) {
        labelHist.push(0);
    }
    sum = _patchLabelGrid.data.length;
    while (sum--) {
        if (_patchLabelGrid.data[sum] > 0) {
            labelHist[_patchLabelGrid.data[sum] - 1]++;
        }
    }

    labelHist = labelHist.map(function (val, idx) {
        return {
            val: val,
            label: idx + 1
        };
    });

    labelHist.sort(function (a, b) {
        return b.val - a.val;
    });

    // extract top areas with at least 6 patches present
    topLabels = labelHist.filter(function (el) {
        return el.val >= 5;
    });

    return topLabels;
}

/**
 *
 */
function findBoxes(topLabels, maxLabel) {
    var i,
        j,
        sum,
        patches = [],
        patch,
        box,
        boxes = [],
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    for (i = 0; i < topLabels.length; i++) {
        sum = _patchLabelGrid.data.length;
        patches.length = 0;
        while (sum--) {
            if (_patchLabelGrid.data[sum] === topLabels[i].label) {
                patch = _imageToPatchGrid.data[sum];
                patches.push(patch);
            }
        }
        box = boxFromPatches(patches);
        if (box) {
            boxes.push(box);

            // draw patch-labels if requested
            if (false) {
                for (j = 0; j < patches.length; j++) {
                    patch = patches[j];
                    hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
                    (0, _cv_utils.hsv2rgb)(hsv, rgb);
                    _image_debug2.default.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
                }
            }
        }
    }
    return boxes;
}

/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */
function similarMoments(moments) {
    var clusters = (0, _cv_utils.cluster)(moments, 0.90);
    var topCluster = (0, _cv_utils.topGeneric)(clusters, 1, function (e) {
        return e.getPoints().length;
    });
    var points = [],
        result = [];
    if (topCluster.length === 1) {
        points = topCluster[0].item.getPoints();
        for (var i = 0; i < points.length; i++) {
            result.push(points[i].point);
        }
    }
    return result;
}

function skeletonize(x, y) {
    _binaryImageWrapper.subImageAsCopy(_subImageWrapper, (0, _cv_utils.imageRef)(x, y));
    _skeletonizer.skeletonize();

    // Show skeleton if requested
    if (false) {
        _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, (0, _cv_utils.imageRef)(x, y));
    }
}

/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */
function describePatch(moments, patchPos, x, y) {
    var k,
        avg,
        eligibleMoments = [],
        matchingMoments,
        patch,
        patchesFound = [],
        minComponentWeight = Math.ceil(_patchSize.x / 3);

    if (moments.length >= 2) {
        // only collect moments which's area covers at least minComponentWeight pixels.
        for (k = 0; k < moments.length; k++) {
            if (moments[k].m00 > minComponentWeight) {
                eligibleMoments.push(moments[k]);
            }
        }

        // if at least 2 moments are found which have at least minComponentWeights covered
        if (eligibleMoments.length >= 2) {
            matchingMoments = similarMoments(eligibleMoments);
            avg = 0;
            // determine the similarity of the moments
            for (k = 0; k < matchingMoments.length; k++) {
                avg += matchingMoments[k].rad;
            }

            // Only two of the moments are allowed not to fit into the equation
            // add the patch to the set
            if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
                avg /= matchingMoments.length;
                patch = {
                    index: patchPos[1] * _numPatches.x + patchPos[0],
                    pos: {
                        x: x,
                        y: y
                    },
                    box: [vec2.clone([x, y]), vec2.clone([x + _subImageWrapper.size.x, y]), vec2.clone([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), vec2.clone([x, y + _subImageWrapper.size.y])],
                    moments: matchingMoments,
                    rad: avg,
                    vec: vec2.clone([Math.cos(avg), Math.sin(avg)])
                };
                patchesFound.push(patch);
            }
        }
    }
    return patchesFound;
}

/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */
function rasterizeAngularSimilarity(patchesFound) {
    var label = 0,
        threshold = 0.95,
        currIdx = 0,
        j,
        patch,
        hsv = [0, 1, 1],
        rgb = [0, 0, 0];

    function notYetProcessed() {
        var i;
        for (i = 0; i < _patchLabelGrid.data.length; i++) {
            if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
                return i;
            }
        }
        return _patchLabelGrid.length;
    }

    function trace(currentIdx) {
        var x,
            y,
            currentPatch,
            idx,
            dir,
            current = {
            x: currentIdx % _patchLabelGrid.size.x,
            y: currentIdx / _patchLabelGrid.size.x | 0
        },
            similarity;

        if (currentIdx < _patchLabelGrid.data.length) {
            currentPatch = _imageToPatchGrid.data[currentIdx];
            // assign label
            _patchLabelGrid.data[currentIdx] = label;
            for (dir = 0; dir < _tracer2.default.searchDirections.length; dir++) {
                y = current.y + _tracer2.default.searchDirections[dir][0];
                x = current.x + _tracer2.default.searchDirections[dir][1];
                idx = y * _patchLabelGrid.size.x + x;

                // continue if patch empty
                if (_patchGrid.data[idx] === 0) {
                    _patchLabelGrid.data[idx] = Number.MAX_VALUE;
                    continue;
                }

                if (_patchLabelGrid.data[idx] === 0) {
                    similarity = Math.abs(vec2.dot(_imageToPatchGrid.data[idx].vec, currentPatch.vec));
                    if (similarity > threshold) {
                        trace(idx);
                    }
                }
            }
        }
    }

    // prepare for finding the right patches
    _array_helper2.default.init(_patchGrid.data, 0);
    _array_helper2.default.init(_patchLabelGrid.data, 0);
    _array_helper2.default.init(_imageToPatchGrid.data, null);

    for (j = 0; j < patchesFound.length; j++) {
        patch = patchesFound[j];
        _imageToPatchGrid.data[patch.index] = patch;
        _patchGrid.data[patch.index] = 1;
    }

    // rasterize the patches found to determine area
    _patchGrid.zeroBorder();

    while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
        label++;
        trace(currIdx);
    }

    // draw patch-labels if requested
    if (false) {
        for (j = 0; j < _patchLabelGrid.data.length; j++) {
            if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
                patch = _imageToPatchGrid.data[j];
                hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
                (0, _cv_utils.hsv2rgb)(hsv, rgb);
                _image_debug2.default.drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, { color: "rgb(" + rgb.join(",") + ")", lineWidth: 2 });
            }
        }
    }

    return label;
}

exports.default = {
    init: function init(inputImageWrapper, config) {
        _config = config;
        _inputImageWrapper = inputImageWrapper;

        initBuffers();
        initCanvas();
    },

    locate: function locate() {
        var patchesFound, topLabels, boxes;

        if (_config.halfSample) {
            (0, _cv_utils.halfSample)(_inputImageWrapper, _currentImageWrapper);
        }

        binarizeImage();
        patchesFound = findPatches();
        // return unless 5% or more patches are found
        if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
            return null;
        }

        // rasterrize area by comparing angular similarity;
        var maxLabel = rasterizeAngularSimilarity(patchesFound);
        if (maxLabel < 1) {
            return null;
        }

        // search for area with the most patches (biggest connected area)
        topLabels = findBiggestConnectedAreas(maxLabel);
        if (topLabels.length === 0) {
            return null;
        }

        boxes = findBoxes(topLabels, maxLabel);
        return boxes;
    },

    checkImageConstraints: function checkImageConstraints(inputStream, config) {
        var patchSize,
            width = inputStream.getWidth(),
            height = inputStream.getHeight(),
            halfSample = config.halfSample ? 0.5 : 1,
            size,
            area;

        // calculate width and height based on area
        if (inputStream.getConfig().area) {
            area = (0, _cv_utils.computeImageArea)(width, height, inputStream.getConfig().area);
            inputStream.setTopRight({ x: area.sx, y: area.sy });
            inputStream.setCanvasSize({ x: width, y: height });
            width = area.sw;
            height = area.sh;
        }

        size = {
            x: Math.floor(width * halfSample),
            y: Math.floor(height * halfSample)
        };

        patchSize = (0, _cv_utils.calculatePatchSize)(config.patchSize, size);
        if (false) {
            console.log("Patch-Size: " + JSON.stringify(patchSize));
        }

        inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / halfSample) * patchSize.x));
        inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / halfSample) * patchSize.y));

        if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
            return true;
        }

        throw new Error("Image dimensions do not comply with the current settings: Width (" + width + " )and height (" + height + ") must a multiple of " + patchSize.x);
    }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(48)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _tracer = __webpack_require__(30);

var _tracer2 = _interopRequireDefault(_tracer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Rasterizer = {
    createContour2D: function createContour2D() {
        return {
            dir: null,
            index: null,
            firstVertex: null,
            insideContours: null,
            nextpeer: null,
            prevpeer: null
        };
    },
    CONTOUR_DIR: {
        CW_DIR: 0,
        CCW_DIR: 1,
        UNKNOWN_DIR: 2
    },
    DIR: {
        OUTSIDE_EDGE: -32767,
        INSIDE_EDGE: -32766
    },
    create: function create(imageWrapper, labelWrapper) {
        var imageData = imageWrapper.data,
            labelData = labelWrapper.data,
            width = imageWrapper.size.x,
            height = imageWrapper.size.y,
            tracer = _tracer2.default.create(imageWrapper, labelWrapper);

        return {
            rasterize: function rasterize(depthlabel) {
                var color,
                    bc,
                    lc,
                    labelindex,
                    cx,
                    cy,
                    colorMap = [],
                    vertex,
                    p,
                    cc,
                    sc,
                    pos,
                    connectedCount = 0,
                    i;

                for (i = 0; i < 400; i++) {
                    colorMap[i] = 0;
                }

                colorMap[0] = imageData[0];
                cc = null;
                for (cy = 1; cy < height - 1; cy++) {
                    labelindex = 0;
                    bc = colorMap[0];
                    for (cx = 1; cx < width - 1; cx++) {
                        pos = cy * width + cx;
                        if (labelData[pos] === 0) {
                            color = imageData[pos];
                            if (color !== bc) {
                                if (labelindex === 0) {
                                    lc = connectedCount + 1;
                                    colorMap[lc] = color;
                                    bc = color;
                                    vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);
                                    if (vertex !== null) {
                                        connectedCount++;
                                        labelindex = lc;
                                        p = Rasterizer.createContour2D();
                                        p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        p.index = labelindex;
                                        p.firstVertex = vertex;
                                        p.nextpeer = cc;
                                        p.insideContours = null;
                                        if (cc !== null) {
                                            cc.prevpeer = p;
                                        }
                                        cc = p;
                                    }
                                } else {
                                    vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);
                                    if (vertex !== null) {
                                        p = Rasterizer.createContour2D();
                                        p.firstVertex = vertex;
                                        p.insideContours = null;
                                        if (depthlabel === 0) {
                                            p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                                        } else {
                                            p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                                        }
                                        p.index = depthlabel;
                                        sc = cc;
                                        while (sc !== null && sc.index !== labelindex) {
                                            sc = sc.nextpeer;
                                        }
                                        if (sc !== null) {
                                            p.nextpeer = sc.insideContours;
                                            if (sc.insideContours !== null) {
                                                sc.insideContours.prevpeer = p;
                                            }
                                            sc.insideContours = p;
                                        }
                                    }
                                }
                            } else {
                                labelData[pos] = labelindex;
                            }
                        } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                            labelindex = 0;
                            if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                                bc = imageData[pos];
                            } else {
                                bc = colorMap[0];
                            }
                        } else {
                            labelindex = labelData[pos];
                            bc = colorMap[labelindex];
                        }
                    }
                }
                sc = cc;
                while (sc !== null) {
                    sc.index = depthlabel;
                    sc = sc.nextpeer;
                }
                return {
                    cc: cc,
                    count: connectedCount
                };
            },
            debug: {
                drawContour: function drawContour(canvas, firstContour) {
                    var ctx = canvas.getContext("2d"),
                        pq = firstContour,
                        iq,
                        q,
                        p;

                    ctx.strokeStyle = "red";
                    ctx.fillStyle = "red";
                    ctx.lineWidth = 1;

                    if (pq !== null) {
                        iq = pq.insideContours;
                    } else {
                        iq = null;
                    }

                    while (pq !== null) {
                        if (iq !== null) {
                            q = iq;
                            iq = iq.nextpeer;
                        } else {
                            q = pq;
                            pq = pq.nextpeer;
                            if (pq !== null) {
                                iq = pq.insideContours;
                            } else {
                                iq = null;
                            }
                        }

                        switch (q.dir) {
                            case Rasterizer.CONTOUR_DIR.CW_DIR:
                                ctx.strokeStyle = "red";
                                break;
                            case Rasterizer.CONTOUR_DIR.CCW_DIR:
                                ctx.strokeStyle = "blue";
                                break;
                            case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                                ctx.strokeStyle = "green";
                                break;
                        }

                        p = q.firstVertex;
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        do {
                            p = p.next;
                            ctx.lineTo(p.x, p.y);
                        } while (p !== q.firstVertex);
                        ctx.stroke();
                    }
                }
            }
        };
    }
};

exports.default = Rasterizer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
/* @preserve ASM BEGIN */
/* eslint-disable eqeqeq*/
function Skeletonizer(stdlib, foreign, buffer) {
    "use asm";

    var images = new stdlib.Uint8Array(buffer),
        size = foreign.size | 0,
        imul = stdlib.Math.imul;

    function erode(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) == (5 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function subtract(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
        aImagePtr = aImagePtr | 0;
        bImagePtr = bImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
        }
    }

    function countNonZero(imagePtr) {
        imagePtr = imagePtr | 0;

        var sum = 0,
            length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
        }

        return sum | 0;
    }

    function init(imagePtr, value) {
        imagePtr = imagePtr | 0;
        value = value | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[imagePtr + length | 0] = value;
        }
    }

    function dilate(inImagePtr, outImagePtr) {
        inImagePtr = inImagePtr | 0;
        outImagePtr = outImagePtr | 0;

        var v = 0,
            u = 0,
            sum = 0,
            yStart1 = 0,
            yStart2 = 0,
            xStart1 = 0,
            xStart2 = 0,
            offset = 0;

        for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
            offset = offset + size | 0;
            for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
                yStart1 = offset - size | 0;
                yStart2 = offset + size | 0;
                xStart1 = u - 1 | 0;
                xStart2 = u + 1 | 0;
                sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;
                if ((sum | 0) > (0 | 0)) {
                    images[outImagePtr + offset + u | 0] = 1;
                } else {
                    images[outImagePtr + offset + u | 0] = 0;
                }
            }
        }
        return;
    }

    function memcpy(srcImagePtr, dstImagePtr) {
        srcImagePtr = srcImagePtr | 0;
        dstImagePtr = dstImagePtr | 0;

        var length = 0;

        length = imul(size, size) | 0;

        while ((length | 0) > 0) {
            length = length - 1 | 0;
            images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
        }
    }

    function zeroBorder(imagePtr) {
        imagePtr = imagePtr | 0;

        var x = 0,
            y = 0;

        for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
            images[imagePtr + x | 0] = 0;
            images[imagePtr + y | 0] = 0;
            y = y + size - 1 | 0;
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
        for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
            images[imagePtr + y | 0] = 0;
            y = y + 1 | 0;
        }
    }

    function skeletonize() {
        var subImagePtr = 0,
            erodedImagePtr = 0,
            tempImagePtr = 0,
            skelImagePtr = 0,
            sum = 0,
            done = 0;

        erodedImagePtr = imul(size, size) | 0;
        tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
        skelImagePtr = tempImagePtr + erodedImagePtr | 0;

        // init skel-image
        init(skelImagePtr, 0);
        zeroBorder(subImagePtr);

        do {
            erode(subImagePtr, erodedImagePtr);
            dilate(erodedImagePtr, tempImagePtr);
            subtract(subImagePtr, tempImagePtr, tempImagePtr);
            bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
            memcpy(erodedImagePtr, subImagePtr);
            sum = countNonZero(subImagePtr) | 0;
            done = (sum | 0) == 0 | 0;
        } while (!done);
    }
    return {
        skeletonize: skeletonize
    };
}
/* @preserve ASM END */
exports.default = Skeletonizer;
/* eslint-enable eqeqeq*/

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TwoOfFiveReader(opts) {
    _barcode_reader2.default.call(this, opts);
    this.barSpaceRatio = [1, 1];
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [W, N, W, N, N, N] },
    STOP_PATTERN: { value: [W, N, N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.30, writable: true },
    FORMAT: { value: "2of5" }
};

var startPatternLength = properties.START_PATTERN.value.reduce(function (sum, val) {
    return sum + val;
}, 0);

TwoOfFiveReader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
TwoOfFiveReader.prototype.constructor = TwoOfFiveReader;

TwoOfFiveReader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / startPatternLength);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

TwoOfFiveReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

TwoOfFiveReader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp,
        offset;

    self._row.reverse();
    offset = self._nextSet(self._row);
    endInfo = self._findPattern(self.STOP_PATTERN, offset, false, true);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

TwoOfFiveReader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

TwoOfFiveReader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counter = [0, 0, 0, 0, 0],
        code;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counter[i] = counters[pos] * this.barSpaceRatio[0];
            pos += 2;
        }
        code = self._decodeCode(counter);
        if (!code) {
            return null;
        }
        result.push(code.code + "");
        decodedCodes.push(code);
    }
    return code;
};

TwoOfFiveReader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

TwoOfFiveReader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length < 5) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

exports.default = TwoOfFiveReader;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CodabarReader() {
    _barcode_reader2.default.call(this);
    this._counters = [];
}

var properties = {
    ALPHABETH_STRING: { value: "0123456789-$:/.+ABCD" },
    ALPHABET: { value: [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68] },
    CHARACTER_ENCODINGS: { value: [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E] },
    START_END: { value: [0x01A, 0x029, 0x00B, 0x00E] },
    MIN_ENCODED_CHARS: { value: 4 },
    MAX_ACCEPTABLE: { value: 2.0 },
    PADDING: { value: 1.5 },
    FORMAT: { value: "codabar", writeable: false }
};

CodabarReader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
CodabarReader.prototype.constructor = CodabarReader;

CodabarReader.prototype._decode = function () {
    var self = this,
        result = [],
        start,
        decodedChar,
        pattern,
        nextStart,
        end;

    this._counters = self._fillCounters();
    start = self._findStart();
    if (!start) {
        return null;
    }
    nextStart = start.startCounter;

    do {
        pattern = self._toPattern(nextStart);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        nextStart += 8;
        if (result.length > 1 && self._isStartEnd(pattern)) {
            break;
        }
    } while (nextStart < self._counters.length);

    // verify end
    if (result.length - 2 < self.MIN_ENCODED_CHARS || !self._isStartEnd(pattern)) {
        return null;
    }

    // verify end white space
    if (!self._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
    }

    if (!self._validateResult(result, start.startCounter)) {
        return null;
    }

    nextStart = nextStart > self._counters.length ? self._counters.length : nextStart;
    end = start.start + self._sumCounters(start.startCounter, nextStart - 8);

    return {
        code: result.join(""),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result
    };
};

CodabarReader.prototype._verifyWhitespace = function (startCounter, endCounter) {
    if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._calculatePatternLength = function (offset) {
    var i,
        sum = 0;

    for (i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
    }

    return sum;
};

CodabarReader.prototype._thresholdResultPattern = function (result, startCounter) {
    var self = this,
        categorization = {
        space: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        },
        bar: {
            narrow: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE },
            wide: { size: 0, counts: 0, min: 0, max: Number.MAX_VALUE }
        }
    },
        kind,
        cat,
        i,
        j,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 2 ? categorization.bar : categorization.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            cat.size += self._counters[pos + j];
            cat.counts++;
            pattern >>= 1;
        }
        pos += 8;
    }

    ["space", "bar"].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * self.MAX_ACCEPTABLE + self.PADDING) / newkind.wide.counts);
    });

    return categorization;
};

CodabarReader.prototype._charToPattern = function (char) {
    var self = this,
        charCode = char.charCodeAt(0),
        i;

    for (i = 0; i < self.ALPHABET.length; i++) {
        if (self.ALPHABET[i] === charCode) {
            return self.CHARACTER_ENCODINGS[i];
        }
    }
    return 0x0;
};

CodabarReader.prototype._validateResult = function (result, startCounter) {
    var self = this,
        thresholds = self._thresholdResultPattern(result, startCounter),
        i,
        j,
        kind,
        cat,
        size,
        pos = startCounter,
        pattern;

    for (i = 0; i < result.length; i++) {
        pattern = self._charToPattern(result[i]);
        for (j = 6; j >= 0; j--) {
            kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
            cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
            size = self._counters[pos + j];
            if (size < cat.min || size > cat.max) {
                return false;
            }
            pattern >>= 1;
        }
        pos += 8;
    }
    return true;
};

CodabarReader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

CodabarReader.prototype._computeAlternatingThreshold = function (offset, end) {
    var i,
        min = Number.MAX_VALUE,
        max = 0,
        counter;

    for (i = offset; i < end; i += 2) {
        counter = this._counters[i];
        if (counter > max) {
            max = counter;
        }
        if (counter < min) {
            min = counter;
        }
    }

    return (min + max) / 2.0 | 0;
};

CodabarReader.prototype._toPattern = function (offset) {
    var numCounters = 7,
        end = offset + numCounters,
        barThreshold,
        spaceThreshold,
        bitmask = 1 << numCounters - 1,
        pattern = 0,
        i,
        threshold;

    if (end > this._counters.length) {
        return -1;
    }

    barThreshold = this._computeAlternatingThreshold(offset, end);
    spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

    for (i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;
        if (this._counters[offset + i] > threshold) {
            pattern |= bitmask;
        }
        bitmask >>= 1;
    }

    return pattern;
};

CodabarReader.prototype._isStartEnd = function (pattern) {
    var i;

    for (i = 0; i < this.START_END.length; i++) {
        if (this.START_END[i] === pattern) {
            return true;
        }
    }
    return false;
};

CodabarReader.prototype._sumCounters = function (start, end) {
    var i,
        sum = 0;

    for (i = start; i < end; i++) {
        sum += this._counters[i];
    }
    return sum;
};

CodabarReader.prototype._findStart = function () {
    var self = this,
        i,
        pattern,
        start = self._nextUnset(self._row),
        end;

    for (i = 1; i < this._counters.length; i++) {
        pattern = self._toPattern(i);
        if (pattern !== -1 && self._isStartEnd(pattern)) {
            // TODO: Look for whitespace ahead
            start += self._sumCounters(0, i);
            end = start + self._sumCounters(i, i + 8);
            return {
                start: start,
                end: end,
                startCounter: i,
                endCounter: i + 8
            };
        }
    }
};

exports.default = CodabarReader;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Code128Reader() {
    _barcode_reader2.default.call(this);
}

var properties = {
    CODE_SHIFT: { value: 98 },
    CODE_C: { value: 99 },
    CODE_B: { value: 100 },
    CODE_A: { value: 101 },
    START_CODE_A: { value: 103 },
    START_CODE_B: { value: 104 },
    START_CODE_C: { value: 105 },
    STOP_CODE: { value: 106 },
    CODE_PATTERN: { value: [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]] },
    SINGLE_CODE_ERROR: { value: 0.64 },
    AVG_CODE_ERROR: { value: 0.30 },
    FORMAT: { value: "code_128", writeable: false },
    MODULE_INDICES: { value: { bar: [0, 2, 4], space: [1, 3, 5] } }
};

Code128Reader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
Code128Reader.prototype.constructor = Code128Reader;

Code128Reader.prototype._decodeCode = function (start, correction) {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = start,
        isWhite = !self._row[offset],
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                if (correction) {
                    self._correct(counter, correction);
                }
                for (code = 0; code < self.CODE_PATTERN.length; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                bestMatch.end = i;
                if (bestMatch.code === -1 || bestMatch.error > self.AVG_CODE_ERROR) {
                    return null;
                }
                if (self.CODE_PATTERN[bestMatch.code]) {
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                }
                return bestMatch;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._correct = function (counter, correction) {
    this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);
    this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
};

Code128Reader.prototype._findStart = function () {
    var counter = [0, 0, 0, 0, 0, 0],
        i,
        self = this,
        offset = self._nextSet(self._row),
        isWhite = false,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
            bar: 1,
            space: 1
        }
    },
        code,
        error,
        j,
        sum;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                for (code = self.START_CODE_A; code <= self.START_CODE_C; code++) {
                    error = self._matchPattern(counter, self.CODE_PATTERN[code]);
                    if (error < bestMatch.error) {
                        bestMatch.code = code;
                        bestMatch.error = error;
                    }
                }
                if (bestMatch.error < self.AVG_CODE_ERROR) {
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    bestMatch.correction.bar = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
                    bestMatch.correction.space = calculateCorrection(self.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
                    return bestMatch;
                }

                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code128Reader.prototype._decode = function () {
    var self = this,
        startInfo = self._findStart(),
        code = null,
        done = false,
        result = [],
        multiplier = 0,
        checksum = 0,
        codeset,
        rawResult = [],
        decodedCodes = [],
        shiftNext = false,
        unshift,
        removeLastCharacter = true;

    if (startInfo === null) {
        return null;
    }
    code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
            bar: startInfo.correction.bar,
            space: startInfo.correction.space
        }
    };
    decodedCodes.push(code);
    checksum = code.code;
    switch (code.code) {
        case self.START_CODE_A:
            codeset = self.CODE_A;
            break;
        case self.START_CODE_B:
            codeset = self.CODE_B;
            break;
        case self.START_CODE_C:
            codeset = self.CODE_C;
            break;
        default:
            return null;
    }

    while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = self._decodeCode(code.end, code.correction);
        if (code !== null) {
            if (code.code !== self.STOP_CODE) {
                removeLastCharacter = true;
            }

            if (code.code !== self.STOP_CODE) {
                rawResult.push(code.code);
                multiplier++;
                checksum += multiplier * code.code;
            }
            decodedCodes.push(code);

            switch (codeset) {
                case self.CODE_A:
                    if (code.code < 64) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else if (code.code < 96) {
                        result.push(String.fromCharCode(code.code - 64));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_B:
                    if (code.code < 96) {
                        result.push(String.fromCharCode(32 + code.code));
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_SHIFT:
                                shiftNext = true;
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_C:
                                codeset = self.CODE_C;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
                case self.CODE_C:
                    if (code.code < 100) {
                        result.push(code.code < 10 ? "0" + code.code : code.code);
                    } else {
                        if (code.code !== self.STOP_CODE) {
                            removeLastCharacter = false;
                        }
                        switch (code.code) {
                            case self.CODE_A:
                                codeset = self.CODE_A;
                                break;
                            case self.CODE_B:
                                codeset = self.CODE_B;
                                break;
                            case self.STOP_CODE:
                                done = true;
                                break;
                        }
                    }
                    break;
            }
        } else {
            done = true;
        }
        if (unshift) {
            codeset = codeset === self.CODE_A ? self.CODE_B : self.CODE_A;
        }
    }

    if (code === null) {
        return null;
    }

    code.end = self._nextUnset(self._row, code.end);
    if (!self._verifyTrailingWhitespace(code)) {
        return null;
    }

    checksum -= multiplier * rawResult[rawResult.length - 1];
    if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
    }

    if (!result.length) {
        return null;
    }

    // remove last code from result (checksum)
    if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
    }

    return {
        code: result.join(""),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code
    };
};

_barcode_reader2.default.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

function calculateCorrection(expected, normalized, indices) {
    var length = indices.length,
        sumNormalized = 0,
        sumExpected = 0;

    while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
    }
    return sumExpected / sumNormalized;
}

exports.default = Code128Reader;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _code_39_reader = __webpack_require__(31);

var _code_39_reader2 = _interopRequireDefault(_code_39_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Code39VINReader() {
    _code_39_reader2.default.call(this);
}

var patterns = {
    IOQ: /[IOQ]/g,
    AZ09: /[A-Z0-9]{17}/
};

Code39VINReader.prototype = Object.create(_code_39_reader2.default.prototype);
Code39VINReader.prototype.constructor = Code39VINReader;

// Cribbed from:
// https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java
Code39VINReader.prototype._decode = function () {
    var result = _code_39_reader2.default.prototype._decode.apply(this);
    if (!result) {
        return null;
    }

    var code = result.code;

    if (!code) {
        return null;
    }

    code = code.replace(patterns.IOQ, '');

    if (!code.match(patterns.AZ09)) {
        if (false) {
            console.log('Failed AZ09 pattern code:', code);
        }
        return null;
    }

    if (!this._checkChecksum(code)) {
        return null;
    }

    result.code = code;
    return result;
};

Code39VINReader.prototype._checkChecksum = function (code) {
    // TODO
    return !!code;
};

exports.default = Code39VINReader;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

var _array_helper = __webpack_require__(3);

var _array_helper2 = _interopRequireDefault(_array_helper);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Code93Reader() {
    _barcode_reader2.default.call(this);
}

var ALPHABETH_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*";

var properties = {
    ALPHABETH_STRING: { value: ALPHABETH_STRING },
    ALPHABET: { value: ALPHABETH_STRING.split('').map(function (char) {
            return char.charCodeAt(0);
        }) },
    CHARACTER_ENCODINGS: { value: [0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E] },
    ASTERISK: { value: 0x15E },
    FORMAT: { value: "code_93", writeable: false }
};

Code93Reader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
Code93Reader.prototype.constructor = Code93Reader;

Code93Reader.prototype._decode = function () {
    var self = this,
        counters = [0, 0, 0, 0, 0, 0],
        result = [],
        start = self._findStart(),
        decodedChar,
        lastStart,
        pattern,
        nextStart;

    if (!start) {
        return null;
    }
    nextStart = self._nextSet(self._row, start.end);

    do {
        counters = self._toCounters(nextStart, counters);
        pattern = self._toPattern(counters);
        if (pattern < 0) {
            return null;
        }
        decodedChar = self._patternToChar(pattern);
        if (decodedChar < 0) {
            return null;
        }
        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += _array_helper2.default.sum(counters);
        nextStart = self._nextSet(self._row, nextStart);
    } while (decodedChar !== '*');
    result.pop();

    if (!result.length) {
        return null;
    }

    if (!self._verifyEnd(lastStart, nextStart, counters)) {
        return null;
    }

    if (!self._verifyChecksums(result)) {
        return null;
    }

    result = result.slice(0, result.length - 2);
    if ((result = self._decodeExtended(result)) === null) {
        return null;
    };

    return {
        code: result.join(""),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result
    };
};

Code93Reader.prototype._verifyEnd = function (lastStart, nextStart) {
    if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
    }
    return true;
};

Code93Reader.prototype._patternToChar = function (pattern) {
    var i,
        self = this;

    for (i = 0; i < self.CHARACTER_ENCODINGS.length; i++) {
        if (self.CHARACTER_ENCODINGS[i] === pattern) {
            return String.fromCharCode(self.ALPHABET[i]);
        }
    }
    return -1;
};

Code93Reader.prototype._toPattern = function (counters) {
    var numCounters = counters.length;
    var pattern = 0;
    var sum = 0;
    for (var i = 0; i < numCounters; i++) {
        sum += counters[i];
    }

    for (var _i = 0; _i < numCounters; _i++) {
        var normalized = Math.round(counters[_i] * 9 / sum);
        if (normalized < 1 || normalized > 4) {
            return -1;
        }
        if ((_i & 1) === 0) {
            for (var j = 0; j < normalized; j++) {
                pattern = pattern << 1 | 1;
            }
        } else {
            pattern <<= normalized;
        }
    }

    return pattern;
};

Code93Reader.prototype._findStart = function () {
    var self = this,
        offset = self._nextSet(self._row),
        patternStart = offset,
        counter = [0, 0, 0, 0, 0, 0],
        counterPos = 0,
        isWhite = false,
        i,
        j,
        whiteSpaceMustStart;

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                // find start pattern
                if (self._toPattern(counter) === self.ASTERISK) {
                    whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));
                    if (self._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                        return {
                            start: patternStart,
                            end: i
                        };
                    }
                }

                patternStart += counter[0] + counter[1];
                for (j = 0; j < 4; j++) {
                    counter[j] = counter[j + 2];
                }
                counter[4] = 0;
                counter[5] = 0;
                counterPos--;
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

Code93Reader.prototype._decodeExtended = function (charArray) {
    var length = charArray.length;
    var result = [];
    for (var i = 0; i < length; i++) {
        var char = charArray[i];
        if (char >= 'a' && char <= 'd') {
            if (i > length - 2) {
                return null;
            }
            var nextChar = charArray[++i];
            var nextCharCode = nextChar.charCodeAt(0);
            var decodedChar = void 0;
            switch (char) {
                case 'a':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode - 64);
                    } else {
                        return null;
                    }
                    break;
                case 'b':
                    if (nextChar >= 'A' && nextChar <= 'E') {
                        decodedChar = String.fromCharCode(nextCharCode - 38);
                    } else if (nextChar >= 'F' && nextChar <= 'J') {
                        decodedChar = String.fromCharCode(nextCharCode - 11);
                    } else if (nextChar >= 'K' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode + 16);
                    } else if (nextChar >= 'P' && nextChar <= 'S') {
                        decodedChar = String.fromCharCode(nextCharCode + 43);
                    } else if (nextChar >= 'T' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(127);
                    } else {
                        return null;
                    }
                    break;
                case 'c':
                    if (nextChar >= 'A' && nextChar <= 'O') {
                        decodedChar = String.fromCharCode(nextCharCode - 32);
                    } else if (nextChar === 'Z') {
                        decodedChar = ':';
                    } else {
                        return null;
                    }
                    break;
                case 'd':
                    if (nextChar >= 'A' && nextChar <= 'Z') {
                        decodedChar = String.fromCharCode(nextCharCode + 32);
                    } else {
                        return null;
                    }
                    break;
            }
            result.push(decodedChar);
        } else {
            result.push(char);
        }
    }
    return result;
};

Code93Reader.prototype._verifyChecksums = function (charArray) {
    return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
};

Code93Reader.prototype._matchCheckChar = function (charArray, index, maxWeight) {
    var _this = this;

    var arrayToCheck = charArray.slice(0, index);
    var length = arrayToCheck.length;
    var weightedSums = arrayToCheck.reduce(function (sum, char, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = _this.ALPHABET.indexOf(char.charCodeAt(0));
        return sum + weight * value;
    }, 0);

    var checkChar = this.ALPHABET[weightedSums % 47];
    return checkChar === charArray[index].charCodeAt(0);
};

exports.default = Code93Reader;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EAN2Reader() {
    _ean_reader2.default.call(this);
}

var properties = {
    FORMAT: { value: "ean_2", writeable: false }
};

EAN2Reader.prototype = Object.create(_ean_reader2.default.prototype, properties);
EAN2Reader.prototype.constructor = EAN2Reader;

EAN2Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 1 - i;
        }
        if (i != 1) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 2 || parseInt(result.join("")) % 4 !== codeFrequency) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

exports.default = EAN2Reader;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EAN5Reader() {
    _ean_reader2.default.call(this);
}

var properties = {
    FORMAT: { value: "ean_5", writeable: false }
};

var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

EAN5Reader.prototype = Object.create(_ean_reader2.default.prototype, properties);
EAN5Reader.prototype.constructor = EAN5Reader;

EAN5Reader.prototype.decode = function (row, start) {
    this._row = row;
    var counters = [0, 0, 0, 0],
        codeFrequency = 0,
        i = 0,
        offset = start,
        end = this._row.length,
        code,
        result = [],
        decodedCodes = [];

    for (i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code % 10);
        if (code.code >= this.CODE_G_START) {
            codeFrequency |= 1 << 4 - i;
        }
        if (i != 4) {
            offset = this._nextSet(this._row, code.end);
            offset = this._nextUnset(this._row, offset);
        }
    }

    if (result.length != 5) {
        return null;
    }

    if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
    }
    return {
        code: result.join(""),
        decodedCodes: decodedCodes,
        end: code.end
    };
};

function determineCheckDigit(codeFrequency) {
    var i;
    for (i = 0; i < 10; i++) {
        if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
            return i;
        }
    }
    return null;
}

function extensionChecksum(result) {
    var length = result.length,
        sum = 0,
        i;

    for (i = length - 2; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    for (i = length - 1; i >= 0; i -= 2) {
        sum += result[i];
    }
    sum *= 3;
    return sum % 10;
}

exports.default = EAN5Reader;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function EAN8Reader(opts, supplements) {
    _ean_reader2.default.call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "ean_8", writeable: false }
};

EAN8Reader.prototype = Object.create(_ean_reader2.default.prototype, properties);
EAN8Reader.prototype.constructor = EAN8Reader;

EAN8Reader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this;

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }

    code = self._findPattern(self.MIDDLE_PATTERN, code.end, true, false);
    if (code === null) {
        return null;
    }
    decodedCodes.push(code);

    for (i = 0; i < 4; i++) {
        code = self._decodeCode(code.end, self.CODE_G_START);
        if (!code) {
            return null;
        }
        decodedCodes.push(code);
        result.push(code.code);
    }

    return code;
};

exports.default = EAN8Reader;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _merge2 = __webpack_require__(28);

var _merge3 = _interopRequireDefault(_merge2);

var _barcode_reader = __webpack_require__(1);

var _barcode_reader2 = _interopRequireDefault(_barcode_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function I2of5Reader(opts) {
    opts = (0, _merge3.default)(getDefaulConfig(), opts);
    _barcode_reader2.default.call(this, opts);
    this.barSpaceRatio = [1, 1];
    if (opts.normalizeBarSpaceWidth) {
        this.SINGLE_CODE_ERROR = 0.38;
        this.AVG_CODE_ERROR = 0.09;
    }
}

function getDefaulConfig() {
    var config = {};

    Object.keys(I2of5Reader.CONFIG_KEYS).forEach(function (key) {
        config[key] = I2of5Reader.CONFIG_KEYS[key].default;
    });
    return config;
}

var N = 1,
    W = 3,
    properties = {
    START_PATTERN: { value: [N, N, N, N] },
    STOP_PATTERN: { value: [N, N, W] },
    CODE_PATTERN: { value: [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]] },
    SINGLE_CODE_ERROR: { value: 0.78, writable: true },
    AVG_CODE_ERROR: { value: 0.38, writable: true },
    MAX_CORRECTION_FACTOR: { value: 5 },
    FORMAT: { value: "i2of5" }
};

I2of5Reader.prototype = Object.create(_barcode_reader2.default.prototype, properties);
I2of5Reader.prototype.constructor = I2of5Reader;

I2of5Reader.prototype._matchPattern = function (counter, code) {
    if (this.config.normalizeBarSpaceWidth) {
        var i,
            counterSum = [0, 0],
            codeSum = [0, 0],
            correction = [0, 0],
            correctionRatio = this.MAX_CORRECTION_FACTOR,
            correctionRatioInverse = 1 / correctionRatio;

        for (i = 0; i < counter.length; i++) {
            counterSum[i % 2] += counter[i];
            codeSum[i % 2] += code[i];
        }
        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];

        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;
        for (i = 0; i < counter.length; i++) {
            counter[i] *= this.barSpaceRatio[i % 2];
        }
    }
    return _barcode_reader2.default.prototype._matchPattern.call(this, counter, code);
};

I2of5Reader.prototype._findPattern = function (pattern, offset, isWhite, tryHarder) {
    var counter = [],
        self = this,
        i,
        counterPos = 0,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    },
        error,
        j,
        sum,
        normalized,
        epsilon = self.AVG_CODE_ERROR;

    isWhite = isWhite || false;
    tryHarder = tryHarder || false;

    if (!offset) {
        offset = self._nextSet(self._row);
    }

    for (i = 0; i < pattern.length; i++) {
        counter[i] = 0;
    }

    for (i = offset; i < self._row.length; i++) {
        if (self._row[i] ^ isWhite) {
            counter[counterPos]++;
        } else {
            if (counterPos === counter.length - 1) {
                sum = 0;
                for (j = 0; j < counter.length; j++) {
                    sum += counter[j];
                }
                error = self._matchPattern(counter, pattern);
                if (error < epsilon) {
                    bestMatch.error = error;
                    bestMatch.start = i - sum;
                    bestMatch.end = i;
                    return bestMatch;
                }
                if (tryHarder) {
                    for (j = 0; j < counter.length - 2; j++) {
                        counter[j] = counter[j + 2];
                    }
                    counter[counter.length - 2] = 0;
                    counter[counter.length - 1] = 0;
                    counterPos--;
                } else {
                    return null;
                }
            } else {
                counterPos++;
            }
            counter[counterPos] = 1;
            isWhite = !isWhite;
        }
    }
    return null;
};

I2of5Reader.prototype._findStart = function () {
    var self = this,
        leadingWhitespaceStart,
        offset = self._nextSet(self._row),
        startInfo,
        narrowBarWidth = 1;

    while (!startInfo) {
        startInfo = self._findPattern(self.START_PATTERN, offset, false, true);
        if (!startInfo) {
            return null;
        }
        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;
        if (leadingWhitespaceStart >= 0) {
            if (self._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
                return startInfo;
            }
        }
        offset = startInfo.end;
        startInfo = null;
    }
};

I2of5Reader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
    return null;
};

I2of5Reader.prototype._findEnd = function () {
    var self = this,
        endInfo,
        tmp;

    self._row.reverse();
    endInfo = self._findPattern(self.STOP_PATTERN);
    self._row.reverse();

    if (endInfo === null) {
        return null;
    }

    // reverse numbers
    tmp = endInfo.start;
    endInfo.start = self._row.length - endInfo.end;
    endInfo.end = self._row.length - tmp;

    return endInfo !== null ? self._verifyTrailingWhitespace(endInfo) : null;
};

I2of5Reader.prototype._decodePair = function (counterPair) {
    var i,
        code,
        codes = [],
        self = this;

    for (i = 0; i < counterPair.length; i++) {
        code = self._decodeCode(counterPair[i]);
        if (!code) {
            return null;
        }
        codes.push(code);
    }
    return codes;
};

I2of5Reader.prototype._decodeCode = function (counter) {
    var j,
        self = this,
        sum = 0,
        normalized,
        error,
        epsilon = self.AVG_CODE_ERROR,
        code,
        bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
    };

    for (j = 0; j < counter.length; j++) {
        sum += counter[j];
    }
    for (code = 0; code < self.CODE_PATTERN.length; code++) {
        error = self._matchPattern(counter, self.CODE_PATTERN[code]);
        if (error < bestMatch.error) {
            bestMatch.code = code;
            bestMatch.error = error;
        }
    }
    if (bestMatch.error < epsilon) {
        return bestMatch;
    }
};

I2of5Reader.prototype._decodePayload = function (counters, result, decodedCodes) {
    var i,
        self = this,
        pos = 0,
        counterLength = counters.length,
        counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]],
        codes;

    while (pos < counterLength) {
        for (i = 0; i < 5; i++) {
            counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
            counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
            pos += 2;
        }
        codes = self._decodePair(counterPair);
        if (!codes) {
            return null;
        }
        for (i = 0; i < codes.length; i++) {
            result.push(codes[i].code + "");
            decodedCodes.push(codes[i]);
        }
    }
    return codes;
};

I2of5Reader.prototype._verifyCounterLength = function (counters) {
    return counters.length % 10 === 0;
};

I2of5Reader.prototype._decode = function () {
    var startInfo,
        endInfo,
        self = this,
        code,
        result = [],
        decodedCodes = [],
        counters;

    startInfo = self._findStart();
    if (!startInfo) {
        return null;
    }
    decodedCodes.push(startInfo);

    endInfo = self._findEnd();
    if (!endInfo) {
        return null;
    }

    counters = self._fillCounters(startInfo.end, endInfo.start, false);
    if (!self._verifyCounterLength(counters)) {
        return null;
    }
    code = self._decodePayload(counters, result, decodedCodes);
    if (!code) {
        return null;
    }
    if (result.length % 2 !== 0 || result.length < 6) {
        return null;
    }

    decodedCodes.push(endInfo);
    return {
        code: result.join(""),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
    };
};

I2of5Reader.CONFIG_KEYS = {
    normalizeBarSpaceWidth: {
        'type': 'boolean',
        'default': false,
        'description': 'If true, the reader tries to normalize the' + 'width-difference between bars and spaces'
    }
};

exports.default = I2of5Reader;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _qrcodeReader = __webpack_require__(63);

var _qrcodeReader2 = _interopRequireDefault(_qrcodeReader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var qr = new _qrcodeReader2.default();

var properties = {
    FORMAT: { value: "qr_code", writeable: false }
};

QrCodeReader.prototype = Object.create(QrCodeReader.prototype, properties);
QrCodeReader.prototype.constructor = QrCodeReader;

function QrCodeReader(config, supplements) {
    this._row = [];
    this.config = config || {};
    this.supplements = supplements;
    return this;
}

QrCodeReader.prototype.decodePattern = function (pattern, inputImageWrapper) {
    var result = qr.decode({ width: inputImageWrapper.size.x, height: inputImageWrapper.size.y }, inputImageWrapper.data);
    if (result === null) {
        return null;
    }
    return { code: result && result.result };
};

exports.default = QrCodeReader;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function UPCEReader(opts, supplements) {
    _ean_reader2.default.call(this, opts, supplements);
}

var properties = {
    CODE_FREQUENCY: { value: [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]] },
    STOP_PATTERN: { value: [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7] },
    FORMAT: { value: "upc_e", writeable: false }
};

UPCEReader.prototype = Object.create(_ean_reader2.default.prototype, properties);
UPCEReader.prototype.constructor = UPCEReader;

UPCEReader.prototype._decodePayload = function (code, result, decodedCodes) {
    var i,
        self = this,
        codeFrequency = 0x0;

    for (i = 0; i < 6; i++) {
        code = self._decodeCode(code.end);
        if (!code) {
            return null;
        }
        if (code.code >= self.CODE_G_START) {
            code.code = code.code - self.CODE_G_START;
            codeFrequency |= 1 << 5 - i;
        }
        result.push(code.code);
        decodedCodes.push(code);
    }
    if (!self._determineParity(codeFrequency, result)) {
        return null;
    }

    return code;
};

UPCEReader.prototype._determineParity = function (codeFrequency, result) {
    var i, nrSystem;

    for (nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
            if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
                result.unshift(nrSystem);
                result.push(i);
                return true;
            }
        }
    }
    return false;
};

UPCEReader.prototype._convertToUPCA = function (result) {
    var upca = [result[0]],
        lastDigit = result[result.length - 2];

    if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
    } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
    } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
    } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
    }

    upca.push(result[result.length - 1]);
    return upca;
};

UPCEReader.prototype._checksum = function (result) {
    return _ean_reader2.default.prototype._checksum.call(this, this._convertToUPCA(result));
};

UPCEReader.prototype._findEnd = function (offset, isWhite) {
    isWhite = true;
    return _ean_reader2.default.prototype._findEnd.call(this, offset, isWhite);
};

UPCEReader.prototype._verifyTrailingWhitespace = function (endInfo) {
    var self = this,
        trailingWhitespaceEnd;

    trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;
    if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
            return endInfo;
        }
    }
};

exports.default = UPCEReader;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _ean_reader = __webpack_require__(4);

var _ean_reader2 = _interopRequireDefault(_ean_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function UPCReader(opts, supplements) {
    _ean_reader2.default.call(this, opts, supplements);
}

var properties = {
    FORMAT: { value: "upc_a", writeable: false }
};

UPCReader.prototype = Object.create(_ean_reader2.default.prototype, properties);
UPCReader.prototype.constructor = UPCReader;

UPCReader.prototype._decode = function () {
    var result = _ean_reader2.default.prototype._decode.call(this);

    if (result && result.code && result.code.length === 13 && result.code.charAt(0) === "0") {
        result.code = result.code.substring(1);
        return result;
    }
    return null;
};

exports.default = UPCReader;

/***/ }),
/* 79 */
/***/ (function(module, exports) {

module.exports = copy

/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0]
  out[1] = a[1]
  out[2] = a[2]
  out[3] = a[3]
  return out
}


/***/ }),
/* 80 */
/***/ (function(module, exports) {

module.exports = create

/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new Float32Array(4)
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 1
  return out
}


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = invert

/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var a3 = a[3]
  var det = a0 * a3 - a2 * a1

  if (!det) return null
  det = 1.0 / det

  out[0] =  a3 * det
  out[1] = -a1 * det
  out[2] = -a2 * det
  out[3] =  a0 * det

  return out
}


/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = scale

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    return out
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = transformMat2

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
    var x = a[0],
        y = a[1]
    out[0] = m[0] * x + m[2] * y
    out[1] = m[1] * x + m[3] * y
    return out
}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(123),
    hashDelete = __webpack_require__(124),
    hashGet = __webpack_require__(125),
    hashHas = __webpack_require__(126),
    hashSet = __webpack_require__(127);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    stackClear = __webpack_require__(150),
    stackDelete = __webpack_require__(151),
    stackGet = __webpack_require__(152),
    stackHas = __webpack_require__(153),
    stackSet = __webpack_require__(154);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(108),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(45),
    isIndex = __webpack_require__(15),
    isTypedArray = __webpack_require__(46);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),
/* 91 */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0);

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(91),
    isFlattenable = __webpack_require__(129);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(118);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),
/* 96 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(25),
    isMasked = __webpack_require__(133),
    isObject = __webpack_require__(0),
    toSource = __webpack_require__(156);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    isLength = __webpack_require__(26),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(0),
    isPrototype = __webpack_require__(40),
    nativeKeysIn = __webpack_require__(145);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(86),
    assignMergeValue = __webpack_require__(35),
    baseFor = __webpack_require__(94),
    baseMergeDeep = __webpack_require__(102),
    isObject = __webpack_require__(0),
    keysIn = __webpack_require__(47),
    safeGet = __webpack_require__(42);

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    if (isObject(srcValue)) {
      stack || (stack = new Stack);
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var assignMergeValue = __webpack_require__(35),
    cloneBuffer = __webpack_require__(112),
    cloneTypedArray = __webpack_require__(113),
    copyArray = __webpack_require__(114),
    initCloneObject = __webpack_require__(128),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isArrayLikeObject = __webpack_require__(160),
    isBuffer = __webpack_require__(45),
    isFunction = __webpack_require__(25),
    isObject = __webpack_require__(0),
    isPlainObject = __webpack_require__(161),
    isTypedArray = __webpack_require__(46),
    safeGet = __webpack_require__(42),
    toPlainObject = __webpack_require__(165);

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var basePickBy = __webpack_require__(104),
    hasIn = __webpack_require__(159);

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(95),
    baseSet = __webpack_require__(106),
    castPath = __webpack_require__(13);

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(44),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(43);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    castPath = __webpack_require__(13),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0),
    toKey = __webpack_require__(23);

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(157),
    defineProperty = __webpack_require__(37),
    identity = __webpack_require__(44);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),
/* 108 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    arrayMap = __webpack_require__(90),
    isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),
/* 110 */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(87);

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(5);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(111);

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),
/* 114 */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(36),
    baseAssignValue = __webpack_require__(21);

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(5);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var baseRest = __webpack_require__(105),
    isIterateeCall = __webpack_require__(130);

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),
/* 118 */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var flatten = __webpack_require__(158),
    overRest = __webpack_require__(41),
    setToString = __webpack_require__(43);

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),
/* 121 */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(13),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2),
    isIndex = __webpack_require__(15),
    isLength = __webpack_require__(26),
    toKey = __webpack_require__(23);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),
/* 124 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(16);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(92),
    getPrototype = __webpack_require__(39),
    isPrototype = __webpack_require__(40);

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var Symbol = __webpack_require__(11),
    isArguments = __webpack_require__(18),
    isArray = __webpack_require__(2);

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(17),
    isArrayLike = __webpack_require__(24),
    isIndex = __webpack_require__(15),
    isObject = __webpack_require__(0);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(27);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),
/* 132 */
/***/ (function(module, exports) {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(116);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),
/* 134 */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(12);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(85),
    ListCache = __webpack_require__(10),
    Map = __webpack_require__(33);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(14);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(162);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),
/* 145 */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(38);

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29)(module)))

/***/ }),
/* 147 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),
/* 148 */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),
/* 149 */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),
/* 151 */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),
/* 152 */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),
/* 153 */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(10),
    Map = __webpack_require__(33),
    MapCache = __webpack_require__(34);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(144);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),
/* 156 */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),
/* 157 */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(93);

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(96),
    hasPath = __webpack_require__(122);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(24),
    isObjectLike = __webpack_require__(6);

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(8),
    getPrototype = __webpack_require__(39),
    isObjectLike = __webpack_require__(6);

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(34);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

var basePick = __webpack_require__(103),
    flatRest = __webpack_require__(119);

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),
/* 164 */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(115),
    keysIn = __webpack_require__(47);

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(109);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_167__;

/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_168__;

/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_169__;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(49);


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAxNzQyMWFhOGQ0YTk2NWUwMmI5ZiIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2JhcmNvZGVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9hcnJheV9oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19yb290LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9pbWFnZV9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9lcS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbG9jYXRvci90cmFjZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLXZlYzIvZG90LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zYWZlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3F1YWdnYS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvaW5wdXRfc3RyZWFtLmpzIiwid2VicGFjazovLy8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9tZWRpYURldmljZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbW1vbi9zdWJJbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tbW9uL3R5cGVkZWZzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLmpzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvY29uZmlnLm5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9kZWNvZGVyL2JyZXNlbmhhbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbGliL3FyY29kZS1yZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvMm9mNV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMTI4X3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvaTJvZjVfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9yZWFkZXIvcXJfY29kZV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3JlYWRlci91cGNfcmVhZGVyLmpzIiwid2VicGFjazovLy8uL34vZ2wtbWF0Mi9jb3B5LmpzIiwid2VicGFjazovLy8uL34vZ2wtbWF0Mi9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbC1tYXQyL2ludmVydC5qcyIsIndlYnBhY2s6Ly8vLi9+L2dsLXZlYzIvc2NhbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbC12ZWMyL3RyYW5zZm9ybU1hdDIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VQaWNrLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUGlja0J5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvcGljay5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9QbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJnZXQtcGl4ZWxzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmRhcnJheVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIiXSwibmFtZXMiOlsiQmFyY29kZVJlYWRlciIsImNvbmZpZyIsInN1cHBsZW1lbnRzIiwiX3JvdyIsInByb3RvdHlwZSIsIl9uZXh0VW5zZXQiLCJsaW5lIiwic3RhcnQiLCJpIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiX21hdGNoUGF0dGVybiIsImNvdW50ZXIiLCJjb2RlIiwibWF4U2luZ2xlRXJyb3IiLCJlcnJvciIsInNpbmdsZUVycm9yIiwic3VtIiwibW9kdWxvIiwiYmFyV2lkdGgiLCJjb3VudCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiTWF0aCIsImFicyIsIl9uZXh0U2V0Iiwib2Zmc2V0IiwiX2NvcnJlY3RCYXJzIiwiY29ycmVjdGlvbiIsImluZGljZXMiLCJ0bXAiLCJfbWF0Y2hUcmFjZSIsImNtcENvdW50ZXIiLCJlcHNpbG9uIiwic2VsZiIsImlzV2hpdGUiLCJjb3VudGVyUG9zIiwiYmVzdE1hdGNoIiwicHVzaCIsImVuZCIsImRlY29kZVBhdHRlcm4iLCJwYXR0ZXJuIiwicmVzdWx0IiwiX2RlY29kZSIsInJldmVyc2UiLCJkaXJlY3Rpb24iLCJESVJFQ1RJT04iLCJSRVZFUlNFIiwiRk9SV0FSRCIsImZvcm1hdCIsIkZPUk1BVCIsIl9tYXRjaFJhbmdlIiwidmFsdWUiLCJfZmlsbENvdW50ZXJzIiwiY291bnRlcnMiLCJfdG9Db3VudGVycyIsIm51bUNvdW50ZXJzIiwiaW5pdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwid3JpdGVhYmxlIiwiRXhjZXB0aW9uIiwiU3RhcnROb3RGb3VuZEV4Y2VwdGlvbiIsIkNvZGVOb3RGb3VuZEV4Y2VwdGlvbiIsIlBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbiIsIkNPTkZJR19LRVlTIiwiYXJyIiwidmFsIiwibCIsInNodWZmbGUiLCJqIiwieCIsImZsb29yIiwicmFuZG9tIiwidG9Qb2ludExpc3QiLCJyb3ciLCJyb3dzIiwiam9pbiIsInRocmVzaG9sZCIsInNjb3JlRnVuYyIsInF1ZXVlIiwiYXBwbHkiLCJtYXhJbmRleCIsIm1heCIsIkVBTlJlYWRlciIsIm9wdHMiLCJnZXREZWZhdWxDb25maWciLCJjYWxsIiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJkZWZhdWx0IiwicHJvcGVydGllcyIsIkNPREVfTF9TVEFSVCIsIkNPREVfR19TVEFSVCIsIlNUQVJUX1BBVFRFUk4iLCJTVE9QX1BBVFRFUk4iLCJNSURETEVfUEFUVEVSTiIsIkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOIiwiQ09ERV9QQVRURVJOIiwiQ09ERV9GUkVRVUVOQ1kiLCJBVkdfQ09ERV9FUlJPUiIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX2RlY29kZUNvZGUiLCJjb2RlcmFuZ2UiLCJfZmluZFBhdHRlcm4iLCJ0cnlIYXJkZXIiLCJfZmluZFN0YXJ0IiwibGVhZGluZ1doaXRlc3BhY2VTdGFydCIsInN0YXJ0SW5mbyIsIl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UiLCJlbmRJbmZvIiwidHJhaWxpbmdXaGl0ZXNwYWNlRW5kIiwiX2ZpbmRFbmQiLCJfY2FsY3VsYXRlRmlyc3REaWdpdCIsImNvZGVGcmVxdWVuY3kiLCJfZGVjb2RlUGF5bG9hZCIsImRlY29kZWRDb2RlcyIsImZpcnN0RGlnaXQiLCJ1bnNoaWZ0IiwicmVzdWx0SW5mbyIsIl9jaGVja3N1bSIsImV4dCIsIl9kZWNvZGVFeHRlbnNpb25zIiwibGFzdENvZGUiLCJzdXBwbGVtZW50IiwiY29kZXNldCIsImRlY29kZSIsImRyYXdSZWN0IiwicG9zIiwic2l6ZSIsImN0eCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJ5IiwiZHJhd1BhdGgiLCJwYXRoIiwiZGVmIiwibW92ZVRvIiwibGluZVRvIiwiY2xvc2VQYXRoIiwic3Ryb2tlIiwiZHJhd0ltYWdlIiwiaW1hZ2VEYXRhIiwiY2FudmFzRGF0YSIsImdldEltYWdlRGF0YSIsImRhdGEiLCJpbWFnZURhdGFQb3MiLCJjYW52YXNEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiaW1hZ2VSZWYiLCJjb21wdXRlSW50ZWdyYWxJbWFnZTIiLCJjb21wdXRlSW50ZWdyYWxJbWFnZSIsInRocmVzaG9sZEltYWdlIiwiY29tcHV0ZUhpc3RvZ3JhbSIsInNoYXJwZW5MaW5lIiwiZGV0ZXJtaW5lT3RzdVRocmVzaG9sZCIsIm90c3VUaHJlc2hvbGQiLCJjb21wdXRlQmluYXJ5SW1hZ2UiLCJjbHVzdGVyIiwiZGlsYXRlIiwiZXJvZGUiLCJzdWJ0cmFjdCIsImJpdHdpc2VPciIsImNvdW50Tm9uWmVybyIsInRvcEdlbmVyaWMiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjb21wdXRlR3JheSIsImxvYWRJbWFnZUFycmF5IiwiaGFsZlNhbXBsZSIsImhzdjJyZ2IiLCJfY29tcHV0ZURpdmlzb3JzIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiY29tcHV0ZUltYWdlQXJlYSIsInZlYzIiLCJjbG9uZSIsInJlcXVpcmUiLCJ2ZWMzIiwidGhhdCIsInRvVmVjMiIsInRvVmVjMyIsInJvdW5kIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwid2lkdGgiLCJoZWlnaHQiLCJpbnRlZ3JhbEltYWdlRGF0YSIsInBvc0EiLCJwb3NCIiwicG9zQyIsInBvc0QiLCJ2IiwidSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiYml0c1BlclBpeGVsIiwiYml0U2hpZnQiLCJidWNrZXRDbnQiLCJoaXN0IiwiSW50MzJBcnJheSIsImxlZnQiLCJjZW50ZXIiLCJyaWdodCIsInB4IiwibXgiLCJkZXRlcm1pbmVUaHJlc2hvbGQiLCJ2ZXQiLCJwMSIsInAyIiwicDEyIiwiayIsIm0xIiwibTIiLCJtMTIiLCJrZXJuZWwiLCJBIiwiQiIsIkMiLCJEIiwiYXZnIiwicG9pbnRzIiwicHJvcGVydHkiLCJwb2ludCIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwibmV3UG9pbnQiLCJmb3VuZCIsImZpdHMiLCJhZGQiLCJjcmVhdGVQb2ludCIsIlRyYWNlciIsInRyYWNlIiwidmVjIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwiZnJvbSIsInRvIiwidG9JZHgiLCJwcmVkaWN0ZWRQb3MiLCJ0aHJlc2hvbGRYIiwidGhyZXNob2xkWSIsIm1hdGNoIiwicHJlZGljdGVkIiwiRElMQVRFIiwiRVJPREUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImFJbWFnZVdyYXBwZXIiLCJiSW1hZ2VXcmFwcGVyIiwicmVzdWx0SW1hZ2VXcmFwcGVyIiwiYUltYWdlRGF0YSIsImJJbWFnZURhdGEiLCJjSW1hZ2VEYXRhIiwibGlzdCIsIm1pbklkeCIsIm1pbiIsInNjb3JlIiwiaGl0IiwiaXRlbSIsImh0bWxJbWFnZSIsIm9mZnNldFgiLCJhcnJheSIsImN0eERhdGEiLCJvdXRBcnJheSIsInRvcFJvd0lkeCIsImJvdHRvbVJvd0lkeCIsImVuZElkeCIsIm91dFdpZHRoIiwib3V0SW1nSWR4IiwiaW5XaWR0aCIsInNpbmdsZUNoYW5uZWwiLCJzcmMiLCJjYWxsYmFjayIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiZ2V0Q29udGV4dCIsIlVpbnQ4QXJyYXkiLCJpbkltZ1dyYXBwZXIiLCJvdXRJbWdXcmFwcGVyIiwiaW5JbWciLCJvdXRJbWciLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwibiIsImxhcmdlRGl2aXNvcnMiLCJkaXZpc29ycyIsInNxcnQiLCJjb25jYXQiLCJfY29tcHV0ZUludGVyc2VjdGlvbiIsImFycjEiLCJhcnIyIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJuck9mUGF0Y2hlc0lkeCIsIm1lZGl1bSIsIm5yT2ZQYXRjaGVzIiwiZGVzaXJlZFBhdGNoU2l6ZSIsIm9wdGltYWxQYXRjaFNpemUiLCJmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMiLCJkaW1lbnNpb24iLCJwYXJzZUZsb2F0IiwidW5pdCIsImluZGV4T2YiLCJfZGltZW5zaW9uc0NvbnZlcnRlcnMiLCJjb250ZXh0IiwiYm90dG9tIiwiaW5wdXRXaWR0aCIsImlucHV0SGVpZ2h0IiwiYXJlYSIsInBhcnNlZEFyZWEiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJJbWFnZVdyYXBwZXIiLCJBcnJheVR5cGUiLCJpbml0aWFsaXplIiwiQXJyYXkiLCJpbkltYWdlV2l0aEJvcmRlciIsImltZ1JlZiIsImJvcmRlciIsInNhbXBsZSIsImx4IiwibHkiLCJ3IiwiYmFzZSIsImEiLCJkIiwiZSIsImNsZWFyQXJyYXkiLCJzdWJJbWFnZSIsInN1YkltYWdlQXNDb3B5Iiwic2l6ZVkiLCJzaXplWCIsImNvcHlUbyIsInNyY0RhdGEiLCJkc3REYXRhIiwiZ2V0IiwiZ2V0U2FmZSIsImluZGV4TWFwcGluZyIsInNldCIsInplcm9Cb3JkZXIiLCJpbnZlcnQiLCJjb252b2x2ZSIsImt4Iiwia3kiLCJrU2l6ZSIsImFjY3UiLCJtb21lbnRzIiwibGFiZWxjb3VudCIsInlzcSIsImxhYmVsc3VtIiwibGFiZWwiLCJtdTExIiwibXUwMiIsIm11MjAiLCJ4XyIsInlfIiwiUEkiLCJQSV80IiwibTAwIiwibTAxIiwibTEwIiwibTExIiwibTAyIiwibTIwIiwidGhldGEiLCJyYWQiLCJpc05hTiIsImF0YW4iLCJjb3MiLCJzaW4iLCJzaG93Iiwic2NhbGUiLCJmcmFtZSIsImN1cnJlbnQiLCJwaXhlbCIsIm92ZXJsYXkiLCJ3aGl0ZVJnYiIsImJsYWNrUmdiIiwic2VhcmNoRGlyZWN0aW9ucyIsImxhYmVsV3JhcHBlciIsImxhYmVsRGF0YSIsImVkZ2VsYWJlbCIsImN5IiwiZGlyIiwiY3giLCJ2ZXJ0ZXgyRCIsIm5leHQiLCJwcmV2IiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJDb2RlMzlSZWFkZXIiLCJBTFBIQUJFVEhfU1RSSU5HIiwiQUxQSEFCRVQiLCJDSEFSQUNURVJfRU5DT0RJTkdTIiwiQVNURVJJU0siLCJkZWNvZGVkQ2hhciIsImxhc3RTdGFydCIsIm5leHRTdGFydCIsIl90b1BhdHRlcm4iLCJfcGF0dGVyblRvQ2hhciIsInBvcCIsInBhdHRlcm5TaXplIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiX2ZpbmROZXh0V2lkdGgiLCJtaW5XaWR0aCIsIm1heE5hcnJvd1dpZHRoIiwibnVtV2lkZUJhcnMiLCJ3aWRlQmFyV2lkdGgiLCJwYXR0ZXJuU3RhcnQiLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwiX2lucHV0U3RyZWFtIiwiX2ZyYW1lZ3JhYmJlciIsIl9zdG9wcGVkIiwiX2NhbnZhc0NvbnRhaW5lciIsImltYWdlIiwiZG9tIiwiX2lucHV0SW1hZ2VXcmFwcGVyIiwiX2JveFNpemUiLCJfZGVjb2RlciIsIl93b3JrZXJQb29sIiwiX29uVUlUaHJlYWQiLCJfcmVzdWx0Q29sbGVjdG9yIiwiX2NvbmZpZyIsImluaXRpYWxpemVEYXRhIiwiaW5pdEJ1ZmZlcnMiLCJkZWNvZGVyIiwiaW5pdElucHV0U3RyZWFtIiwiY2IiLCJ2aWRlbyIsImlucHV0U3RyZWFtIiwidHlwZSIsImNyZWF0ZVZpZGVvU3RyZWFtIiwiY3JlYXRlSW1hZ2VTdHJlYW0iLCIkdmlld3BvcnQiLCJnZXRWaWV3UG9ydCIsInF1ZXJ5U2VsZWN0b3IiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZUxpdmVTdHJlYW0iLCJyZXF1ZXN0IiwiY29uc3RyYWludHMiLCJ0aGVuIiwidHJpZ2dlciIsImNhdGNoIiwiZXJyIiwic2V0QXR0cmlidXRlIiwic2V0SW5wdXRTdHJlYW0iLCJhZGRFdmVudExpc3RlbmVyIiwiY2FuUmVjb3JkIiwiYmluZCIsInRhcmdldCIsIm5vZGVOYW1lIiwibm9kZVR5cGUiLCJzZWxlY3RvciIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImxvY2F0b3IiLCJpbml0Q2FudmFzIiwiYWRqdXN0V29ya2VyUG9vbCIsIm51bU9mV29ya2VycyIsInJlYWR5IiwicGxheSIsImNsYXNzTmFtZSIsImdldENhbnZhc1NpemUiLCJjbGVhckZpeCIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiY29uc29sZSIsImxvZyIsImdldEJvdW5kaW5nQm94ZXMiLCJsb2NhdGUiLCJ0cmFuc2Zvcm1SZXN1bHQiLCJ0b3BSaWdodCIsImdldFRvcFJpZ2h0IiwieE9mZnNldCIsInlPZmZzZXQiLCJiYXJjb2RlcyIsIm1vdmVMaW5lIiwiYm94IiwibW92ZUJveCIsImJveGVzIiwiY29ybmVyIiwiYWRkUmVzdWx0IiwiZmlsdGVyIiwiYmFyY29kZSIsImNvZGVSZXN1bHQiLCJoYXNDb2RlUmVzdWx0Iiwic29tZSIsInB1Ymxpc2hSZXN1bHQiLCJyZXN1bHRUb1B1Ymxpc2giLCJwdWJsaXNoIiwibG9jYXRlQW5kRGVjb2RlIiwiZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMiLCJ1cGRhdGUiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5IiwiYXR0YWNoRGF0YSIsImdyYWIiLCJ3b3JrZXIiLCJwb3N0TWVzc2FnZSIsImNtZCIsImJ1ZmZlciIsInN0YXJ0Q29udGludW91c1VwZGF0ZSIsImRlbGF5IiwiZnJlcXVlbmN5IiwidGltZXN0YW1wIiwid2luZG93IiwicmVxdWVzdEFuaW1GcmFtZSIsInBlcmZvcm1hbmNlIiwibm93IiwiaW5pdFdvcmtlciIsImJsb2JVUkwiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJXb3JrZXIiLCJvbm1lc3NhZ2UiLCJldmVudCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsIm1lc3NhZ2UiLCJjb25maWdGb3JXb3JrZXIiLCJ3b3JrZXJJbnRlcmZhY2UiLCJmYWN0b3J5IiwiUXVhZ2dhIiwib25Qcm9jZXNzZWQiLCJzZXRSZWFkZXJzIiwicmVhZGVycyIsImJsb2IiLCJmYWN0b3J5U291cmNlIiwiX19mYWN0b3J5U291cmNlX18iLCJCbG9iIiwidG9TdHJpbmciLCJjcmVhdGVPYmplY3RVUkwiLCJjYXBhY2l0eSIsImluY3JlYXNlQnkiLCJ3b3JrZXJzVG9UZXJtaW5hdGUiLCJzbGljZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic3RvcCIsInJlbGVhc2UiLCJjbGVhckV2ZW50SGFuZGxlcnMiLCJwYXVzZSIsIm9uRGV0ZWN0ZWQiLCJzdWJzY3JpYmUiLCJvZmZEZXRlY3RlZCIsInVuc3Vic2NyaWJlIiwib2ZmUHJvY2Vzc2VkIiwicmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3IiLCJyZXN1bHRDb2xsZWN0b3IiLCJkZWNvZGVTaW5nbGUiLCJyZXN1bHRDYWxsYmFjayIsInNlcXVlbmNlIiwib25jZSIsIkltYWdlRGVidWciLCJSZXN1bHRDb2xsZWN0b3IiLCJDYW1lcmFBY2Nlc3MiLCJDVlV0aWxzIiwiTmRhcnJheSIsIkludGVycDJEIiwiZDIiLCJGcmFtZUdyYWJiZXIiLCJfdGhhdCIsIl9zdHJlYW1Db25maWciLCJnZXRDb25maWciLCJfdmlkZW9fc2l6ZSIsImdldFJlYWxXaWR0aCIsImdldFJlYWxIZWlnaHQiLCJfY2FudmFzU2l6ZSIsIl9zaXplIiwiX3RvcFJpZ2h0IiwiX2RhdGEiLCJfZ3JheURhdGEiLCJfY2FudmFzRGF0YSIsIl9ncmF5SW1hZ2VBcnJheSIsInRyYW5zcG9zZSIsIl9jYW52YXNJbWFnZUFycmF5IiwiX3RhcmdldEltYWdlQXJyYXkiLCJoaSIsImxvIiwiX3N0ZXBTaXplWCIsIl9zdGVwU2l6ZVkiLCJKU09OIiwic3RyaW5naWZ5IiwidmlkZW9TaXplIiwic2hhcGUiLCJjYW52YXNTaXplIiwic3RlcFNpemUiLCJnZXREYXRhIiwiZ2V0RnJhbWUiLCJzY2FsZUFuZENyb3AiLCJFcnJvciIsImdldFNpemUiLCJtb2R1bGUiLCJleHBvcnRzIiwiR2V0UGl4ZWxzIiwiSW5wdXRTdHJlYW0iLCJmcmFtZUlkeCIsInBhdXNlZCIsImxvYWRlZCIsImJhc2VVcmwiLCJlbmRlZCIsImNhbGN1bGF0ZWRXaWR0aCIsImNhbGN1bGF0ZWRIZWlnaHQiLCJfZXZlbnROYW1lcyIsIl9ldmVudEhhbmRsZXJzIiwibG9hZEltYWdlcyIsIm1pbWUiLCJwaXhlbHMiLCJleGl0Iiwic2V0VGltZW91dCIsInB1Ymxpc2hFdmVudCIsImV2ZW50TmFtZSIsImFyZ3MiLCJoYW5kbGVycyIsInNldFdpZHRoIiwic2V0SGVpZ2h0Iiwic3RyZWFtIiwic2V0Q3VycmVudFRpbWUiLCJ0aW1lIiwiZiIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImNvbnRhaW5zIiwiZXZlcnkiLCJwYXNzZXNGaWx0ZXIiLCJyZXN1bHRzIiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJkb3QiLCJwb2ludE1hcCIsInVwZGF0ZUNlbnRlciIsInBvaW50VG9BZGQiLCJpZCIsIm90aGVyUG9pbnQiLCJzaW1pbGFyaXR5IiwiZ2V0UG9pbnRzIiwiZ2V0Q2VudGVyIiwiZXZlbnRzIiwiZ2V0RXZlbnQiLCJzdWJzY3JpYmVycyIsImNsZWFyRXZlbnRzIiwicHVibGlzaFN1YnNjcmlwdGlvbiIsInN1YnNjcmlwdGlvbiIsImFzeW5jIiwic3Vic2NyaWJlciIsImVudW1lcmF0ZURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJQcm9taXNlIiwicmVqZWN0IiwiU3ViSW1hZ2UiLCJJIiwib3JpZ2luYWxTaXplIiwidXBkYXRlRGF0YSIsInVwZGF0ZUZyb20iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpbXVsIiwiYWgiLCJhbCIsImJoIiwiYmwiLCJhc3NpZ24iLCJUeXBlRXJyb3IiLCJpbmRleCIsImFyZ3VtZW50cyIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiaGFzT3duUHJvcGVydHkiLCJSRUFERVJTIiwiY29kZV8xMjhfcmVhZGVyIiwiZWFuX3JlYWRlciIsImVhbl81X3JlYWRlciIsImVhbl8yX3JlYWRlciIsImVhbl84X3JlYWRlciIsImNvZGVfMzlfcmVhZGVyIiwiY29kZV8zOV92aW5fcmVhZGVyIiwiY29kYWJhcl9yZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJxcl9jb2RlX3JlYWRlciIsImlucHV0SW1hZ2VXcmFwcGVyIiwiX2NhbnZhcyIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlckNvbmZpZyIsInJlYWRlciIsImNvbmZpZ3VyYXRpb24iLCJtYXAiLCJ2aXMiLCJub2RlIiwicHJvcCIsImRlYnVnIiwic2hvd0ZyZXF1ZW5jeSIsInNob3dQYXR0ZXJuIiwiZGlzcGxheSIsImdldEV4dGVuZGVkTGluZSIsImFuZ2xlIiwiZXh0ZW5kTGluZSIsImFtb3VudCIsImV4dGVuc2lvbiIsImNlaWwiLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJnZXRCYXJjb2RlTGluZSIsInByaW50RnJlcXVlbmN5IiwidG9CaW5hcnlMaW5lIiwicHJpbnRQYXR0ZXJuIiwidHJ5RGVjb2RlQnJ1dGVGb3JjZSIsImxpbmVBbmdsZSIsInNpZGVMZW5ndGgiLCJwb3ciLCJzbGljZXMiLCJ4ZGlyIiwieWRpciIsImdldExpbmVMZW5ndGgiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiZHJhd0JvdW5kaW5nQm94IiwiYXRhbjIiLCJtdWx0aXBsZSIsIkJyZXNlbmhhbSIsIlNsb3BlIiwiRElSIiwiVVAiLCJET1dOIiwieDAiLCJ5MCIsIngxIiwieTEiLCJzdGVlcCIsImRlbHRheCIsImRlbHRheSIsInlzdGVwIiwicmVhZCIsInNsb3BlIiwic2xvcGUyIiwiZXh0cmVtYSIsImN1cnJlbnREaXIiLCJyVGhyZXNob2xkIiwiZmlsbENvbG9yIiwiZmlsbFJlY3QiLCJwaWNrQ29uc3RyYWludHMiLCJmYWNpbmdNYXRjaGluZyIsInN0cmVhbVJlZiIsIndhaXRGb3JWaWRlbyIsInJlc29sdmUiLCJhdHRlbXB0cyIsImNoZWNrVmlkZW8iLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJpbml0Q2FtZXJhIiwic3JjT2JqZWN0IiwiZGVwcmVjYXRlZENvbnN0cmFpbnRzIiwidmlkZW9Db25zdHJhaW50cyIsIm5vcm1hbGl6ZWQiLCJtaW5Bc3BlY3RSYXRpbyIsImFzcGVjdFJhdGlvIiwiZmFjaW5nIiwiZmFjaW5nTW9kZSIsIm5vcm1hbGl6ZWRDb25zdHJhaW50cyIsImF1ZGlvIiwiZGV2aWNlSWQiLCJlbnVtZXJhdGVWaWRlb0RldmljZXMiLCJkZXZpY2VzIiwiZGV2aWNlIiwia2luZCIsImdldEFjdGl2ZVRyYWNrIiwidHJhY2tzIiwiZ2V0VmlkZW9UcmFja3MiLCJnZXRBY3RpdmVTdHJlYW1MYWJlbCIsInRyYWNrIiwiZ2xvYmFsIiwiUXJDb2RlIiwiRXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJvcmRpbmFsIiwiYml0cyIsIm5hbWUiLCJvcmRpbmFsX1JlbmFtZWRfRmllbGQiLCJmb3JCaXRzIiwiRk9SX0JJVFMiLCJGT1JNQVRfSU5GT19NQVNLX1FSIiwiRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCIsIkJJVFNfU0VUX0lOX0hBTEZfQllURSIsIkZvcm1hdEluZm9ybWF0aW9uIiwiZm9ybWF0SW5mbyIsImVycm9yQ29ycmVjdGlvbkxldmVsIiwiZGF0YU1hc2siLCJHZXRIYXNoQ29kZSIsIkVxdWFscyIsIm8iLCJvdGhlciIsIm51bUJpdHNEaWZmZXJpbmciLCJVUlNoaWZ0IiwiZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24iLCJtYXNrZWRGb3JtYXRJbmZvIiwiZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbiIsImJlc3REaWZmZXJlbmNlIiwiYmVzdEZvcm1hdEluZm8iLCJkZWNvZGVJbmZvIiwidGFyZ2V0SW5mbyIsImJpdHNEaWZmZXJlbmNlIiwiQml0TWF0cml4Iiwicm93U2l6ZSIsImdldF9SZW5hbWVkIiwic2V0X1JlbmFtZWQiLCJmbGlwIiwiY2xlYXIiLCJzZXRSZWdpb24iLCJFQ0IiLCJkYXRhQ29kZXdvcmRzIiwiRUNCbG9ja3MiLCJlY0NvZGV3b3Jkc1BlckJsb2NrIiwiZWNCbG9ja3MxIiwiZWNCbG9ja3MyIiwiZWNCbG9ja3MiLCJOdW1CbG9ja3MiLCJ0b3RhbCIsImdldEVDQmxvY2tzIiwiVmVyc2lvbiIsInZlcnNpb25OdW1iZXIiLCJhbGlnbm1lbnRQYXR0ZXJuQ2VudGVycyIsImVjQmxvY2tzMyIsImVjQmxvY2tzNCIsImVjQ29kZXdvcmRzIiwiZWNiQXJyYXkiLCJlY0Jsb2NrIiwidG90YWxDb2Rld29yZHMiLCJidWlsZEZ1bmN0aW9uUGF0dGVybiIsIkRpbWVuc2lvbkZvclZlcnNpb24iLCJiaXRNYXRyaXgiLCJnZXRFQ0Jsb2Nrc0ZvckxldmVsIiwiZWNMZXZlbCIsIlZFUlNJT05fREVDT0RFX0lORk8iLCJWRVJTSU9OUyIsImJ1aWxkVmVyc2lvbnMiLCJnZXRWZXJzaW9uRm9yTnVtYmVyIiwiZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uIiwiaWFlIiwiZGVjb2RlVmVyc2lvbkluZm9ybWF0aW9uIiwidmVyc2lvbkJpdHMiLCJiZXN0VmVyc2lvbiIsInRhcmdldFZlcnNpb24iLCJBbGlnbm1lbnRQYXR0ZXJuIiwicG9zWCIsInBvc1kiLCJlc3RpbWF0ZWRNb2R1bGVTaXplIiwiaW5jcmVtZW50Q291bnQiLCJhYm91dEVxdWFscyIsIm1vZHVsZVNpemUiLCJtb2R1bGVTaXplRGlmZiIsIkFsaWdubWVudFBhdHRlcm5GaW5kZXIiLCJzdGFydFgiLCJzdGFydFkiLCJyZXN1bHRQb2ludENhbGxiYWNrIiwicG9zc2libGVDZW50ZXJzIiwiY3Jvc3NDaGVja1N0YXRlQ291bnQiLCJjZW50ZXJGcm9tRW5kIiwic3RhdGVDb3VudCIsImZvdW5kUGF0dGVybkNyb3NzIiwibWF4VmFyaWFuY2UiLCJjcm9zc0NoZWNrVmVydGljYWwiLCJzdGFydEkiLCJjZW50ZXJKIiwibWF4Q291bnQiLCJvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCIsIm1heEkiLCJOYU4iLCJzdGF0ZUNvdW50VG90YWwiLCJoYW5kbGVQb3NzaWJsZUNlbnRlciIsImNlbnRlckkiLCJmb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQiLCJmaW5kIiwibWF4SiIsIm1pZGRsZUkiLCJpR2VuIiwiY3VycmVudFN0YXRlIiwiY29uZmlybWVkIiwiR3JpZFNhbXBsZXIiLCJjaGVja0FuZE51ZGdlUG9pbnRzIiwibnVkZ2VkIiwic2FtcGxlR3JpZDMiLCJ0cmFuc2Zvcm0iLCJpVmFsdWUiLCJ0cmFuc2Zvcm1Qb2ludHMxIiwiYml0IiwiYWlvb2JlIiwiTUlOX1NLSVAiLCJNQVhfTU9EVUxFUyIsIklOVEVHRVJfTUFUSF9TSElGVCIsIkNFTlRFUl9RVU9SVU0iLCJvcmRlckJlc3RQYXR0ZXJucyIsInBhdHRlcm5zIiwiZGlzdGFuY2UiLCJwYXR0ZXJuMSIsInBhdHRlcm4yIiwieERpZmYiLCJYIiwieURpZmYiLCJZIiwiY3Jvc3NQcm9kdWN0WiIsInBvaW50QSIsInBvaW50QiIsInBvaW50QyIsImJYIiwiYlkiLCJ6ZXJvT25lRGlzdGFuY2UiLCJvbmVUd29EaXN0YW5jZSIsInplcm9Ud29EaXN0YW5jZSIsInRlbXAiLCJGaW5kZXJQYXR0ZXJuIiwiRmluZGVyUGF0dGVybkluZm8iLCJwYXR0ZXJuQ2VudGVycyIsImJvdHRvbUxlZnQiLCJ0b3BMZWZ0IiwiRmluZGVyUGF0dGVybkZpbmRlciIsImhhc1NraXBwZWQiLCJ0b3RhbE1vZHVsZVNpemUiLCJDcm9zc0NoZWNrU3RhdGVDb3VudCIsImNyb3NzQ2hlY2tIb3Jpem9udGFsIiwic3RhcnRKIiwic2VsZWN0QmVzdFBhdHRlcm5zIiwic3RhcnRTaXplIiwic3F1YXJlIiwiY2VudGVyVmFsdWUiLCJhdmVyYWdlIiwic29ydCIsImNlbnRlcjEiLCJjZW50ZXIyIiwiZEEiLCJkQiIsInN0ZERldiIsImxpbWl0Iiwic3BsaWNlIiwiZmluZFJvd1NraXAiLCJmaXJzdENvbmZpcm1lZENlbnRlciIsImhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMiLCJjb25maXJtZWRDb3VudCIsInRvdGFsRGV2aWF0aW9uIiwiZmluZEZpbmRlclBhdHRlcm4iLCJpU2tpcCIsImRvbmUiLCJyb3dTa2lwIiwicGF0dGVybkluZm8iLCJQZXJzcGVjdGl2ZVRyYW5zZm9ybSIsImExMSIsImEyMSIsImEzMSIsImExMiIsImEyMiIsImEzMiIsImExMyIsImEyMyIsImEzMyIsImRlbm9taW5hdG9yIiwidHJhbnNmb3JtUG9pbnRzMiIsInhWYWx1ZXMiLCJ5VmFsdWVzIiwiYnVpbGRBZGpvaW50IiwidGltZXMiLCJxdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ4MHAiLCJ5MHAiLCJ4MXAiLCJ5MXAiLCJ4MnAiLCJ5MnAiLCJ4M3AiLCJ5M3AiLCJxVG9TIiwicXVhZHJpbGF0ZXJhbFRvU3F1YXJlIiwic1RvUSIsInNxdWFyZVRvUXVhZHJpbGF0ZXJhbCIsImR5MiIsImR5MyIsImR4MSIsImR4MiIsImR4MyIsImR5MSIsIkRldGVjdG9yUmVzdWx0IiwiRGV0ZWN0b3IiLCJzaXplT2ZCbGFja1doaXRlQmxhY2tSdW4iLCJmcm9tWCIsImZyb21ZIiwidG9YIiwidG9ZIiwiZHgiLCJkeSIsInhzdGVwIiwic3RhdGUiLCJyZWFsWCIsInJlYWxZIiwiZGlmZlgiLCJkaWZmWSIsImRpZmZYMiIsImRpZmZZMiIsInNpemVPZkJsYWNrV2hpdGVCbGFja1J1bkJvdGhXYXlzIiwib3RoZXJUb1giLCJvdGhlclRvWSIsImNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkiLCJvdGhlclBhdHRlcm4iLCJtb2R1bGVTaXplRXN0MSIsIm1vZHVsZVNpemVFc3QyIiwiY2FsY3VsYXRlTW9kdWxlU2l6ZSIsImNvbXB1dGVEaW1lbnNpb24iLCJ0bHRyQ2VudGVyc0RpbWVuc2lvbiIsInRsYmxDZW50ZXJzRGltZW5zaW9uIiwiZmluZEFsaWdubWVudEluUmVnaW9uIiwib3ZlcmFsbEVzdE1vZHVsZVNpemUiLCJlc3RBbGlnbm1lbnRYIiwiZXN0QWxpZ25tZW50WSIsImFsbG93YW5jZUZhY3RvciIsImFsbG93YW5jZSIsImFsaWdubWVudEFyZWFMZWZ0WCIsImFsaWdubWVudEFyZWFSaWdodFgiLCJhbGlnbm1lbnRBcmVhVG9wWSIsImFsaWdubWVudEFyZWFCb3R0b21ZIiwiYWxpZ25tZW50RmluZGVyIiwiY3JlYXRlVHJhbnNmb3JtIiwiYWxpZ25tZW50UGF0dGVybiIsImRpbU1pbnVzVGhyZWUiLCJib3R0b21SaWdodFgiLCJib3R0b21SaWdodFkiLCJzb3VyY2VCb3R0b21SaWdodFgiLCJzb3VyY2VCb3R0b21SaWdodFkiLCJzYW1wbGVHcmlkIiwic2FtcGxlciIsInByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyIsImluZm8iLCJwcm92aXNpb25hbFZlcnNpb24iLCJtb2R1bGVzQmV0d2VlbkZQQ2VudGVycyIsImNvcnJlY3Rpb25Ub1RvcExlZnQiLCJkZXRlY3QiLCJHRjI1NlBvbHkiLCJmaWVsZCIsImNvZWZmaWNpZW50cyIsImNvZWZmaWNpZW50c0xlbmd0aCIsImZpcnN0Tm9uWmVybyIsIlplcm8iLCJjaSIsImdldENvZWZmaWNpZW50IiwiZGVncmVlIiwiZXZhbHVhdGVBdCIsImFkZE9yU3VidHJhY3QiLCJyZXN1bHQyIiwibXVsdGlwbHkiLCJzbWFsbGVyQ29lZmZpY2llbnRzIiwibGFyZ2VyQ29lZmZpY2llbnRzIiwic3VtRGlmZiIsImxlbmd0aERpZmYiLCJtdWx0aXBseTEiLCJhQ29lZmZpY2llbnRzIiwiYUxlbmd0aCIsImJDb2VmZmljaWVudHMiLCJiTGVuZ3RoIiwicHJvZHVjdCIsImFDb2VmZiIsIm11bHRpcGx5MiIsInNjYWxhciIsIm11bHRpcGx5QnlNb25vbWlhbCIsImNvZWZmaWNpZW50IiwiZGl2aWRlIiwicXVvdGllbnQiLCJyZW1haW5kZXIiLCJkZW5vbWluYXRvckxlYWRpbmdUZXJtIiwiRGVncmVlIiwiaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0iLCJpbnZlcnNlIiwiZGVncmVlRGlmZmVyZW5jZSIsInRlcm0iLCJpdGVyYXRpb25RdW90aWVudCIsImJ1aWxkTW9ub21pYWwiLCJHRjI1NiIsInByaW1pdGl2ZSIsImV4cFRhYmxlIiwibG9nVGFibGUiLCJhdDAiLCJ6ZXJvIiwiYXQxIiwib25lIiwiZXhwIiwiUVJfQ09ERV9GSUVMRCIsIkRBVEFfTUFUUklYX0ZJRUxEIiwiUmVlZFNvbG9tb25EZWNvZGVyIiwicmVjZWl2ZWQiLCJ0d29TIiwicG9seSIsInN5bmRyb21lQ29lZmZpY2llbnRzIiwiZGF0YU1hdHJpeCIsIm5vRXJyb3IiLCJfZXZhbCIsInN5bmRyb21lIiwic2lnbWFPbWVnYSIsInJ1bkV1Y2xpZGVhbkFsZ29yaXRobSIsInNpZ21hIiwib21lZ2EiLCJlcnJvckxvY2F0aW9ucyIsImZpbmRFcnJvckxvY2F0aW9ucyIsImVycm9yTWFnbml0dWRlcyIsImZpbmRFcnJvck1hZ25pdHVkZXMiLCJwb3NpdGlvbiIsIlIiLCJyTGFzdCIsInNMYXN0IiwiT25lIiwidExhc3QiLCJ0Iiwickxhc3RMYXN0Iiwic0xhc3RMYXN0IiwidExhc3RMYXN0IiwicSIsImRsdEludmVyc2UiLCJkZWdyZWVEaWZmIiwic2lnbWFUaWxkZUF0WmVybyIsImVycm9yTG9jYXRvciIsIm51bUVycm9ycyIsImVycm9yRXZhbHVhdG9yIiwieGlJbnZlcnNlIiwiRGF0YU1hc2siLCJmb3JSZWZlcmVuY2UiLCJyZWZlcmVuY2UiLCJEQVRBX01BU0tTIiwiRGF0YU1hc2swMDAiLCJ1bm1hc2tCaXRNYXRyaXgiLCJpc01hc2tlZCIsIkRhdGFNYXNrMDAxIiwiRGF0YU1hc2swMTAiLCJEYXRhTWFzazAxMSIsIkRhdGFNYXNrMTAwIiwiRGF0YU1hc2sxMDEiLCJEYXRhTWFzazExMCIsIkRhdGFNYXNrMTExIiwiQml0TWF0cml4UGFyc2VyIiwiRGltZW5zaW9uIiwicGFyc2VkVmVyc2lvbiIsInBhcnNlZEZvcm1hdEluZm8iLCJjb3B5Qml0IiwicmVhZEZvcm1hdEluZm9ybWF0aW9uIiwiZm9ybWF0SW5mb0JpdHMiLCJpTWluIiwicmVhZFZlcnNpb24iLCJpak1pbiIsInJlYWRDb2Rld29yZHMiLCJ2ZXJzaW9uIiwiZnVuY3Rpb25QYXR0ZXJuIiwicmVhZGluZ1VwIiwicmVzdWx0T2Zmc2V0IiwiY3VycmVudEJ5dGUiLCJiaXRzUmVhZCIsImNvbCIsIkRhdGFCbG9jayIsIm51bURhdGFDb2Rld29yZHMiLCJjb2Rld29yZHMiLCJnZXREYXRhQmxvY2tzIiwicmF3Q29kZXdvcmRzIiwidG90YWxCbG9ja3MiLCJlY0Jsb2NrQXJyYXkiLCJudW1SZXN1bHRCbG9ja3MiLCJudW1CbG9ja0NvZGV3b3JkcyIsInNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyIsImxvbmdlckJsb2Nrc1N0YXJ0QXQiLCJudW1Db2Rld29yZHMiLCJzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyIsInJhd0NvZGV3b3Jkc09mZnNldCIsImlPZmZzZXQiLCJRUkNvZGVEYXRhQmxvY2tSZWFkZXIiLCJibG9ja3MiLCJudW1FcnJvckNvcnJlY3Rpb25Db2RlIiwiYmxvY2tQb2ludGVyIiwiYml0UG9pbnRlciIsImRhdGFMZW5ndGgiLCJkYXRhTGVuZ3RoTW9kZSIsImdldE5leHRCaXRzIiwibnVtQml0cyIsIm1hc2siLCJtYXNrMSIsIm1hc2szIiwiYml0c0ZpcnN0QmxvY2siLCJiaXRzU2Vjb25kQmxvY2siLCJiaXRzVGhpcmRCbG9jayIsIk5leHRNb2RlIiwiZ2V0RGF0YUxlbmd0aCIsIm1vZGVJbmRpY2F0b3IiLCJxcmNvZGUiLCJzaXplT2ZEYXRhTGVuZ3RoSW5mbyIsImdldFJvbWFuQW5kRmlndXJlU3RyaW5nIiwiaW50RGF0YSIsInN0ckRhdGEiLCJ0YWJsZVJvbWFuQW5kRmlndXJlIiwiZmlyc3RMZXR0ZXIiLCJzZWNvbmRMZXR0ZXIiLCJnZXRGaWd1cmVTdHJpbmciLCJnZXQ4Yml0Qnl0ZUFycmF5Iiwib3V0cHV0IiwiZ2V0S2FuamlTdHJpbmciLCJ1bmljb2RlU3RyaW5nIiwibG93ZXJCeXRlIiwiaGlnaGVyQnl0ZSIsInRlbXBXb3JkIiwic2hpZnRqaXNXb3JkIiwiTU9ERV9OVU1CRVIiLCJNT0RFX1JPTUFOX0FORF9OVU1CRVIiLCJNT0RFXzhCSVRfQllURSIsIk1PREVfS0FOSkkiLCJtb2RlIiwidGVtcF9zdHIiLCJ0YSIsImNoYXJDb2RlQXQiLCJ0ZW1wX3NieXRlQXJyYXkzIiwiRGVjb2RlciIsInJzRGVjb2RlciIsImNvcnJlY3RFcnJvcnMiLCJjb2Rld29yZEJ5dGVzIiwiY29kZXdvcmRzSW50cyIsIm51bUVDQ29kZXdvcmRzIiwicnNlIiwicGFyc2VyIiwiZGF0YUJsb2NrcyIsInRvdGFsQnl0ZXMiLCJyZXN1bHRCeXRlcyIsImRhdGFCbG9jayIsIlFyQ29kZSQxIiwiaW1hZ2VkYXRhIiwicXJDb2RlU3ltYm9sIiwicHJvY2VzcyIsImNyb3NzT3JpZ2luIiwiY2FudmFzX3FyIiwiY2FudmFzX291dCIsImdldEVsZW1lbnRCeUlkIiwib3V0Y3R4IiwiY2xlYXJSZWN0IiwiZGVjb2RlX3V0ZjgiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJEYXRlIiwiZ2V0VGltZSIsImdyYXlTY2FsZVRvQml0bWFwIiwiZGV0ZWN0b3IiLCJxUkNvZGVNYXRyaXgiLCJEYXRhQnl0ZSIsInN0ciIsImdldFBpeGVsIiwiYmluYXJpemUiLCJ0aCIsInJldCIsImdyYXkiLCJnZXRNaWRkbGVCcmlnaHRuZXNzUGVyQXJlYSIsIm51bVNxcnRBcmVhIiwiYXJlYVdpZHRoIiwiYXJlYUhlaWdodCIsIm1pbm1heCIsImkyIiwiYXkiLCJheCIsIm1pZGRsZSIsImkzIiwiZ3JheVNjYWxlSW1hZ2VEYXRhIiwic3FydE51bUFyZWEiLCJncmF5c2NhbGUiLCJudW1iZXIiLCJ0cmFuc2Zvcm1NYXQyIiwibWF0MiIsImNvcHkiLCJfY3VycmVudEltYWdlV3JhcHBlciIsIl9za2VsSW1hZ2VXcmFwcGVyIiwiX3N1YkltYWdlV3JhcHBlciIsIl9sYWJlbEltYWdlV3JhcHBlciIsIl9wYXRjaEdyaWQiLCJfcGF0Y2hMYWJlbEdyaWQiLCJfaW1hZ2VUb1BhdGNoR3JpZCIsIl9iaW5hcnlJbWFnZVdyYXBwZXIiLCJfcGF0Y2hTaXplIiwiYmluYXJ5IiwiX251bVBhdGNoZXMiLCJfc2tlbGV0b25pemVyIiwic2tlbGV0b25JbWFnZURhdGEiLCJBcnJheUJ1ZmZlciIsInVzZVdvcmtlciIsImJveEZyb21QYXRjaGVzIiwicGF0Y2hlcyIsIm92ZXJBdmciLCJwYXRjaCIsInRyYW5zTWF0IiwibWlueCIsIm1pbnkiLCJtYXh4IiwibWF4eSIsImJpbmFyaXplSW1hZ2UiLCJmaW5kUGF0Y2hlcyIsInBhdGNoZXNGb3VuZCIsInJhc3Rlcml6ZXIiLCJyYXN0ZXJSZXN1bHQiLCJza2VsZXRvbml6ZSIsInJhc3Rlcml6ZSIsImRlc2NyaWJlUGF0Y2giLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJlbCIsImZpbmRCb3hlcyIsInNpbWlsYXJNb21lbnRzIiwidG9wQ2x1c3RlciIsInBhdGNoUG9zIiwiZWxpZ2libGVNb21lbnRzIiwibWF0Y2hpbmdNb21lbnRzIiwibWluQ29tcG9uZW50V2VpZ2h0IiwicmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkiLCJjdXJySWR4Iiwibm90WWV0UHJvY2Vzc2VkIiwiY3VycmVudElkeCIsImN1cnJlbnRQYXRjaCIsIlJhc3Rlcml6ZXIiLCJjcmVhdGVDb250b3VyMkQiLCJmaXJzdFZlcnRleCIsImluc2lkZUNvbnRvdXJzIiwibmV4dHBlZXIiLCJwcmV2cGVlciIsIkNPTlRPVVJfRElSIiwiQ1dfRElSIiwiQ0NXX0RJUiIsIlVOS05PV05fRElSIiwiT1VUU0lERV9FREdFIiwiSU5TSURFX0VER0UiLCJ0cmFjZXIiLCJkZXB0aGxhYmVsIiwiYmMiLCJsYyIsImxhYmVsaW5kZXgiLCJjb2xvck1hcCIsInZlcnRleCIsInAiLCJjYyIsInNjIiwiY29ubmVjdGVkQ291bnQiLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJTa2VsZXRvbml6ZXIiLCJzdGRsaWIiLCJmb3JlaWduIiwiaW1hZ2VzIiwiaW5JbWFnZVB0ciIsIm91dEltYWdlUHRyIiwiYUltYWdlUHRyIiwiYkltYWdlUHRyIiwiaW1hZ2VQdHIiLCJtZW1jcHkiLCJzcmNJbWFnZVB0ciIsImRzdEltYWdlUHRyIiwic3ViSW1hZ2VQdHIiLCJlcm9kZWRJbWFnZVB0ciIsInRlbXBJbWFnZVB0ciIsInNrZWxJbWFnZVB0ciIsIlR3b09mRml2ZVJlYWRlciIsImJhclNwYWNlUmF0aW8iLCJOIiwiVyIsIndyaXRhYmxlIiwic3RhcnRQYXR0ZXJuTGVuZ3RoIiwibmFycm93QmFyV2lkdGgiLCJjb3VudGVyTGVuZ3RoIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJDb2RhYmFyUmVhZGVyIiwiX2NvdW50ZXJzIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJzdGFydENvdW50ZXIiLCJfaXNTdGFydEVuZCIsIl92ZXJpZnlXaGl0ZXNwYWNlIiwiX3ZhbGlkYXRlUmVzdWx0IiwiX3N1bUNvdW50ZXJzIiwiZW5kQ291bnRlciIsIl9jYWxjdWxhdGVQYXR0ZXJuTGVuZ3RoIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJjYXRlZ29yaXphdGlvbiIsInNwYWNlIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsImJhciIsImNhdCIsIl9jaGFyVG9QYXR0ZXJuIiwibmV3a2luZCIsImNoYXIiLCJjaGFyQ29kZSIsInRocmVzaG9sZHMiLCJfY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkIiwiYmFyVGhyZXNob2xkIiwic3BhY2VUaHJlc2hvbGQiLCJiaXRtYXNrIiwiQ29kZTEyOFJlYWRlciIsIkNPREVfU0hJRlQiLCJDT0RFX0MiLCJDT0RFX0IiLCJDT0RFX0EiLCJTVEFSVF9DT0RFX0EiLCJTVEFSVF9DT0RFX0IiLCJTVEFSVF9DT0RFX0MiLCJTVE9QX0NPREUiLCJNT0RVTEVfSU5ESUNFUyIsIl9jb3JyZWN0IiwiY2FsY3VsYXRlQ29ycmVjdGlvbiIsIm11bHRpcGxpZXIiLCJjaGVja3N1bSIsInJhd1Jlc3VsdCIsInNoaWZ0TmV4dCIsInJlbW92ZUxhc3RDaGFyYWN0ZXIiLCJleHBlY3RlZCIsInN1bU5vcm1hbGl6ZWQiLCJzdW1FeHBlY3RlZCIsIkNvZGUzOVZJTlJlYWRlciIsIklPUSIsIkFaMDkiLCJyZXBsYWNlIiwiX2NoZWNrQ2hlY2tzdW0iLCJDb2RlOTNSZWFkZXIiLCJzcGxpdCIsIl92ZXJpZnlFbmQiLCJfdmVyaWZ5Q2hlY2tzdW1zIiwiX2RlY29kZUV4dGVuZGVkIiwiY2hhckFycmF5IiwibmV4dENoYXIiLCJuZXh0Q2hhckNvZGUiLCJfbWF0Y2hDaGVja0NoYXIiLCJtYXhXZWlnaHQiLCJhcnJheVRvQ2hlY2siLCJ3ZWlnaHRlZFN1bXMiLCJ3ZWlnaHQiLCJjaGVja0NoYXIiLCJFQU4yUmVhZGVyIiwicGFyc2VJbnQiLCJFQU41UmVhZGVyIiwiQ0hFQ0tfRElHSVRfRU5DT0RJTkdTIiwiZXh0ZW5zaW9uQ2hlY2tzdW0iLCJkZXRlcm1pbmVDaGVja0RpZ2l0IiwiRUFOOFJlYWRlciIsIkkyb2Y1UmVhZGVyIiwibm9ybWFsaXplQmFyU3BhY2VXaWR0aCIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvdW50ZXJTdW0iLCJjb2RlU3VtIiwiY29ycmVjdGlvblJhdGlvIiwiY29ycmVjdGlvblJhdGlvSW52ZXJzZSIsIl9kZWNvZGVQYWlyIiwiY291bnRlclBhaXIiLCJjb2RlcyIsInFyIiwiUXJDb2RlUmVhZGVyIiwiVVBDRVJlYWRlciIsIl9kZXRlcm1pbmVQYXJpdHkiLCJuclN5c3RlbSIsIl9jb252ZXJ0VG9VUENBIiwidXBjYSIsImxhc3REaWdpdCIsIlVQQ1JlYWRlciIsImNoYXJBdCIsInN1YnN0cmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQTJDLGNBQWM7O0FBRXpEO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLENBQUM7O0FBRUQ7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixVQUFVO0FBQ1Y7QUFDQSxhQUFhLFNBQVM7QUFDdEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDL0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzNCQSxpRDs7Ozs7O0FDQUEsaUQ7Ozs7OztBQ0FBLGlEIiwiZmlsZSI6InF1YWdnYS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImdldC1waXhlbHNcIiksIHJlcXVpcmUoXCJuZGFycmF5XCIpLCByZXF1aXJlKFwibmRhcnJheS1saW5lYXItaW50ZXJwb2xhdGVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiZ2V0LXBpeGVsc1wiLCBcIm5kYXJyYXlcIiwgXCJuZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJnZXQtcGl4ZWxzXCIpLCByZXF1aXJlKFwibmRhcnJheVwiKSwgcmVxdWlyZShcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KHJvb3RbXCJnZXQtcGl4ZWxzXCJdLCByb290W1wibmRhcnJheVwiXSwgcm9vdFtcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY5X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTcwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxNzQyMWFhOGQ0YTk2NWUwMmI5ZiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc09iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmZ1bmN0aW9uIEJhcmNvZGVSZWFkZXIoY29uZmlnLCBzdXBwbGVtZW50cykge1xuICAgIHRoaXMuX3JvdyA9IFtdO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICByZXR1cm4gdGhpcztcbn1cblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX25leHRVbnNldCA9IGZ1bmN0aW9uKGxpbmUsIHN0YXJ0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWxpbmVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFBhdHRlcm4gPSBmdW5jdGlvbihjb3VudGVyLCBjb2RlLCBtYXhTaW5nbGVFcnJvcikge1xuICAgIHZhciBpLFxuICAgICAgICBlcnJvciA9IDAsXG4gICAgICAgIHNpbmdsZUVycm9yID0gMCxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgbW9kdWxvID0gMCxcbiAgICAgICAgYmFyV2lkdGgsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzY2FsZWQ7XG5cbiAgICBtYXhTaW5nbGVFcnJvciA9IG1heFNpbmdsZUVycm9yIHx8IHRoaXMuU0lOR0xFX0NPREVfRVJST1IgfHwgMTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBjb3VudGVyW2ldO1xuICAgICAgICBtb2R1bG8gKz0gY29kZVtpXTtcbiAgICB9XG4gICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgYmFyV2lkdGggPSBzdW0gLyBtb2R1bG87XG4gICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3VudCA9IGNvdW50ZXJbaV07XG4gICAgICAgIHNjYWxlZCA9IGNvZGVbaV0gKiBiYXJXaWR0aDtcbiAgICAgICAgc2luZ2xlRXJyb3IgPSBNYXRoLmFicyhjb3VudCAtIHNjYWxlZCkgLyBzY2FsZWQ7XG4gICAgICAgIGlmIChzaW5nbGVFcnJvciA+IG1heFNpbmdsZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciArPSBzaW5nbGVFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yIC8gbW9kdWxvO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX25leHRTZXQgPSBmdW5jdGlvbihsaW5lLCBvZmZzZXQpIHtcbiAgICB2YXIgaTtcblxuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbn07XG5cbkJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9jb3JyZWN0QmFycyA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvcnJlY3Rpb24sIGluZGljZXMpIHtcbiAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIHRtcCA9IDA7XG4gICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgdG1wID0gY291bnRlcltpbmRpY2VzW2xlbmd0aF1dICogKDEgLSAoKDEgLSBjb3JyZWN0aW9uKSAvIDIpKTtcbiAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaW5kaWNlc1tsZW5ndGhdXSA9IHRtcDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoVHJhY2UgPSBmdW5jdGlvbihjbXBDb3VudGVyLCBlcHNpbG9uKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgaXNXaGl0ZSA9ICFzZWxmLl9yb3dbb2Zmc2V0XSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjtcblxuICAgIGlmIChjbXBDb3VudGVyKSB7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgY21wQ291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIGNtcENvdW50ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3VudGVyID0gY291bnRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY291bnRlci5wdXNoKDApO1xuICAgICAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIucHVzaCgwKTtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBjbXBDb3VudGVyIHdhcyBub3QgZ2l2ZW5cbiAgICBiZXN0TWF0Y2guc3RhcnQgPSBvZmZzZXQ7XG4gICAgYmVzdE1hdGNoLmVuZCA9IHNlbGYuX3Jvdy5sZW5ndGggLSAxO1xuICAgIGJlc3RNYXRjaC5jb3VudGVyID0gY291bnRlcjtcbiAgICByZXR1cm4gYmVzdE1hdGNoO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlUGF0dGVybiA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHJlc3VsdDtcblxuICAgIHNlbGYuX3JvdyA9IHBhdHRlcm47XG4gICAgcmVzdWx0ID0gc2VsZi5fZGVjb2RlKCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICByZXN1bHQgPSBzZWxmLl9kZWNvZGUoKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVSZWFkZXIuRElSRUNUSU9OLlJFVkVSU0U7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gcmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHNlbGYuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVSZWFkZXIuRElSRUNUSU9OLkZPUldBUkQ7XG4gICAgfVxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LmZvcm1hdCA9IHNlbGYuRk9STUFUO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX21hdGNoUmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB2YWx1ZSkge1xuICAgIHZhciBpO1xuXG4gICAgc3RhcnQgPSBzdGFydCA8IDAgPyAwIDogc3RhcnQ7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fcm93W2ldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQmFyY29kZVJlYWRlci5wcm90b3R5cGUuX2ZpbGxDb3VudGVycyA9IGZ1bmN0aW9uKG9mZnNldCwgZW5kLCBpc1doaXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlcnMgPSBbXTtcblxuICAgIGlzV2hpdGUgPSAodHlwZW9mIGlzV2hpdGUgIT09ICd1bmRlZmluZWQnKSA/IGlzV2hpdGUgOiB0cnVlO1xuICAgIG9mZnNldCA9ICh0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykgPyBvZmZzZXQgOiBzZWxmLl9uZXh0VW5zZXQoc2VsZi5fcm93KTtcbiAgICBlbmQgPSBlbmQgfHwgc2VsZi5fcm93Lmxlbmd0aDtcblxuICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMDtcbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlcnM7XG59O1xuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fdG9Db3VudGVycyA9IGZ1bmN0aW9uKHN0YXJ0LCBjb3VudGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBudW1Db3VudGVycyA9IGNvdW50ZXIubGVuZ3RoLFxuICAgICAgICBlbmQgPSBzZWxmLl9yb3cubGVuZ3RoLFxuICAgICAgICBpc1doaXRlID0gIXNlbGYuX3Jvd1tzdGFydF0sXG4gICAgICAgIGksXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgQXJyYXlIZWxwZXIuaW5pdChjb3VudGVyLCAwKTtcblxuICAgIGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50ZXI7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIFwiRk9STUFUXCIsIHtcbiAgICB2YWx1ZTogJ3Vua25vd24nLFxuICAgIHdyaXRlYWJsZTogZmFsc2Vcbn0pO1xuXG5CYXJjb2RlUmVhZGVyLkRJUkVDVElPTiA9IHtcbiAgICBGT1JXQVJEOiAxLFxuICAgIFJFVkVSU0U6IC0xXG59O1xuXG5CYXJjb2RlUmVhZGVyLkV4Y2VwdGlvbiA9IHtcbiAgICBTdGFydE5vdEZvdW5kRXhjZXB0aW9uOiBcIlN0YXJ0LUluZm8gd2FzIG5vdCBmb3VuZCFcIixcbiAgICBDb2RlTm90Rm91bmRFeGNlcHRpb246IFwiQ29kZSBjb3VsZCBub3QgYmUgZm91bmQhXCIsXG4gICAgUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uOiBcIlBhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kIVwiXG59O1xuXG5CYXJjb2RlUmVhZGVyLkNPTkZJR19LRVlTID0ge307XG5cbmV4cG9ydCBkZWZhdWx0IEJhcmNvZGVSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2JhcmNvZGVfcmVhZGVyLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogZnVuY3Rpb24oYXJyLCB2YWwpIHtcbiAgICAgICAgdmFyIGwgPSBhcnIubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobC0tKSB7XG4gICAgICAgICAgICBhcnJbbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2h1ZmZsZXMgdGhlIGNvbnRlbnQgb2YgYW4gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIGFycmF5IGl0c2VsZiBzaHVmZmxlZFxuICAgICAqL1xuICAgIHNodWZmbGU6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgaSA9IGFyci5sZW5ndGggLSAxLCBqLCB4O1xuICAgICAgICBmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSk7XG4gICAgICAgICAgICB4ID0gYXJyW2ldO1xuICAgICAgICAgICAgYXJyW2ldID0gYXJyW2pdO1xuICAgICAgICAgICAgYXJyW2pdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICB0b1BvaW50TGlzdDogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBpLCBqLCByb3cgPSBbXSwgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGFycltpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJvd1tqXSA9IGFycltpXVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3NbaV0gPSBcIltcIiArIHJvdy5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIltcIiArIHJvd3Muam9pbihcIixcXHJcXG5cIikgKyBcIl1cIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICogQHJldHVybiB7QXJyYXl9IHRoZSByZWR1Y2VkIGFycmF5XG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnIsIHRocmVzaG9sZCwgc2NvcmVGdW5jKSB7XG4gICAgICAgIHZhciBpLCBxdWV1ZSA9IFtdO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNjb3JlRnVuYy5hcHBseShhcnIsIFthcnJbaV1dKSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGFycltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlO1xuICAgIH0sXG5cbiAgICBtYXhJbmRleDogZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgIHZhciBpLCBtYXggPSAwO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFycltpXSA+IGFyclttYXhdKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKGFycikge1xuICAgICAgICB2YXIgaSwgbWF4ID0gMDtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgc3VtOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGgsXG4gICAgICAgICAgICBzdW0gPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgc3VtICs9IGFycltsZW5ndGhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQge21lcmdlfSBmcm9tICdsb2Rhc2gnO1xuXG5mdW5jdGlvbiBFQU5SZWFkZXIob3B0cywgc3VwcGxlbWVudHMpIHtcbiAgICBvcHRzID0gbWVyZ2UoZ2V0RGVmYXVsQ29uZmlnKCksIG9wdHMpO1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzLCBvcHRzLCBzdXBwbGVtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bENvbmZpZygpIHtcbiAgICB2YXIgY29uZmlnID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhFQU5SZWFkZXIuQ09ORklHX0tFWVMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gRUFOUmVhZGVyLkNPTkZJR19LRVlTW2tleV0uZGVmYXVsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBDT0RFX0xfU1RBUlQ6IHt2YWx1ZTogMH0sXG4gICAgQ09ERV9HX1NUQVJUOiB7dmFsdWU6IDEwfSxcbiAgICBTVEFSVF9QQVRURVJOOiB7dmFsdWU6IFsxLCAxLCAxXX0sXG4gICAgU1RPUF9QQVRURVJOOiB7dmFsdWU6IFsxLCAxLCAxXX0sXG4gICAgTUlERExFX1BBVFRFUk46IHt2YWx1ZTogWzEsIDEsIDEsIDEsIDFdfSxcbiAgICBFWFRFTlNJT05fU1RBUlRfUEFUVEVSTjoge3ZhbHVlOiBbMSwgMSwgMl19LFxuICAgIENPREVfUEFUVEVSTjoge3ZhbHVlOiBbXG4gICAgICAgIFszLCAyLCAxLCAxXSxcbiAgICAgICAgWzIsIDIsIDIsIDFdLFxuICAgICAgICBbMiwgMSwgMiwgMl0sXG4gICAgICAgIFsxLCA0LCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDMsIDJdLFxuICAgICAgICBbMSwgMiwgMywgMV0sXG4gICAgICAgIFsxLCAxLCAxLCA0XSxcbiAgICAgICAgWzEsIDMsIDEsIDJdLFxuICAgICAgICBbMSwgMiwgMSwgM10sXG4gICAgICAgIFszLCAxLCAxLCAyXSxcbiAgICAgICAgWzEsIDEsIDIsIDNdLFxuICAgICAgICBbMSwgMiwgMiwgMl0sXG4gICAgICAgIFsyLCAyLCAxLCAyXSxcbiAgICAgICAgWzEsIDEsIDQsIDFdLFxuICAgICAgICBbMiwgMywgMSwgMV0sXG4gICAgICAgIFsxLCAzLCAyLCAxXSxcbiAgICAgICAgWzQsIDEsIDEsIDFdLFxuICAgICAgICBbMiwgMSwgMywgMV0sXG4gICAgICAgIFszLCAxLCAyLCAxXSxcbiAgICAgICAgWzIsIDEsIDEsIDNdXG4gICAgXX0sXG4gICAgQ09ERV9GUkVRVUVOQ1k6IHt2YWx1ZTogWzAsIDExLCAxMywgMTQsIDE5LCAyNSwgMjgsIDIxLCAyMiwgMjZdfSxcbiAgICBTSU5HTEVfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjcwfSxcbiAgICBBVkdfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjQ4fSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJlYW5fMTNcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkVBTlJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFQU5SZWFkZXI7XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZUNvZGUgPSBmdW5jdGlvbihzdGFydCwgY29kZXJhbmdlKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvZmZzZXQgPSBzdGFydCxcbiAgICAgICAgaXNXaGl0ZSA9ICFzZWxmLl9yb3dbb2Zmc2V0XSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH0sXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGVycm9yO1xuXG4gICAgaWYgKCFjb2RlcmFuZ2UpIHtcbiAgICAgICAgY29kZXJhbmdlID0gc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgY29kZXJhbmdlOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPiBzZWxmLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2ZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIsIGVwc2lsb24pIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtO1xuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpO1xuICAgIH1cblxuICAgIGlmIChpc1doaXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaXNXaGl0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0cnlIYXJkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnlIYXJkZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICggZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVwc2lsb24gPSBzZWxmLkFWR19DT0RFX0VSUk9SO1xuICAgIH1cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb3VudGVyW2ldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yID0gc2VsZi5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdyksXG4gICAgICAgIHN0YXJ0SW5mbztcblxuICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHN0YXJ0SW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgfVxufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9maW5kRW5kID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1doaXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbmRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyBzZWxmLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlRmlyc3REaWdpdCA9IGZ1bmN0aW9uKGNvZGVGcmVxdWVuY3kpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHNlbGYuQ09ERV9GUkVRVUVOQ1kubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHNlbGYuQ09ERV9GUkVRVUVOQ1lbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMHgwLFxuICAgICAgICBmaXJzdERpZ2l0O1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gc2VsZi5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGUuY29kZSA9IGNvZGUuY29kZSAtIHNlbGYuQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDAgPDwgKDUgLSBpKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICB9XG5cbiAgICBmaXJzdERpZ2l0ID0gc2VsZi5fY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5KTtcbiAgICBpZiAoZmlyc3REaWdpdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LnVuc2hpZnQoZmlyc3REaWdpdCk7XG5cbiAgICBjb2RlID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5NSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBjb2RlID0gc2VsZi5fZGVjb2RlQ29kZShjb2RlLmVuZCwgc2VsZi5DT0RFX0dfU1RBUlQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2RlO1xufTtcblxuRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgcmVzdWx0SW5mbyA9IHt9O1xuXG4gICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFN0YXJ0KCk7XG4gICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvZGUgPSB7XG4gICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IHN0YXJ0SW5mby5lbmRcbiAgICB9O1xuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVQYXlsb2FkKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvZGUgPSBzZWxmLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG4gICAgaWYgKCFjb2RlKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAvLyBDaGVja3N1bVxuICAgIGlmICghc2VsZi5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdXBwbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBleHQgPSB0aGlzLl9kZWNvZGVFeHRlbnNpb25zKGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0Q29kZSA9IGV4dC5kZWNvZGVkQ29kZXNbZXh0LmRlY29kZWRDb2Rlcy5sZW5ndGgtMV0sXG4gICAgICAgICAgICBlbmRJbmZvID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBsYXN0Q29kZS5zdGFydCArICgoKGxhc3RDb2RlLmVuZCAtIGxhc3RDb2RlLnN0YXJ0KSAvIDIpIHwgMCksXG4gICAgICAgICAgICAgICAgZW5kOiBsYXN0Q29kZS5lbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGlmKCFzZWxmLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdEluZm8gPSB7XG4gICAgICAgICAgICBzdXBwbGVtZW50OiBleHQsXG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSArIGV4dC5jb2RlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgY29kZXNldDogXCJcIixcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzLFxuICAgICAgICAuLi5yZXN1bHRJbmZvXG4gICAgfTtcbn07XG5cbkVBTlJlYWRlci5wcm90b3R5cGUuX2RlY29kZUV4dGVuc2lvbnMgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KSxcbiAgICAgICAgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTiwgc3RhcnQsIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5kZWNvZGUodGhpcy5fcm93LCBzdGFydEluZm8uZW5kKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBzdGFydEluZm8sXG4gICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgIGNvZGVzZXQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5FQU5SZWFkZXIucHJvdG90eXBlLl9jaGVja3N1bSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBzdW0gPSAwLCBpO1xuXG4gICAgZm9yICggaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICBmb3IgKCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbn07XG5cbkVBTlJlYWRlci5DT05GSUdfS0VZUyA9IHtcbiAgICBzdXBwbGVtZW50czoge1xuICAgICAgICAndHlwZSc6ICdhcnJheU9mKHN0cmluZyknLFxuICAgICAgICAnZGVmYXVsdCc6IFtdLFxuICAgICAgICAnZGVzY3JpcHRpb24nOiAnQWxsb3dlZCBleHRlbnNpb25zIHRvIGJlIGRlY29kZWQgKDIgYW5kL29yIDUpJ1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChFQU5SZWFkZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fcm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMilcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIHJldHVybiBvdXRcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ2wtdmVjMi9jbG9uZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUdldFRhZy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgZHJhd1JlY3Q6IGZ1bmN0aW9uKHBvcywgc2l6ZSwgY3R4LCBzdHlsZSl7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHBvcy54LCBwb3MueSwgc2l6ZS54LCBzaXplLnkpO1xuICAgIH0sXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKHBhdGgsIGRlZiwgY3R4LCBzdHlsZSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2U6IGZ1bmN0aW9uKGltYWdlRGF0YSwgc2l6ZSwgY3R4KSB7XG4gICAgICAgIHZhciBjYW52YXNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBzaXplLngsIHNpemUueSksXG4gICAgICAgICAgICBkYXRhID0gY2FudmFzRGF0YS5kYXRhLFxuICAgICAgICAgICAgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGNhbnZhc0RhdGFQb3MgPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHZhbHVlO1xuXG4gICAgICAgIGlmIChjYW52YXNEYXRhUG9zIC8gaW1hZ2VEYXRhUG9zICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGltYWdlRGF0YVBvcy0tKXtcbiAgICAgICAgICAgIHZhbHVlID0gaW1hZ2VEYXRhW2ltYWdlRGF0YVBvc107XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSAyNTU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vaW1hZ2VfZGVidWcuanMiLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fU3ltYm9sLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Nhc3RQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0TWFwRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvZXEuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBDbHVzdGVyMiBmcm9tICcuL2NsdXN0ZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4vYXJyYXlfaGVscGVyJztcbmNvbnN0IHZlYzIgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzIvY2xvbmUnKSxcbn07XG5jb25zdCB2ZWMzID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMzL2Nsb25lJyksXG59O1xuXG4vKipcbiAqIEBwYXJhbSB4IHgtY29vcmRpbmF0ZVxuICogQHBhcmFtIHkgeS1jb29yZGluYXRlXG4gKiBAcmV0dXJuIEltYWdlUmVmZXJlbmNlIHt4LHl9IENvb3JkaW5hdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltYWdlUmVmKHgsIHkpIHtcbiAgICB2YXIgdGhhdCA9IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgdG9WZWMyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMyLmNsb25lKFt0aGlzLngsIHRoaXMueV0pO1xuICAgICAgICB9LFxuICAgICAgICB0b1ZlYzM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzMuY2xvbmUoW3RoaXMueCwgdGhpcy55LCAxXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gdGhhdDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICB2YXIgaW50ZWdyYWxJbWFnZURhdGEgPSBpbnRlZ3JhbFdyYXBwZXIuZGF0YTtcbiAgICB2YXIgc3VtID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwLCBwb3NDID0gMCwgcG9zRCA9IDAsIHgsIHk7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3QgY29sdW1uXG4gICAgcG9zQiA9IHdpZHRoO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICggeSA9IDE7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3Bvc0FdO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArPSBzdW07XG4gICAgICAgIHBvc0EgKz0gd2lkdGg7XG4gICAgICAgIHBvc0IgKz0gd2lkdGg7XG4gICAgfVxuXG4gICAgcG9zQSA9IDA7XG4gICAgcG9zQiA9IDE7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKCB4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKCB5ID0gMTsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHBvc0EgPSB5ICogd2lkdGggKyAxO1xuICAgICAgICBwb3NCID0gKHkgLSAxKSAqIHdpZHRoICsgMTtcbiAgICAgICAgcG9zQyA9IHkgKiB3aWR0aDtcbiAgICAgICAgcG9zRCA9ICh5IC0gMSkgKiB3aWR0aDtcbiAgICAgICAgZm9yICggeCA9IDE7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtwb3NBXSArPVxuICAgICAgICAgICAgICAgIGltYWdlRGF0YVtwb3NBXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0JdICsgaW50ZWdyYWxJbWFnZURhdGFbcG9zQ10gLSBpbnRlZ3JhbEltYWdlRGF0YVtwb3NEXTtcbiAgICAgICAgICAgIHBvc0ErKztcbiAgICAgICAgICAgIHBvc0IrKztcbiAgICAgICAgICAgIHBvc0MrKztcbiAgICAgICAgICAgIHBvc0QrKztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgLy8gc3VtIHVwIGZpcnN0IHJvd1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW2ldO1xuICAgICAgICBpbnRlZ3JhbEltYWdlRGF0YVtpXSA9IHN1bTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciB2ID0gMTsgdiA8IGhlaWdodDsgdisrKSB7XG4gICAgICAgIHN1bSA9IDA7XG4gICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgd2lkdGg7IHUrKykge1xuICAgICAgICAgICAgc3VtICs9IGltYWdlRGF0YVt2ICogd2lkdGggKyB1XTtcbiAgICAgICAgICAgIGludGVncmFsSW1hZ2VEYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IHN1bSArIGludGVncmFsSW1hZ2VEYXRhWyh2IC0gMSkgKiB3aWR0aCArIHVdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgaWYgKCF0YXJnZXRXcmFwcGVyKSB7XG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YSwgbGVuZ3RoID0gaW1hZ2VEYXRhLmxlbmd0aCwgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB0YXJnZXREYXRhW2xlbmd0aF0gPSBpbWFnZURhdGFbbGVuZ3RoXSA8IHRocmVzaG9sZCA/IDEgOiAwO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSGlzdG9ncmFtKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKSB7XG4gICAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgYml0c1BlclBpeGVsID0gODtcbiAgICB9XG4gICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBsZW5ndGggPSBpbWFnZURhdGEubGVuZ3RoLFxuICAgICAgICBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWwsXG4gICAgICAgIGJ1Y2tldENudCA9IDEgPDwgYml0c1BlclBpeGVsLFxuICAgICAgICBoaXN0ID0gbmV3IEludDMyQXJyYXkoYnVja2V0Q250KTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBoaXN0W2ltYWdlRGF0YVtsZW5ndGhdID4+IGJpdFNoaWZ0XSsrO1xuICAgIH1cbiAgICByZXR1cm4gaGlzdDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGxlbmd0aCA9IGxpbmUubGVuZ3RoLFxuICAgICAgICBsZWZ0ID0gbGluZVswXSxcbiAgICAgICAgY2VudGVyID0gbGluZVsxXSxcbiAgICAgICAgcmlnaHQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHJpZ2h0ID0gbGluZVtpICsgMV07XG4gICAgICAgIC8vICAtMSA0IC0xIGtlcm5lbFxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVPdHN1VGhyZXNob2xkKGltYWdlV3JhcHBlciwgYml0c1BlclBpeGVsKSB7XG4gICAgaWYgKCFiaXRzUGVyUGl4ZWwpIHtcbiAgICAgICAgYml0c1BlclBpeGVsID0gODtcbiAgICB9XG4gICAgdmFyIGhpc3QsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIHZhciBzdW0gPSAwLCBpO1xuICAgICAgICBmb3IgKCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgdmFyIGksIHN1bSA9IDA7XG5cbiAgICAgICAgZm9yICggaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICB2YXIgdmV0ID0gWzBdLCBwMSwgcDIsIHAxMiwgaywgbTEsIG0yLCBtMTIsXG4gICAgICAgICAgICBtYXggPSAoMSA8PCBiaXRzUGVyUGl4ZWwpIC0gMTtcblxuICAgICAgICBoaXN0ID0gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCk7XG4gICAgICAgIGZvciAoIGsgPSAxOyBrIDwgbWF4OyBrKyspIHtcbiAgICAgICAgICAgIHAxID0gcHgoMCwgayk7XG4gICAgICAgICAgICBwMiA9IHB4KGsgKyAxLCBtYXgpO1xuICAgICAgICAgICAgcDEyID0gcDEgKiBwMjtcbiAgICAgICAgICAgIGlmIChwMTIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwMTIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbTEgPSBteCgwLCBrKSAqIHAyO1xuICAgICAgICAgICAgbTIgPSBteChrICsgMSwgbWF4KSAqIHAxO1xuICAgICAgICAgICAgbTEyID0gbTEgLSBtMjtcbiAgICAgICAgICAgIHZldFtrXSA9IG0xMiAqIG0xMiAvIHAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXlIZWxwZXIubWF4SW5kZXgodmV0KTtcbiAgICB9XG5cbiAgICB0aHJlc2hvbGQgPSBkZXRlcm1pbmVUaHJlc2hvbGQoKTtcbiAgICByZXR1cm4gdGhyZXNob2xkIDw8IGJpdFNoaWZ0O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyKTtcblxuICAgIHRocmVzaG9sZEltYWdlKGltYWdlV3JhcHBlciwgdGhyZXNob2xkLCB0YXJnZXRXcmFwcGVyKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xufTtcblxuLy8gbG9jYWwgdGhyZXNob2xkaW5nXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUJpbmFyeUltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29tcHV0ZUludGVncmFsSW1hZ2UoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpO1xuXG4gICAgaWYgKCF0YXJnZXRXcmFwcGVyKSB7XG4gICAgICAgIHRhcmdldFdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIHZhciBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICB2YXIgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIHZhciBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIHZhciBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIHZhciBzdW0gPSAwLCB2LCB1LCBrZXJuZWwgPSAzLCBBLCBCLCBDLCBELCBhdmcsIHNpemUgPSAoa2VybmVsICogMiArIDEpICogKGtlcm5lbCAqIDIgKyAxKTtcblxuICAgIC8vIGNsZWFyIG91dCB0b3AgJiBib3R0b20tYm9yZGVyXG4gICAgZm9yICggdiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICggdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygodikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgICAgICB0YXJnZXREYXRhWygoKGhlaWdodCAtIDEpIC0gdikgKiB3aWR0aCkgKyB1XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjbGVhciBvdXQgbGVmdCAmIHJpZ2h0IGJvcmRlclxuICAgIGZvciAoIHYgPSBrZXJuZWw7IHYgPCBoZWlnaHQgLSBrZXJuZWw7IHYrKykge1xuICAgICAgICBmb3IgKCB1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKCB2ID0ga2VybmVsICsgMTsgdiA8IGhlaWdodCAtIGtlcm5lbCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKCB1ID0ga2VybmVsICsgMTsgdSA8IHdpZHRoIC0ga2VybmVsOyB1KyspIHtcbiAgICAgICAgICAgIEEgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSAtIGtlcm5lbCAtIDEpXTtcbiAgICAgICAgICAgIEIgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiAtIGtlcm5lbCAtIDEpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgICAgICAgQyA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBEID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgKyBrZXJuZWwpICogd2lkdGggKyAodSArIGtlcm5lbCldO1xuICAgICAgICAgICAgc3VtID0gRCAtIEMgLSBCICsgQTtcbiAgICAgICAgICAgIGF2ZyA9IHN1bSAvIChzaXplKTtcbiAgICAgICAgICAgIHRhcmdldERhdGFbdiAqIHdpZHRoICsgdV0gPSBpbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPiAoYXZnICsgNSkgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIHZhciBpLCBrLCBjbHVzdGVyLCBwb2ludCwgY2x1c3RlcnMgPSBbXTtcblxuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgcHJvcGVydHkgPSBcInJhZFwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICggayA9IDA7IGsgPCBjbHVzdGVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgY2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKGNsdXN0ZXIuZml0cyhuZXdQb2ludCkpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyLmFkZChuZXdQb2ludCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZWFjaCBjbG91ZFxuICAgIGZvciAoIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50ID0gQ2x1c3RlcjIuY3JlYXRlUG9pbnQocG9pbnRzW2ldLCBpLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICghYWRkVG9DbHVzdGVyKHBvaW50KSkge1xuICAgICAgICAgICAgY2x1c3RlcnMucHVzaChDbHVzdGVyMi5jcmVhdGUocG9pbnQsIHRocmVzaG9sZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbHVzdGVycztcbn07XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2U6IGZ1bmN0aW9uKHBvaW50cywgdmVjKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb24sIG1heEl0ZXJhdGlvbnMgPSAxMCwgdG9wID0gW10sIHJlc3VsdCA9IFtdLCBjZW50ZXJQb3MgPSAwLCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIHZhciBmcm9tLCB0bywgdG9JZHgsIHByZWRpY3RlZFBvcywgdGhyZXNob2xkWCA9IDEsIHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCksIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hdGNoKHBvcywgcHJlZGljdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy54ID4gKHByZWRpY3RlZC54IC0gdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy54IDwgKHByZWRpY3RlZC54ICsgdGhyZXNob2xkWClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55ID4gKHByZWRpY3RlZC55IC0gdGhyZXNob2xkWSlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIHBvcy55IDwgKHByZWRpY3RlZC55ICsgdGhyZXNob2xkWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIG5leHQgaW5kZXggaXMgd2l0aGluIHRoZSB2ZWMgc3BlY2lmaWNhdGlvbnNcbiAgICAgICAgICAgIC8vIGlmIG5vdCwgY2hlY2sgYXMgbG9uZyBhcyB0aGUgdGhyZXNob2xkIGlzIG1ldFxuXG4gICAgICAgICAgICBmcm9tID0gcG9pbnRzW2lkeF07XG4gICAgICAgICAgICBpZiAoZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY3RlZFBvcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogZnJvbS54ICsgdmVjWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBmcm9tLnkgKyB2ZWNbMV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gaWR4ICsgMSA6IGlkeCAtIDE7XG4gICAgICAgICAgICB0byA9IHBvaW50c1t0b0lkeF07XG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKCBmb3VuZCA9IG1hdGNoKHRvLCBwcmVkaWN0ZWRQb3MpKSAhPT0gdHJ1ZSAmJiAoTWF0aC5hYnModG8ueSAtIGZyb20ueSkgPCB2ZWNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG9JZHggPSBmb3J3YXJkID8gdG9JZHggKyAxIDogdG9JZHggLSAxO1xuICAgICAgICAgICAgICAgIHRvID0gcG9pbnRzW3RvSWR4XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID8gdG9JZHggOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaXRlcmF0aW9uID0gMDsgaXRlcmF0aW9uIDwgbWF4SXRlcmF0aW9uczsgaXRlcmF0aW9uKyspIHtcbiAgICAgICAgICAgIC8vIHJhbmRvbWx5IHNlbGVjdCBwb2ludCB0byBzdGFydCB3aXRoXG4gICAgICAgICAgICBjZW50ZXJQb3MgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb2ludHMubGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gdHJhY2UgZm9yd2FyZFxuICAgICAgICAgICAgdG9wID0gW107XG4gICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgdG9wLnB1c2gocG9pbnRzW2N1cnJlbnRQb3NdKTtcbiAgICAgICAgICAgIHdoaWxlICgoIGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlclBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9zID0gY2VudGVyUG9zO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoIGN1cnJlbnRQb3MgPSB0cmFjZShjdXJyZW50UG9zLCBmYWxzZSkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9wLmxlbmd0aCA+IHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5leHBvcnQgY29uc3QgRElMQVRFID0gMTtcbmV4cG9ydCBjb25zdCBFUk9ERSA9IDI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWxhdGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIHZhciB2LFxuICAgICAgICB1LFxuICAgICAgICBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgIHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54LFxuICAgICAgICBzdW0sXG4gICAgICAgIHlTdGFydDEsXG4gICAgICAgIHlTdGFydDIsXG4gICAgICAgIHhTdGFydDEsXG4gICAgICAgIHhTdGFydDI7XG5cbiAgICBmb3IgKCB2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKCB1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdICtcbiAgICAgICAgICAgIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdICtcbiAgICAgICAgICAgIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPiAwID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVdyYXBwZXIsIG91dEltYWdlV3JhcHBlcikge1xuICAgIHZhciB2LFxuICAgICAgICB1LFxuICAgICAgICBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBoZWlnaHQgPSBpbkltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgIHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54LFxuICAgICAgICBzdW0sXG4gICAgICAgIHlTdGFydDEsXG4gICAgICAgIHlTdGFydDIsXG4gICAgICAgIHhTdGFydDEsXG4gICAgICAgIHhTdGFydDI7XG5cbiAgICBmb3IgKCB2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKCB1ID0gMTsgdSA8IHdpZHRoIC0gMTsgdSsrKSB7XG4gICAgICAgICAgICB5U3RhcnQxID0gdiAtIDE7XG4gICAgICAgICAgICB5U3RhcnQyID0gdiArIDE7XG4gICAgICAgICAgICB4U3RhcnQxID0gdSAtIDE7XG4gICAgICAgICAgICB4U3RhcnQyID0gdSArIDE7XG4gICAgICAgICAgICBzdW0gPSBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDJdICtcbiAgICAgICAgICAgIGluSW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdICtcbiAgICAgICAgICAgIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0Ml07XG4gICAgICAgICAgICBvdXRJbWFnZURhdGFbdiAqIHdpZHRoICsgdV0gPSBzdW0gPT09IDUgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYUltYWdlV3JhcHBlci5kYXRhLmxlbmd0aCxcbiAgICAgICAgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgYkltYWdlRGF0YSA9IGJJbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSAtIGJJbWFnZURhdGFbbGVuZ3RoXTtcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdEltYWdlV3JhcHBlciA9IGFJbWFnZVdyYXBwZXI7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBhSW1hZ2VXcmFwcGVyLmRhdGEubGVuZ3RoLFxuICAgICAgICBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICBjSW1hZ2VEYXRhID0gcmVzdWx0SW1hZ2VXcmFwcGVyLmRhdGE7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgY0ltYWdlRGF0YVtsZW5ndGhdID0gYUltYWdlRGF0YVtsZW5ndGhdIHx8IGJJbWFnZURhdGFbbGVuZ3RoXTtcbiAgICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIHZhciBsZW5ndGggPSBpbWFnZVdyYXBwZXIuZGF0YS5sZW5ndGgsIGRhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YSwgc3VtID0gMDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBzdW0gKz0gZGF0YVtsZW5ndGhdO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICB2YXIgaSwgbWluSWR4ID0gMCwgbWluID0gMCwgcXVldWUgPSBbXSwgc2NvcmUsIGhpdCwgcG9zO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB0b3A7IGkrKykge1xuICAgICAgICBxdWV1ZVtpXSA9IHtcbiAgICAgICAgICAgIHNjb3JlOiAwLFxuICAgICAgICAgICAgaXRlbTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzY29yZSA9IHNjb3JlRnVuYy5hcHBseSh0aGlzLCBbbGlzdFtpXV0pO1xuICAgICAgICBpZiAoc2NvcmUgPiBtaW4pIHtcbiAgICAgICAgICAgIGhpdCA9IHF1ZXVlW21pbklkeF07XG4gICAgICAgICAgICBoaXQuc2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGhpdC5pdGVtID0gbGlzdFtpXTtcbiAgICAgICAgICAgIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICBmb3IgKCBwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QXJyYXlGcm9tSW1hZ2UoaHRtbEltYWdlLCBvZmZzZXRYLCBjdHgsIGFycmF5KSB7XG4gICAgY3R4LmRyYXdJbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCk7XG4gICAgdmFyIGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldFgsIDAsIGh0bWxJbWFnZS53aWR0aCwgaHRtbEltYWdlLmhlaWdodCkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgdmFyIGN0eERhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSwgc2l6ZS54LCBzaXplLnkpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEoY2FudmFzRGF0YSwgc2l6ZSwgb3V0QXJyYXkpIHtcbiAgICB2YXIgdG9wUm93SWR4ID0gMDtcbiAgICB2YXIgYm90dG9tUm93SWR4ID0gc2l6ZS54O1xuICAgIHZhciBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgdmFyIG91dFdpZHRoID0gc2l6ZS54IC8gMjtcbiAgICB2YXIgb3V0SW1nSWR4ID0gMDtcbiAgICB2YXIgaW5XaWR0aCA9IHNpemUueDtcbiAgICB2YXIgaTtcblxuICAgIHdoaWxlIChib3R0b21Sb3dJZHggPCBlbmRJZHgpIHtcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbWdJZHhdID0gKFxuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDBdICtcbiAgICAgICAgICAgICAgICAgMC41ODcgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAxXSArXG4gICAgICAgICAgICAgICAgIDAuMTE0ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMl0pICtcbiAgICAgICAgICAgICAgICAoMC4yOTkgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAwXSArXG4gICAgICAgICAgICAgICAgIDAuNTg3ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMV0gK1xuICAgICAgICAgICAgICAgICAwLjExNCAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDJdKSArXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAwXSArXG4gICAgICAgICAgICAgICAgIDAuNTg3ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAxXSArXG4gICAgICAgICAgICAgICAgIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4KSAqIDQgKyAyXSkgK1xuICAgICAgICAgICAgICAgICgwLjI5OSAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDBdICtcbiAgICAgICAgICAgICAgICAgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAxXSArXG4gICAgICAgICAgICAgICAgIDAuMTE0ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMl0pKSAvIDQ7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCA9IHRvcFJvd0lkeCArIDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggPSBib3R0b21Sb3dJZHggKyAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCA9IHRvcFJvd0lkeCArIGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCA9IGJvdHRvbVJvd0lkeCArIGluV2lkdGg7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVHcmF5KGltYWdlRGF0YSwgb3V0QXJyYXksIGNvbmZpZykge1xuICAgIHZhciBsID0gKGltYWdlRGF0YS5sZW5ndGggLyA0KSB8IDAsXG4gICAgICAgIGksXG4gICAgICAgIHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPVxuICAgICAgICAgICAgICAgIDAuMjk5ICogaW1hZ2VEYXRhW2kgKiA0ICsgMF0gKyAwLjU4NyAqIGltYWdlRGF0YVtpICogNCArIDFdICsgMC4xMTQgKiBpbWFnZURhdGFbaSAqIDQgKyAyXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMpIHtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB9XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMud2lkdGggKiB0aGlzLmhlaWdodCk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcywgMCwgMCk7XG4gICAgICAgIHZhciBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkuZGF0YTtcbiAgICAgICAgY29tcHV0ZUdyYXkoZGF0YSwgYXJyYXkpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKGFycmF5LCB7XG4gICAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgeTogdGhpcy5oZWlnaHRcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gaW5JbWcge0ltYWdlV3JhcHBlcn0gaW5wdXQgaW1hZ2UgdG8gYmUgc2FtcGxlZFxuICogQHBhcmFtIG91dEltZyB7SW1hZ2VXcmFwcGVyfSB0byBiZSBzdG9yZWQgaW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbGZTYW1wbGUoaW5JbWdXcmFwcGVyLCBvdXRJbWdXcmFwcGVyKSB7XG4gICAgdmFyIGluSW1nID0gaW5JbWdXcmFwcGVyLmRhdGE7XG4gICAgdmFyIGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIHZhciBvdXRJbWcgPSBvdXRJbWdXcmFwcGVyLmRhdGE7XG4gICAgdmFyIHRvcFJvd0lkeCA9IDA7XG4gICAgdmFyIGJvdHRvbVJvd0lkeCA9IGluV2lkdGg7XG4gICAgdmFyIGVuZElkeCA9IGluSW1nLmxlbmd0aDtcbiAgICB2YXIgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICB2YXIgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCA9IHRvcFJvd0lkeCArIDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggPSBib3R0b21Sb3dJZHggKyAyO1xuICAgICAgICB9XG4gICAgICAgIHRvcFJvd0lkeCA9IHRvcFJvd0lkeCArIGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCA9IGJvdHRvbVJvd0lkeCArIGluV2lkdGg7XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IpIHtcbiAgICB2YXIgaCA9IGhzdlswXSxcbiAgICAgICAgcyA9IGhzdlsxXSxcbiAgICAgICAgdiA9IGhzdlsyXSxcbiAgICAgICAgYyA9IHYgKiBzLFxuICAgICAgICB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKGggLyA2MCkgJSAyIC0gMSkpLFxuICAgICAgICBtID0gdiAtIGMsXG4gICAgICAgIHIgPSAwLFxuICAgICAgICBnID0gMCxcbiAgICAgICAgYiA9IDA7XG5cbiAgICByZ2IgPSByZ2IgfHwgWzAsIDAsIDBdO1xuXG4gICAgaWYgKGggPCA2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgZyA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMTIwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBnID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAxODApIHtcbiAgICAgICAgZyA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH0gZWxzZSBpZiAoaCA8IDI0MCkge1xuICAgICAgICBnID0geDtcbiAgICAgICAgYiA9IGM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzAwKSB7XG4gICAgICAgIHIgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzNjApIHtcbiAgICAgICAgciA9IGM7XG4gICAgICAgIGIgPSB4O1xuICAgIH1cbiAgICByZ2JbMF0gPSAoKHIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJnYlsxXSA9ICgoZyArIG0pICogMjU1KSB8IDA7XG4gICAgcmdiWzJdID0gKChiICsgbSkgKiAyNTUpIHwgMDtcbiAgICByZXR1cm4gcmdiO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlRGl2aXNvcnMobikge1xuICAgIHZhciBsYXJnZURpdmlzb3JzID0gW10sXG4gICAgICAgIGRpdmlzb3JzID0gW10sXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn07XG5cbmZ1bmN0aW9uIF9jb21wdXRlSW50ZXJzZWN0aW9uKGFycjEsIGFycjIpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGogPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgYXJyMS5sZW5ndGggJiYgaiA8IGFycjIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnIxW2ldID09PSBhcnIyW2pdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhcnIxW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIGlmIChhcnIxW2ldID4gYXJyMltqXSkge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIHZhciBkaXZpc29yc1ggPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueCksXG4gICAgICAgIGRpdmlzb3JzWSA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS55KSxcbiAgICAgICAgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSksXG4gICAgICAgIGNvbW1vbiA9IF9jb21wdXRlSW50ZXJzZWN0aW9uKGRpdmlzb3JzWCwgZGl2aXNvcnNZKSxcbiAgICAgICAgbnJPZlBhdGNoZXNMaXN0ID0gWzgsIDEwLCAxNSwgMjAsIDMyLCA2MCwgODBdLFxuICAgICAgICBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgICAgIFwieC1zbWFsbFwiOiA1LFxuICAgICAgICAgICAgXCJzbWFsbFwiOiA0LFxuICAgICAgICAgICAgXCJtZWRpdW1cIjogMyxcbiAgICAgICAgICAgIFwibGFyZ2VcIjogMixcbiAgICAgICAgICAgIFwieC1sYXJnZVwiOiAxXG4gICAgICAgIH0sXG4gICAgICAgIG5yT2ZQYXRjaGVzSWR4ID0gbnJPZlBhdGNoZXNNYXBbcGF0Y2hTaXplXSB8fCBuck9mUGF0Y2hlc01hcC5tZWRpdW0sXG4gICAgICAgIG5yT2ZQYXRjaGVzID0gbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4XSxcbiAgICAgICAgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyksXG4gICAgICAgIG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdICYmXG4gICAgICAgICAgICBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0gKSB7XG4gICAgICAgICAgICByZXR1cm4ge3g6IGZvdW5kLCB5OiBmb3VuZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhjb21tb24pO1xuICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKF9jb21wdXRlRGl2aXNvcnMod2lkZVNpZGUpKTtcbiAgICAgICAgaWYgKCFvcHRpbWFsUGF0Y2hTaXplKSB7XG4gICAgICAgICAgICBvcHRpbWFsUGF0Y2hTaXplID0gZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzKChfY29tcHV0ZURpdmlzb3JzKGRlc2lyZWRQYXRjaFNpemUgKiBuck9mUGF0Y2hlcykpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW1hbFBhdGNoU2l6ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICB2YXIgZGltZW5zaW9uID0ge1xuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSksXG4gICAgICAgIHVuaXQ6IHZhbHVlLmluZGV4T2YoXCIlXCIpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gXCIlXCIgOiBcIiVcIlxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufTtcblxuZXhwb3J0IGNvbnN0IF9kaW1lbnNpb25zQ29udmVydGVycyA9IHtcbiAgICB0b3A6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoZGltZW5zaW9uLnVuaXQgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoZGltZW5zaW9uLnVuaXQgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoIC0gKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBib3R0b206IGZ1bmN0aW9uKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoZGltZW5zaW9uLnVuaXQgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGxlZnQ6IGZ1bmN0aW9uKGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICBpZiAoZGltZW5zaW9uLnVuaXQgPT09IFwiJVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVJbWFnZUFyZWEoaW5wdXRXaWR0aCwgaW5wdXRIZWlnaHQsIGFyZWEpIHtcbiAgICB2YXIgY29udGV4dCA9IHt3aWR0aDogaW5wdXRXaWR0aCwgaGVpZ2h0OiBpbnB1dEhlaWdodH07XG5cbiAgICB2YXIgcGFyc2VkQXJlYSA9IE9iamVjdC5rZXlzKGFyZWEpLnJlZHVjZShmdW5jdGlvbihyZXN1bHQsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcmVhW2tleV0sXG4gICAgICAgICAgICBwYXJzZWQgPSBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpLFxuICAgICAgICAgICAgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgcmVzdWx0W2tleV0gPSBjYWxjdWxhdGVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHN4OiBwYXJzZWRBcmVhLmxlZnQsXG4gICAgICAgIHN5OiBwYXJzZWRBcmVhLnRvcCxcbiAgICAgICAgc3c6IHBhcnNlZEFyZWEucmlnaHQgLSBwYXJzZWRBcmVhLmxlZnQsXG4gICAgICAgIHNoOiBwYXJzZWRBcmVhLmJvdHRvbSAtIHBhcnNlZEFyZWEudG9wXG4gICAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL2N2X3V0aWxzLmpzIiwiaW1wb3J0IFN1YkltYWdlIGZyb20gJy4vc3ViSW1hZ2UnO1xuaW1wb3J0IHtoc3YycmdifSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuY29uc3QgdmVjMiA9IHtcbiAgICBjbG9uZTogcmVxdWlyZSgnZ2wtdmVjMi9jbG9uZScpLFxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLlxuICogSW4gYWRkaXRpb24sIHNvbWUgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW9uIGFyZSBjb250YWluZWQuXG4gKiBAcGFyYW0gc2l6ZSB7eCx5fSBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxcbiAqIEBwYXJhbSBkYXRhIHtBcnJheX0gSWYgZ2l2ZW4sIGEgZmxhdCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhXG4gKiBAcGFyYW0gQXJyYXlUeXBlIHtUeXBlfSBJZiBnaXZlbiwgdGhlIGRlc2lyZWQgRGF0YVR5cGUgb2YgdGhlIEFycmF5IChtYXkgYmUgdHlwZWQvbm9uLXR5cGVkKVxuICogQHBhcmFtIGluaXRpYWxpemUge0Jvb2xlYW59IEluZGljYXRpbmcgaWYgdGhlIGFycmF5IHNob3VsZCBiZSBpbml0aWFsaXplZCBvbiBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtJbWFnZVdyYXBwZXJ9XG4gKi9cbmZ1bmN0aW9uIEltYWdlV3JhcHBlcihzaXplLCBkYXRhLCBBcnJheVR5cGUsIGluaXRpYWxpemUpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgaWYgKEFycmF5VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5VHlwZShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKEFycmF5VHlwZSA9PT0gQXJyYXkgJiYgaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQodGhpcy5kYXRhLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KHNpemUueCAqIHNpemUueSk7XG4gICAgICAgICAgICBpZiAoVWludDhBcnJheSA9PT0gQXJyYXkgJiYgaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQodGhpcy5kYXRhLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG59XG5cbi8qKlxuICogdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlIHdpdGggYSBnaXZlbiBvZmZzZXRcbiAqIEBwYXJhbSBpbWdSZWYge3gsIHl9IFRoZSBsb2NhdGlvbiB0byB0ZXN0XG4gKiBAcGFyYW0gYm9yZGVyIE51bWJlciB0aGUgcGFkZGluZyB2YWx1ZSBpbiBwaXhlbFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgbG9jYXRpb24gaW5zaWRlIHRoZSBpbWFnZSdzIGJvcmRlciwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAc2VlIGN2ZC9pbWFnZS5oXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuaW5JbWFnZVdpdGhCb3JkZXIgPSBmdW5jdGlvbihpbWdSZWYsIGJvcmRlcikge1xuICAgIHJldHVybiAoaW1nUmVmLnggPj0gYm9yZGVyKVxuICAgICAgICAmJiAoaW1nUmVmLnkgPj0gYm9yZGVyKVxuICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggLSBib3JkZXIpKVxuICAgICAgICAmJiAoaW1nUmVmLnkgPCAodGhpcy5zaXplLnkgLSBib3JkZXIpKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYmlsaW5lYXIgc2FtcGxpbmdcbiAqIEBwYXJhbSBpbkltZyBJbWFnZSB0byBleHRyYWN0IHNhbXBsZSBmcm9tXG4gKiBAcGFyYW0geCB0aGUgeC1jb29yZGluYXRlXG4gKiBAcGFyYW0geSB0aGUgeS1jb29yZGluYXRlXG4gKiBAcmV0dXJucyB0aGUgc2FtcGxlZCB2YWx1ZVxuICogQHNlZSBjdmQvdmlzaW9uLmhcbiAqL1xuSW1hZ2VXcmFwcGVyLnNhbXBsZSA9IGZ1bmN0aW9uKGluSW1nLCB4LCB5KSB7XG4gICAgdmFyIGx4ID0gTWF0aC5mbG9vcih4KTtcbiAgICB2YXIgbHkgPSBNYXRoLmZsb29yKHkpO1xuICAgIHZhciB3ID0gaW5JbWcuc2l6ZS54O1xuICAgIHZhciBiYXNlID0gbHkgKiBpbkltZy5zaXplLnggKyBseDtcbiAgICB2YXIgYSA9IGluSW1nLmRhdGFbYmFzZSArIDBdO1xuICAgIHZhciBiID0gaW5JbWcuZGF0YVtiYXNlICsgMV07XG4gICAgdmFyIGMgPSBpbkltZy5kYXRhW2Jhc2UgKyB3XTtcbiAgICB2YXIgZCA9IGluSW1nLmRhdGFbYmFzZSArIHcgKyAxXTtcbiAgICB2YXIgZSA9IGEgLSBiO1xuICAgIHggLT0gbHg7XG4gICAgeSAtPSBseTtcblxuICAgIHZhciByZXN1bHQgPSBNYXRoLmZsb29yKHggKiAoeSAqIChlIC0gYyArIGQpIC0gZSkgKyB5ICogKGMgLSBhKSArIGEpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgZ2l2ZW4gYXJyYXkuIFNldHMgZWFjaCBlbGVtZW50IHRvIHplcm8uXG4gKiBAcGFyYW0gYXJyYXkge0FycmF5fSBUaGUgYXJyYXkgdG8gaW5pdGlhbGl6ZVxuICovXG5JbWFnZVdyYXBwZXIuY2xlYXJBcnJheSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgICBhcnJheVtsXSA9IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge1N1YkltYWdlfSBmcm9tIHRoZSBjdXJyZW50IGltYWdlICh7dGhpc30pLlxuICogQHBhcmFtIGZyb20ge0ltYWdlUmVmfSBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgdGhlIHtTdWJJbWFnZX0gZnJvbS4gKHRvcC1sZWZ0IGNvcm5lcilcbiAqIEBwYXJhbSBzaXplIHtJbWFnZVJlZn0gVGhlIHNpemUgb2YgdGhlIHJlc3VsdGluZyBpbWFnZVxuICogQHJldHVybnMge1N1YkltYWdlfSBBIHNoYXJlZCBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLnN1YkltYWdlID0gZnVuY3Rpb24oZnJvbSwgc2l6ZSkge1xuICAgIHJldHVybiBuZXcgU3ViSW1hZ2UoZnJvbSwgc2l6ZSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4ge0ltYWdlV3JhcHBlcikgYW5kIGNvcGllcyB0aGUgbmVlZGVkIHVuZGVybHlpbmcgaW1hZ2UtZGF0YSBhcmVhXG4gKiBAcGFyYW0gaW1hZ2VXcmFwcGVyIHtJbWFnZVdyYXBwZXJ9IFRoZSB0YXJnZXQge0ltYWdlV3JhcHBlcn0gd2hlcmUgdGhlIGRhdGEgc2hvdWxkIGJlIGNvcGllZFxuICogQHBhcmFtIGZyb20ge0ltYWdlUmVmfSBUaGUgbG9jYXRpb24gd2hlcmUgdG8gY29weSBmcm9tICh0b3AtbGVmdCBsb2NhdGlvbilcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5zdWJJbWFnZUFzQ29weSA9IGZ1bmN0aW9uKGltYWdlV3JhcHBlciwgZnJvbSkge1xuICAgIHZhciBzaXplWSA9IGltYWdlV3JhcHBlci5zaXplLnksIHNpemVYID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICB2YXIgeCwgeTtcbiAgICBmb3IgKCB4ID0gMDsgeCA8IHNpemVYOyB4KyspIHtcbiAgICAgICAgZm9yICggeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YVt5ICogc2l6ZVggKyB4XSA9IHRoaXMuZGF0YVsoZnJvbS55ICsgeSkgKiB0aGlzLnNpemUueCArIGZyb20ueCArIHhdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5jb3B5VG8gPSBmdW5jdGlvbihpbWFnZVdyYXBwZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCwgc3JjRGF0YSA9IHRoaXMuZGF0YSwgZHN0RGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGRzdERhdGFbbGVuZ3RoXSA9IHNyY0RhdGFbbGVuZ3RoXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGZyb20gdGhlIGltYWdlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1wb3NpdGlvblxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIHktcG9zaXRpb25cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIHBpeGVsLXBvc2l0aW9uXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGZyb20gdGhlIGltYWdlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1wb3NpdGlvblxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIHktcG9zaXRpb25cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIHBpeGVsLXBvc2l0aW9uXG4gKi9cbkltYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0U2FmZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgaTtcblxuICAgIGlmICghdGhpcy5pbmRleE1hcHBpbmcpIHtcbiAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgIHk6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4TWFwcGluZy54W2ldID0gaTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnhbaSArIHRoaXMuc2l6ZS54XSA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2l6ZS55OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueVtpICsgdGhpcy5zaXplLnldID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhWyh0aGlzLmluZGV4TWFwcGluZy55W3kgKyB0aGlzLnNpemUueV0pICogdGhpcy5zaXplLnggKyB0aGlzLmluZGV4TWFwcGluZy54W3ggKyB0aGlzLnNpemUueF1dO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlXG4gKiBAcGFyYW0geCB7TnVtYmVyfSBUaGUgeC1wb3NpdGlvblxuICogQHBhcmFtIHkge051bWJlcn0gVGhlIHktcG9zaXRpb25cbiAqIEBwYXJhbSB2YWx1ZSB7TnVtYmVyfSBUaGUgZ3JheXNjYWxlIHZhbHVlIHRvIHNldFxuICogQHJldHVybnMge0ltYWdlV3JhcHBlcn0gVGhlIEltYWdlIGl0c2VsZiAoZm9yIHBvc3NpYmxlIGNoYWluaW5nKVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgdGhpcy5kYXRhW3kgKiB0aGlzLnNpemUueCArIHhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGJvcmRlciBvZiB0aGUgaW1hZ2UgKDEgcGl4ZWwpIHRvIHplcm9cbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS56ZXJvQm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGksIHdpZHRoID0gdGhpcy5zaXplLngsIGhlaWdodCA9IHRoaXMuc2l6ZS55LCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGZvciAoIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVsoaGVpZ2h0IC0gMSkgKiB3aWR0aCArIGldID0gMDtcbiAgICB9XG4gICAgZm9yICggaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgZGF0YVtpICogd2lkdGhdID0gZGF0YVtpICogd2lkdGggKyAod2lkdGggLSAxKV0gPSAwO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIGJpbmFyeSBpbWFnZSBpbiBwbGFjZVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLCBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBkYXRhW2xlbmd0aF0gPSBkYXRhW2xlbmd0aF0gPyAwIDogMTtcbiAgICB9XG59O1xuXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLmNvbnZvbHZlID0gZnVuY3Rpb24oa2VybmVsKSB7XG4gICAgdmFyIHgsIHksIGt4LCBreSwga1NpemUgPSAoa2VybmVsLmxlbmd0aCAvIDIpIHwgMCwgYWNjdSA9IDA7XG4gICAgZm9yICggeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgIGZvciAoIHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgYWNjdSA9IDA7XG4gICAgICAgICAgICBmb3IgKCBreSA9IC1rU2l6ZTsga3kgPD0ga1NpemU7IGt5KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKCBreCA9IC1rU2l6ZTsga3ggPD0ga1NpemU7IGt4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjdSArPSBrZXJuZWxba3kgKyBrU2l6ZV1ba3ggKyBrU2l6ZV0gKiB0aGlzLmdldFNhZmUoeCArIGt4LCB5ICsga3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGF0YVt5ICogdGhpcy5zaXplLnggKyB4XSA9IGFjY3U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLm1vbWVudHMgPSBmdW5jdGlvbihsYWJlbGNvdW50KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGhlaWdodCA9IHRoaXMuc2l6ZS55LFxuICAgICAgICB3aWR0aCA9IHRoaXMuc2l6ZS54LFxuICAgICAgICB2YWwsXG4gICAgICAgIHlzcSxcbiAgICAgICAgbGFiZWxzdW0gPSBbXSxcbiAgICAgICAgaSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIG11MTEsXG4gICAgICAgIG11MDIsXG4gICAgICAgIG11MjAsXG4gICAgICAgIHhfLFxuICAgICAgICB5XyxcbiAgICAgICAgdG1wLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgUEkgPSBNYXRoLlBJLFxuICAgICAgICBQSV80ID0gUEkgLyA0O1xuXG4gICAgaWYgKGxhYmVsY291bnQgPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoIGkgPSAwOyBpIDwgbGFiZWxjb3VudDsgaSsrKSB7XG4gICAgICAgIGxhYmVsc3VtW2ldID0ge1xuICAgICAgICAgICAgbTAwOiAwLFxuICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgbTEwOiAwLFxuICAgICAgICAgICAgbTExOiAwLFxuICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgbTIwOiAwLFxuICAgICAgICAgICAgdGhldGE6IDAsXG4gICAgICAgICAgICByYWQ6IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHlzcSA9IHkgKiB5O1xuICAgICAgICBmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHZhbCA9IGRhdGFbeSAqIHdpZHRoICsgeF07XG4gICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxzdW1bdmFsIC0gMV07XG4gICAgICAgICAgICAgICAgbGFiZWwubTAwICs9IDE7XG4gICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgbGFiZWwubTEwICs9IHg7XG4gICAgICAgICAgICAgICAgbGFiZWwubTExICs9IHggKiB5O1xuICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgbGFiZWwubTIwICs9IHggKiB4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggaSA9IDA7IGkgPCBsYWJlbGNvdW50OyBpKyspIHtcbiAgICAgICAgbGFiZWwgPSBsYWJlbHN1bVtpXTtcbiAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgeF8gPSBsYWJlbC5tMTAgLyBsYWJlbC5tMDA7XG4gICAgICAgICAgICB5XyA9IGxhYmVsLm0wMSAvIGxhYmVsLm0wMDtcbiAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgbXUwMiA9IGxhYmVsLm0wMiAvIGxhYmVsLm0wMCAtIHlfICogeV87XG4gICAgICAgICAgICBtdTIwID0gbGFiZWwubTIwIC8gbGFiZWwubTAwIC0geF8gKiB4XztcbiAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgdG1wID0gMC41ICogTWF0aC5hdGFuKHRtcCkgKyAobXUxMSA+PSAwID8gUElfNCA6IC1QSV80ICkgKyBQSTtcbiAgICAgICAgICAgIGxhYmVsLnRoZXRhID0gKHRtcCAqIDE4MCAvIFBJICsgOTApICUgMTgwIC0gOTA7XG4gICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgKz0gMTgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgIGxhYmVsLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKHRtcCksIE1hdGguc2luKHRtcCldKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSB7SW1hZ2VXcmFwcGVyfSBpbiBhIGdpdmVuIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgdG8gd3JpdGUgdG9cbiAqIEBwYXJhbSBzY2FsZSB7TnVtYmVyfSBTY2FsZSB3aGljaCBpcyBhcHBsaWVkIHRvIGVhY2ggcGl4ZWwtdmFsdWVcbiAqL1xuSW1hZ2VXcmFwcGVyLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oY2FudmFzLCBzY2FsZSkge1xuICAgIHZhciBjdHgsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBwaXhlbCxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGlmICghc2NhbGUpIHtcbiAgICAgICAgc2NhbGUgPSAxLjA7XG4gICAgfVxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBkYXRhID0gZnJhbWUuZGF0YTtcbiAgICBjdXJyZW50ID0gMDtcbiAgICBmb3IgKHkgPSAwOyB5IDwgdGhpcy5zaXplLnk7IHkrKykge1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgcGl4ZWwgPSB5ICogdGhpcy5zaXplLnggKyB4O1xuICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuZ2V0KHgsIHkpICogc2NhbGU7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDBdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMV0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAyXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDNdID0gMjU1O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vZnJhbWUuZGF0YSA9IGRhdGE7XG4gICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgMCwgMCk7XG59O1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSB7U3ViSW1hZ2V9IGluIGEgZ2l2ZW4gY2FudmFzXG4gKiBAcGFyYW0gY2FudmFzIHtDYW52YXN9IFRoZSBjYW52YXMgZWxlbWVudCB0byB3cml0ZSB0b1xuICogQHBhcmFtIHNjYWxlIHtOdW1iZXJ9IFNjYWxlIHdoaWNoIGlzIGFwcGxpZWQgdG8gZWFjaCBwaXhlbC12YWx1ZVxuICovXG5JbWFnZVdyYXBwZXIucHJvdG90eXBlLm92ZXJsYXkgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlLCBmcm9tKSB7XG4gICAgaWYgKCFzY2FsZSB8fCBzY2FsZSA8IDAgfHwgc2NhbGUgPiAzNjApIHtcbiAgICAgICAgc2NhbGUgPSAzNjA7XG4gICAgfVxuICAgIHZhciBoc3YgPSBbMCwgMSwgMV07XG4gICAgdmFyIHJnYiA9IFswLCAwLCAwXTtcbiAgICB2YXIgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgdmFyIGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGZyYW1lID0gY3R4LmdldEltYWdlRGF0YShmcm9tLngsIGZyb20ueSwgdGhpcy5zaXplLngsIHRoaXMuc2l6ZS55KTtcbiAgICB2YXIgZGF0YSA9IGZyYW1lLmRhdGE7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGhzdlswXSA9IHRoaXMuZGF0YVtsZW5ndGhdICogc2NhbGU7XG4gICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgZGF0YVtsZW5ndGggKiA0ICsgMF0gPSByZXN1bHRbMF07XG4gICAgICAgIGRhdGFbbGVuZ3RoICogNCArIDFdID0gcmVzdWx0WzFdO1xuICAgICAgICBkYXRhW2xlbmd0aCAqIDQgKyAyXSA9IHJlc3VsdFsyXTtcbiAgICAgICAgZGF0YVtsZW5ndGggKiA0ICsgM10gPSAyNTU7XG4gICAgfVxuICAgIGN0eC5wdXRJbWFnZURhdGEoZnJhbWUsIGZyb20ueCwgZnJvbS55KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlV3JhcHBlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci5qcyIsInZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3RvS2V5LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2lzRnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNMZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNTeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9tZXJnZS5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xudmFyIFRyYWNlciA9IHtcbiAgICBzZWFyY2hEaXJlY3Rpb25zOiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dLFxuICAgIGNyZWF0ZTogZnVuY3Rpb24oaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhLFxuICAgICAgICAgICAgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb25zID0gdGhpcy5zZWFyY2hEaXJlY3Rpb25zLFxuICAgICAgICAgICAgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54LFxuICAgICAgICAgICAgcG9zO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIHg7XG5cbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnJlbnQuY3kgKyBzZWFyY2hEaXJlY3Rpb25zW2N1cnJlbnQuZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC5jeCArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzFdO1xuICAgICAgICAgICAgICAgIHBvcyA9IHkgKiB3aWR0aCArIHg7XG4gICAgICAgICAgICAgICAgaWYgKChpbWFnZURhdGFbcG9zXSA9PT0gY29sb3IpICYmICgobGFiZWxEYXRhW3Bvc10gPT09IDApIHx8IChsYWJlbERhdGFbcG9zXSA9PT0gbGFiZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5jeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRhW3Bvc10gPSBlZGdlbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmVydGV4MkQoeCwgeSwgZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpcjogZGlyLFxuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXY6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICB2YXIgRnYgPSBudWxsLFxuICAgICAgICAgICAgICAgIEN2LFxuICAgICAgICAgICAgICAgIFAsXG4gICAgICAgICAgICAgICAgbGRpcixcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBjeDogc3gsXG4gICAgICAgICAgICAgICAgICAgIGN5OiBzeSxcbiAgICAgICAgICAgICAgICAgICAgZGlyOiAwXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSkge1xuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcbiAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnggPSBjdXJyZW50LmN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQuY3ggIT09IHN4IHx8IGN1cnJlbnQuY3kgIT09IHN5KTtcbiAgICAgICAgICAgICAgICBGdi5wcmV2ID0gQ3YucHJldjtcbiAgICAgICAgICAgICAgICBDdi5wcmV2Lm5leHQgPSBGdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZTogZnVuY3Rpb24oY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2UoY3VycmVudCwgY29sb3IsIGxhYmVsLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRvdXJUcmFjaW5nOiBmdW5jdGlvbihzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRvdXJUcmFjaW5nKHN5LCBzeCwgbGFiZWwsIGNvbG9yLCBlZGdlbGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmZ1bmN0aW9uIENvZGUzOVJlYWRlcigpIHtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIEFMUEhBQkVUSF9TVFJJTkc6IHt2YWx1ZTogXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAqJC8rJVwifSxcbiAgICBBTFBIQUJFVDoge3ZhbHVlOiBbNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDY1LCA2NiwgNjcsIDY4LCA2OSwgNzAsIDcxLCA3MiwgNzMsIDc0LCA3NSwgNzYsIDc3LCA3OCxcbiAgICAgICAgNzksIDgwLCA4MSwgODIsIDgzLCA4NCwgODUsIDg2LCA4NywgODgsIDg5LCA5MCwgNDUsIDQ2LCAzMiwgNDIsIDM2LCA0NywgNDMsIDM3XX0sXG4gICAgQ0hBUkFDVEVSX0VOQ09ESU5HUzoge3ZhbHVlOiBbMHgwMzQsIDB4MTIxLCAweDA2MSwgMHgxNjAsIDB4MDMxLCAweDEzMCwgMHgwNzAsIDB4MDI1LCAweDEyNCwgMHgwNjQsIDB4MTA5LCAweDA0OSxcbiAgICAgICAgMHgxNDgsIDB4MDE5LCAweDExOCwgMHgwNTgsIDB4MDBELCAweDEwQywgMHgwNEMsIDB4MDFDLCAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsXG4gICAgICAgIDB4MDQ2LCAweDAxNiwgMHgxODEsIDB4MEMxLCAweDFDMCwgMHgwOTEsIDB4MTkwLCAweDBEMCwgMHgwODUsIDB4MTg0LCAweDBDNCwgMHgwOTQsIDB4MEE4LCAweDBBMiwgMHgwOEEsIDB4MDJBXG4gICAgXX0sXG4gICAgQVNURVJJU0s6IHt2YWx1ZTogMHgwOTR9LFxuICAgIEZPUk1BVDoge3ZhbHVlOiBcImNvZGVfMzlcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RlMzlSZWFkZXI7XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX2RlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY291bnRlcnMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBzdGFydCA9IHNlbGYuX2ZpbmRTdGFydCgpLFxuICAgICAgICBkZWNvZGVkQ2hhcixcbiAgICAgICAgbGFzdFN0YXJ0LFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBuZXh0U3RhcnQ7XG5cbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBuZXh0U3RhcnQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdywgc3RhcnQuZW5kKTtcblxuICAgIGRvIHtcbiAgICAgICAgY291bnRlcnMgPSBzZWxmLl90b0NvdW50ZXJzKG5leHRTdGFydCwgY291bnRlcnMpO1xuICAgICAgICBwYXR0ZXJuID0gc2VsZi5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ2hhciA9IHNlbGYuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgIGlmIChkZWNvZGVkQ2hhciA8IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICBuZXh0U3RhcnQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdywgbmV4dFN0YXJ0KTtcbiAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICByZXN1bHQucG9wKCk7XG5cbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UobGFzdFN0YXJ0LCBuZXh0U3RhcnQsIGNvdW50ZXJzKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICBlbmQ6IG5leHRTdGFydCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHRcbiAgICB9O1xufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24obGFzdFN0YXJ0LCBuZXh0U3RhcnQsIGNvdW50ZXJzKSB7XG4gICAgdmFyIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCxcbiAgICAgICAgcGF0dGVyblNpemUgPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gcGF0dGVyblNpemU7XG4gICAgaWYgKCh0cmFpbGluZ1doaXRlc3BhY2VFbmQgKiAzKSA+PSBwYXR0ZXJuU2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fcGF0dGVyblRvQ2hhciA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLkNIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHNlbGYuQUxQSEFCRVRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbkNvZGUzOVJlYWRlci5wcm90b3R5cGUuX2ZpbmROZXh0V2lkdGggPSBmdW5jdGlvbihjb3VudGVycywgY3VycmVudCkge1xuICAgIHZhciBpLFxuICAgICAgICBtaW5XaWR0aCA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNvdW50ZXJzW2ldIDwgbWluV2lkdGggJiYgY291bnRlcnNbaV0gPiBjdXJyZW50KSB7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbldpZHRoO1xufTtcblxuQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fdG9QYXR0ZXJuID0gZnVuY3Rpb24oY291bnRlcnMpIHtcbiAgICB2YXIgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGgsXG4gICAgICAgIG1heE5hcnJvd1dpZHRoID0gMCxcbiAgICAgICAgbnVtV2lkZUJhcnMgPSBudW1Db3VudGVycyxcbiAgICAgICAgd2lkZUJhcldpZHRoID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGk7XG5cbiAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XG4gICAgICAgIG1heE5hcnJvd1dpZHRoID0gc2VsZi5fZmluZE5leHRXaWR0aChjb3VudGVycywgbWF4TmFycm93V2lkdGgpO1xuICAgICAgICBudW1XaWRlQmFycyA9IDA7XG4gICAgICAgIHBhdHRlcm4gPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xuICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XG4gICAgICAgICAgICAgICAgd2lkZUJhcldpZHRoICs9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG51bVdpZGVCYXJzID09PSAzKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPiBtYXhOYXJyb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBudW1XaWRlQmFycy0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RlMzlSZWFkZXIucHJvdG90eXBlLl9maW5kU3RhcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KSxcbiAgICAgICAgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0LFxuICAgICAgICBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBjb3VudGVyUG9zID0gMCxcbiAgICAgICAgaXNXaGl0ZSA9IGZhbHNlLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICB3aGl0ZVNwYWNlTXVzdFN0YXJ0O1xuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgcGF0dGVyblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl90b1BhdHRlcm4oY291bnRlcikgPT09IHNlbGYuQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVTcGFjZU11c3RTdGFydCA9IE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgcGF0dGVyblN0YXJ0IC0gKChpIC0gcGF0dGVyblN0YXJ0KSAvIDQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHBhdHRlcm5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlclswXSArIGNvdW50ZXJbMV07XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyWzhdID0gMDtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5UmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzM5X3JlYWRlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gZG90XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzIvZG90LmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fTWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fTWFwQ2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXNzaWduVmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldFByb3RvdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19vdmVyUmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBrZXkgPT0gJ19fcHJvdG9fXydcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3NhZmVHZXQuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zZXRUb1N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaWRlbnRpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzSW4gPSByZXF1aXJlKCcuL19iYXNlS2V5c0luJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gva2V5c0luLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBUeXBlRGVmcyBmcm9tICcuL2NvbW1vbi90eXBlZGVmcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi9kZWNvZGVyL2JhcmNvZGVfZGVjb2Rlcic7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vY29tbW9uL2V2ZW50cyc7XG5pbXBvcnQgQ2FtZXJhQWNjZXNzIGZyb20gJy4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmVzdWx0Q29sbGVjdG9yIGZyb20gJy4vYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3InO1xuaW1wb3J0IENvbmZpZyBmcm9tICcuL2NvbmZpZy9jb25maWcnO1xuaW1wb3J0IElucHV0U3RyZWFtIGZyb20gJ2lucHV0X3N0cmVhbSc7XG5pbXBvcnQgRnJhbWVHcmFiYmVyIGZyb20gJ2ZyYW1lX2dyYWJiZXInO1xuaW1wb3J0IHttZXJnZX0gZnJvbSAnbG9kYXNoJztcbmNvbnN0IHZlYzIgPSB7XG4gICAgY2xvbmU6IHJlcXVpcmUoJ2dsLXZlYzIvY2xvbmUnKVxufTtcblxudmFyIF9pbnB1dFN0cmVhbSxcbiAgICBfZnJhbWVncmFiYmVyLFxuICAgIF9zdG9wcGVkLFxuICAgIF9jYW52YXNDb250YWluZXIgPSB7XG4gICAgICAgIGN0eDoge1xuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGRvbToge1xuICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9pbnB1dEltYWdlV3JhcHBlcixcbiAgICBfYm94U2l6ZSxcbiAgICBfZGVjb2RlcixcbiAgICBfd29ya2VyUG9vbCA9IFtdLFxuICAgIF9vblVJVGhyZWFkID0gdHJ1ZSxcbiAgICBfcmVzdWx0Q29sbGVjdG9yLFxuICAgIF9jb25maWcgPSB7fTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKSB7XG4gICAgaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKTtcbiAgICBfZGVjb2RlciA9IEJhcmNvZGVEZWNvZGVyLmNyZWF0ZShfY29uZmlnLmRlY29kZXIsIF9pbnB1dEltYWdlV3JhcHBlcik7XG59XG5cbmZ1bmN0aW9uIGluaXRJbnB1dFN0cmVhbShjYikge1xuICAgIHZhciB2aWRlbztcbiAgICBpZiAoX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIlZpZGVvU3RyZWFtXCIpIHtcbiAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgIF9pbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtLmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICB9IGVsc2UgaWYgKF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJJbWFnZVN0cmVhbVwiKSB7XG4gICAgICAgIF9pbnB1dFN0cmVhbSA9IElucHV0U3RyZWFtLmNyZWF0ZUltYWdlU3RyZWFtKCk7XG4gICAgfSBlbHNlIGlmIChfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiTGl2ZVN0cmVhbVwiKSB7XG4gICAgICAgIHZhciAkdmlld3BvcnQgPSBnZXRWaWV3UG9ydCgpO1xuICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICB2aWRlbyA9ICR2aWV3cG9ydC5xdWVyeVNlbGVjdG9yKFwidmlkZW9cIik7XG4gICAgICAgICAgICBpZiAoIXZpZGVvKSB7XG4gICAgICAgICAgICAgICAgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfaW5wdXRTdHJlYW0gPSBJbnB1dFN0cmVhbS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgQ2FtZXJhQWNjZXNzLnJlcXVlc3QodmlkZW8sIF9jb25maWcuaW5wdXRTdHJlYW0uY29uc3RyYWludHMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIF9pbnB1dFN0cmVhbS50cmlnZ2VyKFwiY2FucmVjb3JkXCIpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2lucHV0U3RyZWFtLnNldEF0dHJpYnV0ZShcInByZWxvYWRcIiwgXCJhdXRvXCIpO1xuICAgIF9pbnB1dFN0cmVhbS5zZXRJbnB1dFN0cmVhbShfY29uZmlnLmlucHV0U3RyZWFtKTtcbiAgICBfaW5wdXRTdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcihcImNhbnJlY29yZFwiLCBjYW5SZWNvcmQuYmluZCh1bmRlZmluZWQsIGNiKSk7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdQb3J0KCkge1xuICAgIHZhciB0YXJnZXQgPSBfY29uZmlnLmlucHV0U3RyZWFtLnRhcmdldDtcbiAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlICcjaW50ZXJhY3RpdmUudmlld3BvcnQnIGFzIGEgZmFsbGJhY2sgc2VsZWN0b3IgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KVxuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICcjaW50ZXJhY3RpdmUudmlld3BvcnQnO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW5SZWNvcmQoY2IpIHtcbiAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHMoX2lucHV0U3RyZWFtLCBfY29uZmlnLmxvY2F0b3IpO1xuICAgIGluaXRDYW52YXMoX2NvbmZpZyk7XG4gICAgX2ZyYW1lZ3JhYmJlciA9IEZyYW1lR3JhYmJlci5jcmVhdGUoX2lucHV0U3RyZWFtLCBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSk7XG5cbiAgICBhZGp1c3RXb3JrZXJQb29sKF9jb25maWcubnVtT2ZXb3JrZXJzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKF9jb25maWcubnVtT2ZXb3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsaXplRGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlYWR5KGNiKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZHkoY2Ipe1xuICAgIF9pbnB1dFN0cmVhbS5wbGF5KCk7XG4gICAgY2IoKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciAkdmlld3BvcnQgPSBnZXRWaWV3UG9ydCgpO1xuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuaW1nQnVmZmVyXCIpO1xuICAgICAgICBpZiAoIV9jYW52YXNDb250YWluZXIuZG9tLmltYWdlKSB7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5jbGFzc05hbWUgPSBcImltZ0J1ZmZlclwiO1xuICAgICAgICAgICAgaWYgKCR2aWV3cG9ydCAmJiBfY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09IFwiSW1hZ2VTdHJlYW1cIikge1xuICAgICAgICAgICAgICAgICR2aWV3cG9ydC5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5jdHguaW1hZ2UgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLmltYWdlLndpZHRoID0gX2lucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKS54O1xuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZS5oZWlnaHQgPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLnk7XG5cbiAgICAgICAgX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXMuZHJhd2luZ0J1ZmZlclwiKTtcbiAgICAgICAgaWYgKCFfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5KSB7XG4gICAgICAgICAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkuY2xhc3NOYW1lID0gXCJkcmF3aW5nQnVmZmVyXCI7XG4gICAgICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsZWFyRml4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgICAgICAgY2xlYXJGaXguc2V0QXR0cmlidXRlKFwiY2xlYXJcIiwgXCJhbGxcIik7XG4gICAgICAgICAgICBpZiAoJHZpZXdwb3J0KSB7XG4gICAgICAgICAgICAgICAgJHZpZXdwb3J0LmFwcGVuZENoaWxkKGNsZWFyRml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5vdmVybGF5ID0gX2NhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkud2lkdGggPSBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLng7XG4gICAgICAgIF9jYW52YXNDb250YWluZXIuZG9tLm92ZXJsYXkuaGVpZ2h0ID0gX2lucHV0U3RyZWFtLmdldENhbnZhc1NpemUoKS55O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoaW1hZ2VXcmFwcGVyKSB7XG4gICAgaWYgKGltYWdlV3JhcHBlcikge1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbWFnZVdyYXBwZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2lucHV0SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICB4OiBfaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHk6IF9pbnB1dFN0cmVhbS5nZXRIZWlnaHQoKVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKF9pbnB1dEltYWdlV3JhcHBlci5zaXplKTtcbiAgICB9XG4gICAgX2JveFNpemUgPSBbXG4gICAgICAgIHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgdmVjMi5jbG9uZShbMCwgX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICB2ZWMyLmNsb25lKFtfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55XSksXG4gICAgICAgIHZlYzIuY2xvbmUoW19pbnB1dEltYWdlV3JhcHBlci5zaXplLngsIDBdKVxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChfaW5wdXRJbWFnZVdyYXBwZXIsIF9jb25maWcubG9jYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94ZXMoKSB7XG4gICAgaWYgKF9jb25maWcubG9jYXRlKSB7XG4gICAgICAgIHJldHVybiBCYXJjb2RlTG9jYXRvci5sb2NhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1tcbiAgICAgICAgICAgIHZlYzIuY2xvbmUoX2JveFNpemVbMF0pLFxuICAgICAgICAgICAgdmVjMi5jbG9uZShfYm94U2l6ZVsxXSksXG4gICAgICAgICAgICB2ZWMyLmNsb25lKF9ib3hTaXplWzJdKSxcbiAgICAgICAgICAgIHZlYzIuY2xvbmUoX2JveFNpemVbM10pXV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0KSB7XG4gICAgdmFyIHRvcFJpZ2h0ID0gX2lucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCksXG4gICAgICAgIHhPZmZzZXQgPSB0b3BSaWdodC54LFxuICAgICAgICB5T2Zmc2V0ID0gdG9wUmlnaHQueSxcbiAgICAgICAgaTtcblxuICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5iYXJjb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNmb3JtUmVzdWx0KHJlc3VsdC5iYXJjb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmxpbmUgJiYgcmVzdWx0LmxpbmUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG1vdmVMaW5lKHJlc3VsdC5saW5lKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmJveCkge1xuICAgICAgICBtb3ZlQm94KHJlc3VsdC5ib3gpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYm94ZXMgJiYgcmVzdWx0LmJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbW92ZUJveChyZXN1bHQuYm94ZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZUJveChib3gpIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGJveC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGNvcm5lci0tKSB7XG4gICAgICAgICAgICBib3hbY29ybmVyXVswXSArPSB4T2Zmc2V0O1xuICAgICAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmVMaW5lKGxpbmUpIHtcbiAgICAgICAgbGluZVswXS54ICs9IHhPZmZzZXQ7XG4gICAgICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgICAgICBsaW5lWzFdLnggKz0geE9mZnNldDtcbiAgICAgICAgbGluZVsxXS55ICs9IHlPZmZzZXQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRSZXN1bHQgKHJlc3VsdCwgaW1hZ2VEYXRhKSB7XG4gICAgaWYgKCFpbWFnZURhdGEgfHwgIV9yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgcmVzdWx0LmJhcmNvZGVzLmZpbHRlcihiYXJjb2RlID0+IGJhcmNvZGUuY29kZVJlc3VsdClcbiAgICAgICAgICAgIC5mb3JFYWNoKGJhcmNvZGUgPT4gYWRkUmVzdWx0KGJhcmNvZGUsIGltYWdlRGF0YSkpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgX3Jlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQoaW1hZ2VEYXRhLCBfaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLCByZXN1bHQuY29kZVJlc3VsdCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb2RlUmVzdWx0IChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ICYmIChyZXN1bHQuYmFyY29kZXMgP1xuICAgICAgcmVzdWx0LmJhcmNvZGVzLnNvbWUoYmFyY29kZSA9PiBiYXJjb2RlLmNvZGVSZXN1bHQpIDpcbiAgICAgIHJlc3VsdC5jb2RlUmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlc3VsdChyZXN1bHQsIGltYWdlRGF0YSkge1xuICAgIGxldCByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQ7XG5cbiAgICBpZiAocmVzdWx0ICYmIF9vblVJVGhyZWFkKSB7XG4gICAgICAgIHRyYW5zZm9ybVJlc3VsdChyZXN1bHQpO1xuICAgICAgICBhZGRSZXN1bHQocmVzdWx0LCBpbWFnZURhdGEpO1xuICAgICAgICByZXN1bHRUb1B1Ymxpc2ggPSByZXN1bHQuYmFyY29kZXMgfHwgcmVzdWx0O1xuICAgIH1cblxuICAgIEV2ZW50cy5wdWJsaXNoKFwicHJvY2Vzc2VkXCIsIHJlc3VsdFRvUHVibGlzaCk7XG4gICAgaWYgKGhhc0NvZGVSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBFdmVudHMucHVibGlzaChcImRldGVjdGVkXCIsIHJlc3VsdFRvUHVibGlzaCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhdGVBbmREZWNvZGUoKSB7XG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgYm94ZXM7XG5cbiAgICBib3hlcyA9IGdldEJvdW5kaW5nQm94ZXMoKTtcbiAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgcmVzdWx0ID0gX2RlY29kZXIuZGVjb2RlRnJvbUJvdW5kaW5nQm94ZXMoYm94ZXMpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gICAgICAgIHJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICBwdWJsaXNoUmVzdWx0KHJlc3VsdCwgX2lucHV0SW1hZ2VXcmFwcGVyLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHB1Ymxpc2hSZXN1bHQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgYXZhaWxhYmxlV29ya2VyO1xuXG4gICAgaWYgKF9vblVJVGhyZWFkKSB7XG4gICAgICAgIGlmIChfd29ya2VyUG9vbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIgPSBfd29ya2VyUG9vbC5maWx0ZXIoZnVuY3Rpb24od29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF3b3JrZXJUaHJlYWQuYnVzeTtcbiAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZVdvcmtlcikge1xuICAgICAgICAgICAgICAgIF9mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YShhdmFpbGFibGVXb3JrZXIuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhbGwgd29ya2VycyBhcmUgYnVzeVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2ZyYW1lZ3JhYmJlci5hdHRhY2hEYXRhKF9pbnB1dEltYWdlV3JhcHBlci5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2ZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGFcbiAgICAgICAgICAgICAgICB9LCBbYXZhaWxhYmxlV29ya2VyLmltYWdlRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRlQW5kRGVjb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGVBbmREZWNvZGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpIHtcbiAgICB2YXIgbmV4dCA9IG51bGwsXG4gICAgICAgIGRlbGF5ID0gMTAwMCAvIChfY29uZmlnLmZyZXF1ZW5jeSB8fCA2MCk7XG5cbiAgICBfc3RvcHBlZCA9IGZhbHNlO1xuICAgIChmdW5jdGlvbiBmcmFtZSh0aW1lc3RhbXApIHtcbiAgICAgICAgbmV4dCA9IG5leHQgfHwgdGltZXN0YW1wO1xuICAgICAgICBpZiAoIV9zdG9wcGVkKSB7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltRnJhbWUoZnJhbWUpO1xuICAgICAgICB9XG4gICAgfShwZXJmb3JtYW5jZS5ub3coKSkpO1xufVxuXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgICBpZiAoX29uVUlUaHJlYWQgJiYgX2NvbmZpZy5pbnB1dFN0cmVhbS50eXBlID09PSBcIkxpdmVTdHJlYW1cIikge1xuICAgICAgICBzdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXb3JrZXIoY2IpIHtcbiAgICB2YXIgYmxvYlVSTCxcbiAgICAgICAgd29ya2VyVGhyZWFkID0ge1xuICAgICAgICAgICAgd29ya2VyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KF9pbnB1dFN0cmVhbS5nZXRXaWR0aCgpICogX2lucHV0U3RyZWFtLmdldEhlaWdodCgpKSxcbiAgICAgICAgICAgIGJ1c3k6IHRydWVcbiAgICAgICAgfTtcblxuICAgIGJsb2JVUkwgPSBnZW5lcmF0ZVdvcmtlckJsb2IoKTtcbiAgICB3b3JrZXJUaHJlYWQud29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kYXRhLmV2ZW50ID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGJsb2JVUkwpO1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLmJ1c3kgPSBmYWxzZTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIldvcmtlciBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYih3b3JrZXJUaHJlYWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ3Byb2Nlc3NlZCcpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5pbWFnZURhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICBwdWJsaXNoUmVzdWx0KGUuZGF0YS5yZXN1bHQsIHdvcmtlclRocmVhZC5pbWFnZURhdGEpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIGVycm9yOiBcIiArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHt4OiBfaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogX2lucHV0U3RyZWFtLmdldEhlaWdodCgpfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0ZvcldvcmtlcihfY29uZmlnKVxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5mdW5jdGlvbiBjb25maWdGb3JXb3JrZXIoY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICAgICAgLi4uY29uZmlnLmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGFyZ2V0OiBudWxsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3b3JrZXJJbnRlcmZhY2UoZmFjdG9yeSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmKi9cbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsnZXZlbnQnOiAnZXJyb3InLCBtZXNzYWdlOiAnUXVhZ2dhIGNvdWxkIG5vdCBiZSBjcmVhdGVkJ30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBpbWFnZVdyYXBwZXI7XG5cbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5jbWQgPT09ICdpbml0Jykge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IGUuZGF0YS5jb25maWc7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgICAgIGltYWdlV3JhcHBlciA9IG5ldyBRdWFnZ2EuSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgICAgICAgICB4OiBlLmRhdGEuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IGUuZGF0YS5zaXplLnlcbiAgICAgICAgICAgIH0sIG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIFF1YWdnYS5pbml0KGNvbmZpZywgcmVhZHksIGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBRdWFnZ2Eub25Qcm9jZXNzZWQob25Qcm9jZXNzZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdwcm9jZXNzJykge1xuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGEgPSBuZXcgVWludDhBcnJheShlLmRhdGEuaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIFF1YWdnYS5zdGFydCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS5jbWQgPT09ICdzZXRSZWFkZXJzJykge1xuICAgICAgICAgICAgUXVhZ2dhLnNldFJlYWRlcnMoZS5kYXRhLnJlYWRlcnMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0XG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkeSgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsnZXZlbnQnOiAnaW5pdGlhbGl6ZWQnLCBpbWFnZURhdGE6IGltYWdlV3JhcHBlci5kYXRhfSwgW2ltYWdlV3JhcHBlci5kYXRhLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVXb3JrZXJCbG9iKCkge1xuICAgIHZhciBibG9iLFxuICAgICAgICBmYWN0b3J5U291cmNlO1xuXG4gICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgIGlmICh0eXBlb2YgX19mYWN0b3J5U291cmNlX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZhY3RvcnlTb3VyY2UgPSBfX2ZhY3RvcnlTb3VyY2VfXzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgYmxvYiA9IG5ldyBCbG9iKFsnKCcgKyB3b3JrZXJJbnRlcmZhY2UudG9TdHJpbmcoKSArICcpKCcgKyBmYWN0b3J5U291cmNlICsgJyk7J10sXG4gICAgICAgIHt0eXBlOiAndGV4dC9qYXZhc2NyaXB0J30pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5mdW5jdGlvbiBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICBpZiAoX2RlY29kZXIpIHtcbiAgICAgICAgX2RlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICB9IGVsc2UgaWYgKF9vblVJVGhyZWFkICYmIF93b3JrZXJQb29sLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3dvcmtlclBvb2wuZm9yRWFjaChmdW5jdGlvbih3b3JrZXJUaHJlYWQpIHtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2Uoe2NtZDogJ3NldFJlYWRlcnMnLCByZWFkZXJzOiByZWFkZXJzfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eSwgY2IpIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSBfd29ya2VyUG9vbC5sZW5ndGg7XG4gICAgaWYgKGluY3JlYXNlQnkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfVxuICAgIGlmIChpbmNyZWFzZUJ5IDwgMCkge1xuICAgICAgICBjb25zdCB3b3JrZXJzVG9UZXJtaW5hdGUgPSBfd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24od29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2VyIHRlcm1pbmF0ZWQhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3dvcmtlclBvb2wgPSBfd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgcmV0dXJuIGNiICYmIGNiKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgIGluaXRXb3JrZXIod29ya2VySW5pdGlhbGl6ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gd29ya2VySW5pdGlhbGl6ZWQod29ya2VyVGhyZWFkKSB7XG4gICAgICAgICAgICBfd29ya2VyUG9vbC5wdXNoKHdvcmtlclRocmVhZCk7XG4gICAgICAgICAgICBpZiAoX3dvcmtlclBvb2wubGVuZ3RoID49IGNhcGFjaXR5KXtcbiAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnLCBjYiwgaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIF9jb25maWcgPSBtZXJnZSh7fSwgQ29uZmlnLCBjb25maWcpO1xuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBfb25VSVRocmVhZCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZURhdGEoaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGFydCgpO1xuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgYWRqdXN0V29ya2VyUG9vbCgwKTtcbiAgICAgICAgaWYgKF9jb25maWcuaW5wdXRTdHJlYW0udHlwZSA9PT0gXCJMaXZlU3RyZWFtXCIpIHtcbiAgICAgICAgICAgIENhbWVyYUFjY2Vzcy5yZWxlYXNlKCk7XG4gICAgICAgICAgICBfaW5wdXRTdHJlYW0uY2xlYXJFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgX3N0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZShcImRldGVjdGVkXCIsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIG9mZkRldGVjdGVkOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoXCJkZXRlY3RlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvblByb2Nlc3NlZDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZShcInByb2Nlc3NlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvZmZQcm9jZXNzZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIEV2ZW50cy51bnN1YnNjcmliZShcInByb2Nlc3NlZFwiLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbihyZWFkZXJzKSB7XG4gICAgICAgIHNldFJlYWRlcnMocmVhZGVycyk7XG4gICAgfSxcbiAgICByZWdpc3RlclJlc3VsdENvbGxlY3RvcjogZnVuY3Rpb24ocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9yZXN1bHRDb2xsZWN0b3IgPSByZXN1bHRDb2xsZWN0b3I7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNhbnZhczogX2NhbnZhc0NvbnRhaW5lcixcbiAgICBkZWNvZGVTaW5nbGU6IGZ1bmN0aW9uKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uZmlnID0gbWVyZ2Uoe1xuICAgICAgICAgICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkltYWdlU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNpemU6IDgwMCxcbiAgICAgICAgICAgICAgICBzcmM6IGNvbmZpZy5zcmNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuaW5pdChjb25maWcsICgpID0+IHtcbiAgICAgICAgICAgIEV2ZW50cy5vbmNlKFwicHJvY2Vzc2VkXCIsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICByZXN1bHRDYWxsYmFjay5jYWxsKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgIHN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgSW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIsXG4gICAgSW1hZ2VEZWJ1ZzogSW1hZ2VEZWJ1ZyxcbiAgICBSZXN1bHRDb2xsZWN0b3I6IFJlc3VsdENvbGxlY3RvcixcbiAgICBDYW1lcmFBY2Nlc3M6IENhbWVyYUFjY2Vzcyxcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcXVhZ2dhLmpzIiwiY29uc3QgQ1ZVdGlscyA9IHJlcXVpcmUoJy4uL3NyYy9jb21tb24vY3ZfdXRpbHMnKSxcbiAgICAgIE5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKSxcbiAgICAgIEludGVycDJEID0gcmVxdWlyZShcIm5kYXJyYXktbGluZWFyLWludGVycG9sYXRlXCIpLmQyO1xuXG52YXIgRnJhbWVHcmFiYmVyID0ge307XG5cbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbihpbnB1dFN0cmVhbSkge1xuICAgIHZhciBfdGhhdCA9IHt9LFxuICAgICAgICBfc3RyZWFtQ29uZmlnID0gaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCksXG4gICAgICAgIF92aWRlb19zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRSZWFsV2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0UmVhbEhlaWdodCgpKSxcbiAgICAgICAgX2NhbnZhc1NpemUgPSBpbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCksXG4gICAgICAgIF9zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIF90b3BSaWdodCA9IGlucHV0U3RyZWFtLmdldFRvcFJpZ2h0KCksXG4gICAgICAgIF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpLFxuICAgICAgICBfZ3JheURhdGEgPSBuZXcgVWludDhBcnJheShfdmlkZW9fc2l6ZS54ICogX3ZpZGVvX3NpemUueSksXG4gICAgICAgIF9jYW52YXNEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX2NhbnZhc1NpemUueCAqIF9jYW52YXNTaXplLnkpLFxuICAgICAgICBfZ3JheUltYWdlQXJyYXkgPSBOZGFycmF5KF9ncmF5RGF0YSwgW192aWRlb19zaXplLnksIF92aWRlb19zaXplLnhdKS50cmFuc3Bvc2UoMSwgMCksXG4gICAgICAgIF9jYW52YXNJbWFnZUFycmF5ID0gTmRhcnJheShfY2FudmFzRGF0YSwgW19jYW52YXNTaXplLnksIF9jYW52YXNTaXplLnhdKS50cmFuc3Bvc2UoMSwgMCksXG4gICAgICAgIF90YXJnZXRJbWFnZUFycmF5ID0gX2NhbnZhc0ltYWdlQXJyYXkuaGkoX3RvcFJpZ2h0LnggKyBfc2l6ZS54LCBfdG9wUmlnaHQueSArIF9zaXplLnkpLmxvKF90b3BSaWdodC54LCBfdG9wUmlnaHQueSksXG4gICAgICAgIF9zdGVwU2l6ZVggPSBfdmlkZW9fc2l6ZS54L19jYW52YXNTaXplLngsXG4gICAgICAgIF9zdGVwU2l6ZVkgPSBfdmlkZW9fc2l6ZS55L19jYW52YXNTaXplLnk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkZyYW1lR3JhYmJlclwiLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZpZGVvU2l6ZTogX2dyYXlJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzSW1hZ2VBcnJheS5zaGFwZSxcbiAgICAgICAgc3RlcFNpemU6IFtfc3RlcFNpemVYLCBfc3RlcFNpemVZXSxcbiAgICAgICAgc2l6ZTogX3RhcmdldEltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgIHRvcFJpZ2h0OiBfdG9wUmlnaHRcbiAgICB9KSk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBnaXZlbiBhcnJheSBhcyBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5hdHRhY2hEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVBbmRDcm9wKGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF90aGF0LnNjYWxlQW5kQ3JvcCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIHZhciB4LFxuICAgICAgICAgICAgeTtcblxuICAgICAgICAvLyAxLiBjb21wdXRlIGZ1bGwtc2l6ZWQgZ3JheSBpbWFnZVxuICAgICAgICBDVlV0aWxzLmNvbXB1dGVHcmF5KGZyYW1lLmRhdGEsIF9ncmF5RGF0YSk7XG5cbiAgICAgICAgLy8gMi4gaW50ZXJwb2xhdGVcbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IF9jYW52YXNTaXplLnk7IHkrKykge1xuICAgICAgICAgICAgZm9yICh4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIF9jYW52YXNJbWFnZUFycmF5LnNldCh4LCB5LCAoSW50ZXJwMkQoX2dyYXlJbWFnZUFycmF5LCB4ICogX3N0ZXBTaXplWCwgeSAqIF9zdGVwU2l6ZVkpKSB8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGFyZ2V0SW1hZ2VBcnJheSBtdXN0IGJlIGVxdWFsIHRvIHRhcmdldFNpemVcbiAgICAgICAgaWYgKF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzBdICE9PSBfc2l6ZS54IHx8XG4gICAgICAgICAgICBfdGFyZ2V0SW1hZ2VBcnJheS5zaGFwZVsxXSAhPT0gX3NpemUueSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcGVzIGRvIG5vdCBtYXRjaCFcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBjcm9wXG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBfc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCBfc2l6ZS54OyB4KyspIHtcbiAgICAgICAgICAgICAgICBfZGF0YVt5ICogX3NpemUueCArIHhdID0gX3RhcmdldEltYWdlQXJyYXkuZ2V0KHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIF90aGF0LmdldFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lR3JhYmJlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2xpYi9mcmFtZV9ncmFiYmVyLmpzIiwiY29uc3QgR2V0UGl4ZWxzID0gcmVxdWlyZShcImdldC1waXhlbHNcIik7XG5cbnZhciBJbnB1dFN0cmVhbSA9IHt9O1xuXG5JbnB1dFN0cmVhbS5jcmVhdGVJbWFnZVN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0ge307XG4gICAgdmFyIF9jb25maWcgPSBudWxsO1xuXG4gICAgdmFyIHdpZHRoID0gMCxcbiAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgZnJhbWVJZHggPSAwLFxuICAgICAgICBwYXVzZWQgPSB0cnVlLFxuICAgICAgICBsb2FkZWQgPSBmYWxzZSxcbiAgICAgICAgZnJhbWUgPSBudWxsLFxuICAgICAgICBiYXNlVXJsLFxuICAgICAgICBlbmRlZCA9IGZhbHNlLFxuICAgICAgICBzaXplLFxuICAgICAgICBjYWxjdWxhdGVkV2lkdGgsXG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQsXG4gICAgICAgIF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXSxcbiAgICAgICAgX2V2ZW50SGFuZGxlcnMgPSB7fSxcbiAgICAgICAgX3RvcFJpZ2h0ID0ge3g6IDAsIHk6IDB9LFxuICAgICAgICBfY2FudmFzU2l6ZSA9IHt4OiAwLCB5OiAwfTtcblxuICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKSB7XG4gICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBHZXRQaXhlbHMoYmFzZVVybCwgX2NvbmZpZy5taW1lLCBmdW5jdGlvbihlcnIsIHBpeGVscykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgZXhpdCgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhwaXhlbHMuc2hhcGUpO1xuICAgICAgICAgICAgZnJhbWUgPSBwaXhlbHM7XG4gICAgICAgICAgICB3aWR0aCA9IHBpeGVscy5zaGFwZVswXTtcbiAgICAgICAgICAgIGhlaWdodCA9IHBpeGVscy5zaGFwZVsxXTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWcuc2l6ZSA/IHdpZHRoL2hlaWdodCA+IDEgPyBfY29uZmlnLnNpemUgOiBNYXRoLmZsb29yKCh3aWR0aC9oZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWcuc2l6ZSA/IHdpZHRoL2hlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQvd2lkdGgpICogX2NvbmZpZy5zaXplKSA6IF9jb25maWcuc2l6ZSA6IGhlaWdodDtcblxuICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBjYWxjdWxhdGVkSGVpZ2h0O1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudChcImNhbnJlY29yZFwiLCBbXSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICB2YXIgaixcbiAgICAgICAgICAgIGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB0aGF0LnRyaWdnZXIgPSBwdWJsaXNoRXZlbnQ7XG5cbiAgICB0aGF0LmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVkV2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgIH07XG5cbiAgICB0aGF0LnNldFdpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gd2lkdGg7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0UmVhbFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9O1xuXG4gICAgdGhhdC5nZXRSZWFsSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfTtcblxuICAgIHRoYXQuc2V0SW5wdXRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgX2NvbmZpZyA9IHN0cmVhbTtcbiAgICAgICAgYmFzZVVybCA9IF9jb25maWcuc3JjO1xuICAgICAgICBzaXplID0gMTtcbiAgICAgICAgbG9hZEltYWdlcygpO1xuICAgIH07XG5cbiAgICB0aGF0LmVuZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlbmRlZDtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgdGhhdC5nZXRDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgfTtcblxuICAgIHRoYXQucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhhdC5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGF0LnNldEN1cnJlbnRUaW1lID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICBmcmFtZUlkeCA9IHRpbWU7XG4gICAgfTtcblxuICAgIHRoYXQuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmKSB7XG4gICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghX2V2ZW50SGFuZGxlcnNbZXZlbnRdKSB7XG4gICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZXZlbnRIYW5kbGVyc1tldmVudF0ucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGF0LnNldFRvcFJpZ2h0ID0gZnVuY3Rpb24odG9wUmlnaHQpIHtcbiAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgfTtcblxuICAgIHRoYXQuZ2V0VG9wUmlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICB9O1xuXG4gICAgdGhhdC5zZXRDYW52YXNTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgICBfY2FudmFzU2l6ZS54ID0gc2l6ZS54O1xuICAgICAgICBfY2FudmFzU2l6ZS55ID0gc2l6ZS55O1xuICAgIH07XG5cbiAgICB0aGF0LmdldENhbnZhc1NpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgIH07XG5cbiAgICB0aGF0LmdldEZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghbG9hZGVkKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0U3RyZWFtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbGliL2lucHV0X3N0cmVhbS5qcyIsImltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGNvZGVSZXN1bHQsIGxpc3QpIHtcbiAgICBpZiAobGlzdCkge1xuICAgICAgICByZXR1cm4gbGlzdC5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbSkuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtW2tleV0gPT09IGNvZGVSZXN1bHRba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwYXNzZXNGaWx0ZXIoY29kZVJlc3VsdCwgZmlsdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlcihjb2RlUmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG4gICAgICAgICAgICByZXN1bHRzID0gW10sXG4gICAgICAgICAgICBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSB8fCAyMCxcbiAgICAgICAgICAgIGNhcHR1cmUgPSBjb25maWcuY2FwdHVyZSA9PT0gdHJ1ZTtcblxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0KVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc0ZpbHRlcihjb2RlUmVzdWx0LCBjb25maWcuZmlsdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRSZXN1bHQ6IGZ1bmN0aW9uKGRhdGEsIGltYWdlU2l6ZSwgY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQ29uc3RyYWludHMoY29kZVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FwYWNpdHktLTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvZGVSZXN1bHQgPSBjb2RlUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1hZ2VTaXplLng7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2VTaXplLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdJbWFnZShkYXRhLCBpbWFnZVNpemUsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZnJhbWUgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFJlc3VsdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYW5hbHl0aWNzL3Jlc3VsdF9jb2xsZWN0b3IuanMiLCJjb25zdCB2ZWMyID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMyL2Nsb25lJyksXG4gICAgZG90OiByZXF1aXJlKCdnbC12ZWMyL2RvdCcpXG59XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAgICAgKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKHBvaW50LCB0aHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdLFxuICAgICAgICAgICAgY2VudGVyID0ge1xuICAgICAgICAgICAgICAgIHJhZDogMCxcbiAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvaW50TWFwID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZChwb2ludFRvQWRkKSB7XG4gICAgICAgICAgICBwb2ludE1hcFtwb2ludFRvQWRkLmlkXSA9IHBvaW50VG9BZGQ7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludFRvQWRkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNlbnRlcigpIHtcbiAgICAgICAgICAgIHZhciBpLCBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHM6IGZ1bmN0aW9uKG90aGVyUG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjb3NpbmUgc2ltaWxhcml0eSB0byBjZW50ZXItYW5nbGVcbiAgICAgICAgICAgICAgICB2YXIgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KG90aGVyUG9pbnQucG9pbnQudmVjLCBjZW50ZXIudmVjKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQ6IGZ1bmN0aW9uKG5ld1BvaW50LCBpZCwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhZDogbmV3UG9pbnRbcHJvcGVydHldLFxuICAgICAgICAgICAgcG9pbnQ6IG5ld1BvaW50LFxuICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH07XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vY2x1c3Rlci5qcyIsImV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnRzID0ge307XG5cbiAgICBmdW5jdGlvbiBnZXRFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHNbZXZlbnROYW1lXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckV2ZW50cygpe1xuICAgICAgICBldmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZGF0YSkge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcblxuICAgICAgICBpZiAoIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBhc3luY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24uY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbGxiYWNrIHdhcyBub3Qgc3BlY2lmaWVkIG9uIG9wdGlvbnNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdldEV2ZW50KGV2ZW50KS5zdWJzY3JpYmVycy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCwgY2FsbGJhY2ssIGFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgYXN5bmMpO1xuICAgICAgICB9LFxuICAgICAgICBwdWJsaXNoOiBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGdldEV2ZW50KGV2ZW50TmFtZSksXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMgPSBldmVudC5zdWJzY3JpYmVycztcblxuICAgICAgICAgICAgLy8gUHVibGlzaCBvbmUtdGltZSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJzY3JpYmVycy5maWx0ZXIoZnVuY3Rpb24oc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXN1YnNjcmliZXIub25jZTtcbiAgICAgICAgICAgIH0pLmZvckVhY2goKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU3Vic2NyaXB0aW9uKHN1YnNjcmliZXIsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGVtIGZyb20gdGhlIHN1YnNjcmliZXJcbiAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uKHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXN1YnNjcmliZXIub25jZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlOiBmdW5jdGlvbihldmVudCwgY2FsbGJhY2ssIGFzeW5jKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUoZXZlbnQsIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgYXN5bmM6IGFzeW5jLFxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGV2ZW50O1xuXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzLmZpbHRlcihmdW5jdGlvbihzdWJzY3JpYmVyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNhbGxiYWNrICE9PSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vZXZlbnRzLmpzIiwiXG5leHBvcnQgZnVuY3Rpb24gZW51bWVyYXRlRGV2aWNlcygpIHtcbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICAgICAgICAgICAgJiYgdHlwZW9mIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2VudW1lcmF0ZURldmljZXMgaXMgbm90IGRlZmluZWQnKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKSB7XG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXNcbiAgICAgICAgICAgICYmIHR5cGVvZiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlc1xuICAgICAgICAgICAgLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2dldFVzZXJNZWRpYSBpcyBub3QgZGVmaW5lZCcpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLmpzIiwiLyoqXG4gKiBDb25zdHJ1Y3QgcmVwcmVzZW50aW5nIGEgcGFydCBvZiBhbm90aGVyIHtJbWFnZVdyYXBwZXJ9LiBTaGFyZXMgZGF0YVxuICogYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY2hpbGQuXG4gKiBAcGFyYW0gZnJvbSB7SW1hZ2VSZWZ9IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCB0aGUge1N1YkltYWdlfSBmcm9tLiAodG9wLWxlZnQgY29ybmVyKVxuICogQHBhcmFtIHNpemUge0ltYWdlUmVmfSBUaGUgc2l6ZSBvZiB0aGUgcmVzdWx0aW5nIGltYWdlXG4gKiBAcGFyYW0gSSB7SW1hZ2VXcmFwcGVyfSBUaGUge0ltYWdlV3JhcHBlcn0gdG8gc2hhcmUgZnJvbVxuICogQHJldHVybnMge1N1YkltYWdlfSBBIHNoYXJlZCBwYXJ0IG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICovXG5mdW5jdGlvbiBTdWJJbWFnZShmcm9tLCBzaXplLCBJKSB7XG4gICAgaWYgKCFJKSB7XG4gICAgICAgIEkgPSB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBJLmRhdGE7XG4gICAgdGhpcy5vcmlnaW5hbFNpemUgPSBJLnNpemU7XG4gICAgdGhpcy5JID0gSTtcblxuICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5cyB0aGUge1N1YkltYWdlfSBpbiBhIGdpdmVuIGNhbnZhc1xuICogQHBhcmFtIGNhbnZhcyB7Q2FudmFzfSBUaGUgY2FudmFzIGVsZW1lbnQgdG8gd3JpdGUgdG9cbiAqIEBwYXJhbSBzY2FsZSB7TnVtYmVyfSBTY2FsZSB3aGljaCBpcyBhcHBsaWVkIHRvIGVhY2ggcGl4ZWwtdmFsdWVcbiAqL1xuU3ViSW1hZ2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbihjYW52YXMsIHNjYWxlKSB7XG4gICAgdmFyIGN0eCxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHksXG4gICAgICAgIHgsXG4gICAgICAgIHBpeGVsO1xuXG4gICAgaWYgKCFzY2FsZSkge1xuICAgICAgICBzY2FsZSA9IDEuMDtcbiAgICB9XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY2FudmFzLndpZHRoID0gdGhpcy5zaXplLng7XG4gICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgIGZyYW1lID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGRhdGEgPSBmcmFtZS5kYXRhO1xuICAgIGN1cnJlbnQgPSAwO1xuICAgIGZvciAoeSA9IDA7IHkgPCB0aGlzLnNpemUueTsgeSsrKSB7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCB0aGlzLnNpemUueDsgeCsrKSB7XG4gICAgICAgICAgICBwaXhlbCA9IHkgKiB0aGlzLnNpemUueCArIHg7XG4gICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgZGF0YVtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICBkYXRhW3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgIGRhdGFbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJhbWUuZGF0YSA9IGRhdGE7XG4gICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgMCwgMCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIGdpdmVuIHBpeGVsIHBvc2l0aW9uIGZyb20gdGhlIHtTdWJJbWFnZX1cbiAqIEBwYXJhbSB4IHtOdW1iZXJ9IFRoZSB4LXBvc2l0aW9uXG4gKiBAcGFyYW0geSB7TnVtYmVyfSBUaGUgeS1wb3NpdGlvblxuICogQHJldHVybnMge051bWJlcn0gVGhlIGdyYXlzY2FsZSB2YWx1ZSBhdCB0aGUgcGl4ZWwtcG9zaXRpb25cbiAqL1xuU3ViSW1hZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhWyh0aGlzLmZyb20ueSArIHkpICogdGhpcy5vcmlnaW5hbFNpemUueCArIHRoaXMuZnJvbS54ICsgeF07XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHVuZGVybHlpbmcgZGF0YSBmcm9tIGEgZ2l2ZW4ge0ltYWdlV3JhcHBlcn1cbiAqIEBwYXJhbSBpbWFnZSB7SW1hZ2VXcmFwcGVyfSBUaGUgdXBkYXRlZCBpbWFnZVxuICovXG5TdWJJbWFnZS5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgdGhpcy5vcmlnaW5hbFNpemUgPSBpbWFnZS5zaXplO1xuICAgIHRoaXMuZGF0YSA9IGltYWdlLmRhdGE7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFyZWQgYXJlYVxuICogQHBhcmFtIGZyb20ge3gseX0gVGhlIG5ldyBsb2NhdGlvblxuICogQHJldHVybnMge1N1YkltYWdlfSByZXR1cm5zIHt0aGlzfSBmb3IgcG9zc2libGUgY2hhaW5pbmdcbiAqL1xuU3ViSW1hZ2UucHJvdG90eXBlLnVwZGF0ZUZyb20gPSBmdW5jdGlvbihmcm9tKSB7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChTdWJJbWFnZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tbW9uL3N1YkltYWdlLmpzIiwiLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgIH07XG4gICAgfSkoKTtcbn1cbk1hdGguaW11bCA9IE1hdGguaW11bCB8fCBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGFoID0gKGEgPj4+IDE2KSAmIDB4ZmZmZixcbiAgICAgICAgYWwgPSBhICYgMHhmZmZmLFxuICAgICAgICBiaCA9IChiID4+PiAxNikgJiAweGZmZmYsXG4gICAgICAgIGJsID0gYiAmIDB4ZmZmZjtcbiAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgLy8gdGhlIGZpbmFsIHwwIGNvbnZlcnRzIHRoZSB1bnNpZ25lZCB2YWx1ZSBpbnRvIGEgc2lnbmVkIHZhbHVlXG4gICAgcmV0dXJuICgoYWwgKiBibCkgKyAoKChhaCAqIGJsICsgYWwgKiBiaCkgPDwgMTYpID4+PiAwKSB8IDApO1xufTtcblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uKHRhcmdldCkgeyAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAobmV4dFNvdXJjZSAhPT0gbnVsbCkgeyAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21tb24vdHlwZWRlZnMuanMiLCJsZXQgY29uZmlnO1xuXG5pZiAoRU5WLmRldmVsb3BtZW50KXtcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5kZXYuanMnKTtcbn0gZWxzZSBpZiAoRU5WLm5vZGUpIHtcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZy5ub2RlLmpzJyk7XG59IGVsc2Uge1xuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnLnByb2QuanMnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uZmlnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy9jb25maWcuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbnB1dFN0cmVhbToge1xuICAgICAgICB0eXBlOiBcIkltYWdlU3RyZWFtXCIsXG4gICAgICAgIHNlcXVlbmNlOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICBhcmVhOiB7XG4gICAgICAgICAgICB0b3A6IFwiMCVcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjAlXCIsXG4gICAgICAgICAgICBsZWZ0OiBcIjAlXCIsXG4gICAgICAgICAgICBib3R0b206IFwiMCVcIlxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVDaGFubmVsOiBmYWxzZSAvLyB0cnVlOiBvbmx5IHRoZSByZWQgY29sb3ItY2hhbm5lbCBpcyByZWFkXG4gICAgfSxcbiAgICBsb2NhdGU6IHRydWUsXG4gICAgbnVtT2ZXb3JrZXJzOiAwLFxuICAgIGRlY29kZXI6IHtcbiAgICAgICAgcmVhZGVyczogW1xuICAgICAgICAgICAgJ2NvZGVfMTI4X3JlYWRlcidcbiAgICAgICAgXVxuICAgIH0sXG4gICAgbG9jYXRvcjoge1xuICAgICAgICBoYWxmU2FtcGxlOiB0cnVlLFxuICAgICAgICBwYXRjaFNpemU6IFwibWVkaXVtXCIgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbmZpZy9jb25maWcubm9kZS5qcyIsImltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgUXJDb2RlUmVhZGVyIGZyb20gJy4uL3JlYWRlci9xcl9jb2RlX3JlYWRlcic7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcbiAgICBxcl9jb2RlX3JlYWRlcjogUXJDb2RlUmVhZGVyXG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICB2YXIgX2NhbnZhcyA9IHtcbiAgICAgICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF9iYXJjb2RlUmVhZGVycyA9IFtdO1xuXG4gICAgICAgIGluaXRDYW52YXMoKTtcbiAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgaW5pdENvbmZpZygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGRlYnVnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNkZWJ1Zy5kZXRlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhcy5mcmVxdWVuY3lcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5LmNsYXNzTmFtZSA9IFwiZnJlcXVlbmN5XCI7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRkZWJ1Zy5hcHBlbmRDaGlsZChfY2FudmFzLmRvbS5mcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LmZyZXF1ZW5jeSA9IF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImNhbnZhcy5wYXR0ZXJuQnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmICghX2NhbnZhcy5kb20ucGF0dGVybikge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybi5jbGFzc05hbWUgPSBcInBhdHRlcm5CdWZmZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLm92ZXJsYXkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiY2FudmFzLmRyYXdpbmdCdWZmZXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKF9jYW52YXMuZG9tLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5jdHgub3ZlcmxheSA9IF9jYW52YXMuZG9tLm92ZXJsYXkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihyZWFkZXJDb25maWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uID0ge30sXG4gICAgICAgICAgICAgICAgICAgIHN1cHBsZW1lbnRzID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHJlYWRlckNvbmZpZy5jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGVyQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkZXJDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiBcIiwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uc3VwcGxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcGxlbWVudHMgPSBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3VwcGxlbWVudHMubWFwKChzdXBwbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSRUFERVJTW3N1cHBsZW1lbnRdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLnB1c2gobmV3IFJFQURFUlNbcmVhZGVyXShjb25maWd1cmF0aW9uLCBzdXBwbGVtZW50cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZWdpc3RlcmVkIFJlYWRlcnM6IFwiICsgX2JhcmNvZGVSZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlYWRlcikgPT4gSlNPTi5zdHJpbmdpZnkoe2Zvcm1hdDogcmVhZGVyLkZPUk1BVCwgY29uZmlnOiByZWFkZXIuY29uZmlnfSkpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRDb25maWcoKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICAgICAgdmlzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLmZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5XG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd1BhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNbaV0ucHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzW2ldLm5vZGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmQgdGhlIGxpbmUgb24gYm90aCBlbmRzXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpbmVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZExpbmUobGluZSwgYW5nbGUsIGV4dCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kTGluZShhbW91bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBsaW5lWzBdLnkgLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVswXS54IC09IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueSArPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnggKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGluc2lkZSBpbWFnZVxuICAgICAgICAgICAgZXh0ZW5kTGluZShleHQpO1xuICAgICAgICAgICAgd2hpbGUgKGV4dCA+IDEgJiYgKCFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzBdLCAwKVxuICAgICAgICAgICAgICAgICAgICB8fCAhaW5wdXRJbWFnZVdyYXBwZXIuaW5JbWFnZVdpdGhCb3JkZXIobGluZVsxXSwgMCkpKSB7XG4gICAgICAgICAgICAgICAgZXh0IC09IE1hdGguY2VpbChleHQgLyAyKTtcbiAgICAgICAgICAgICAgICBleHRlbmRMaW5lKC1leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lKGJveCkge1xuICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgeDogKGJveFsxXVswXSAtIGJveFswXVswXSkgLyAyICsgYm94WzBdWzBdLFxuICAgICAgICAgICAgICAgIHk6IChib3hbMV1bMV0gLSBib3hbMF1bMV0pIC8gMiArIGJveFswXVsxXVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJ5RGVjb2RlKGxpbmUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7eDogJ3gnLCB5OiAneSd9LCBfY2FudmFzLmN0eC5vdmVybGF5LCB7Y29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDN9KTtcbiAgICAgICAgICAgICAgICBCcmVzZW5oYW0uZGVidWcucHJpbnRGcmVxdWVuY3koYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20uZnJlcXVlbmN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQnJlc2VuaGFtLnRvQmluYXJ5TGluZShiYXJjb2RlTGluZSk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnLnNob3dQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50UGF0dGVybihiYXJjb2RlTGluZS5saW5lLCBfY2FudmFzLmRvbS5wYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgaW5wdXRJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZTogYmFyY29kZUxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICB2YXIgc2lkZUxlbmd0aCA9IE1hdGguc3FydChNYXRoLnBvdyhib3hbMV1bMF0gLSBib3hbMF1bMF0sIDIpICsgTWF0aC5wb3coKGJveFsxXVsxXSAtIGJveFswXVsxXSksIDIpKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHNsaWNlcyA9IDE2LFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG51bGwsXG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKSxcbiAgICAgICAgICAgICAgICB5ZGlyID0gTWF0aC5jb3MobGluZUFuZ2xlKTtcblxuICAgICAgICAgICAgZm9yICggaSA9IDE7IGkgPCBzbGljZXMgJiYgcmVzdWx0ID09PSBudWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGxpbmUgcGVycGVuZGljdWxhciB0byBhbmdsZVxuICAgICAgICAgICAgICAgIGRpciA9IHNpZGVMZW5ndGggLyBzbGljZXMgKiBpICogKGkgJSAyID09PSAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHk6IGRpciAqIHhkaXIsXG4gICAgICAgICAgICAgICAgICAgIHg6IGRpciAqIHlkaXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueSArPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzBdLnggLT0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMV0ueCAtPSBleHRlbnNpb24ueTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMikgK1xuICAgICAgICAgICAgICAgIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIHRoZSBoZWxwIG9mIHRoZSBjb25maWd1cmVkIHJlYWRlcnMgKENvZGUxMjggb3IgRUFOKSB0aGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGRldGVjdCBhXG4gICAgICAgICAqIHZhbGlkIGJhcmNvZGUgcGF0dGVybiB3aXRoaW4gdGhlIGdpdmVuIGFyZWEuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib3ggVGhlIGFyZWEgdG8gc2VhcmNoIGluXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSByZXN1bHQge2NvZGVSZXN1bHQsIGxpbmUsIGFuZ2xlLCBwYXR0ZXJuLCB0aHJlc2hvbGR9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB7XG4gICAgICAgICAgICB2YXIgbGluZSxcbiAgICAgICAgICAgICAgICBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgY3R4ID0gX2NhbnZhcy5jdHgub3ZlcmxheSxcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZUxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwge3g6IDAsIHk6IDF9LCBjdHgsIHtjb2xvcjogXCJibHVlXCIsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGluZSA9IGdldExpbmUoYm94KTtcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSBnZXRMaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgbGluZUFuZ2xlID0gTWF0aC5hdGFuMihsaW5lWzFdLnkgLSBsaW5lWzBdLnksIGxpbmVbMV0ueCAtIGxpbmVbMF0ueCk7XG4gICAgICAgICAgICBsaW5lID0gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGxpbmVBbmdsZSwgTWF0aC5mbG9vcihsaW5lTGVuZ3RoICogMC4xKSk7XG4gICAgICAgICAgICBpZiAobGluZSA9PT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwge3g6ICd4JywgeTogJ3knfSwgY3R4LCB7Y29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDN9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlUmVzdWx0OiByZXN1bHQuY29kZVJlc3VsdCxcbiAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBsaW5lQW5nbGUsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogcmVzdWx0LmJhcmNvZGVMaW5lLmxpbmUsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiByZXN1bHQuYmFyY29kZUxpbmUudGhyZXNob2xkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveDogZnVuY3Rpb24oYm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZyb21Cb3VuZGluZ0JveChib3gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21Cb3VuZGluZ0JveGVzOiBmdW5jdGlvbihib3hlcykge1xuICAgICAgICAgICAgICAgIHZhciBpLCByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxlID0gY29uZmlnLm11bHRpcGxlO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkgfHwge307XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib3ggPSBib3g7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2Rlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJlYWRlcnM6IGZ1bmN0aW9uKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwiaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5cbnZhciBCcmVzZW5oYW0gPSB7fTtcblxudmFyIFNsb3BlID0ge1xuICAgIERJUjoge1xuICAgICAgICBVUDogMSxcbiAgICAgICAgRE9XTjogLTFcbiAgICB9XG59O1xuLyoqXG4gKiBTY2FucyBhIGxpbmUgb2YgdGhlIGdpdmVuIGltYWdlIGZyb20gcG9pbnQgcDEgdG8gcDIgYW5kIHJldHVybnMgYSByZXN1bHQgb2JqZWN0IGNvbnRhaW5pbmdcbiAqIGdyYXktc2NhbGUgdmFsdWVzICgwLTI1NSkgb2YgdGhlIHVuZGVybHlpbmcgcGl4ZWxzIGluIGFkZGl0aW9uIHRvIHRoZSBtaW5cbiAqIGFuZCBtYXggdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IGltYWdlV3JhcHBlclxuICogQHBhcmFtIHtPYmplY3R9IHAxIFRoZSBzdGFydCBwb2ludCB7eCx5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIFRoZSBlbmQgcG9pbnQge3gseX1cbiAqIEByZXR1cm5zIHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLmdldEJhcmNvZGVMaW5lID0gZnVuY3Rpb24oaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcbiAgICB2YXIgeDAgPSBwMS54IHwgMCxcbiAgICAgICAgeTAgPSBwMS55IHwgMCxcbiAgICAgICAgeDEgPSBwMi54IHwgMCxcbiAgICAgICAgeTEgPSBwMi55IHwgMCxcbiAgICAgICAgc3RlZXAgPSBNYXRoLmFicyh5MSAtIHkwKSA+IE1hdGguYWJzKHgxIC0geDApLFxuICAgICAgICBkZWx0YXgsXG4gICAgICAgIGRlbHRheSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHlzdGVwLFxuICAgICAgICB5LFxuICAgICAgICB0bXAsXG4gICAgICAgIHgsXG4gICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgdmFsLFxuICAgICAgICBtaW4gPSAyNTUsXG4gICAgICAgIG1heCA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWFkKGEsIGIpIHtcbiAgICAgICAgdmFsID0gaW1hZ2VEYXRhW2IgKiB3aWR0aCArIGFdO1xuICAgICAgICBzdW0gKz0gdmFsO1xuICAgICAgICBtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG4gICAgICAgIG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcbiAgICAgICAgbGluZS5wdXNoKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHkwO1xuICAgICAgICB5MCA9IHRtcDtcblxuICAgICAgICB0bXAgPSB4MTtcbiAgICAgICAgeDEgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGlmICh4MCA+IHgxKSB7XG4gICAgICAgIHRtcCA9IHgwO1xuICAgICAgICB4MCA9IHgxO1xuICAgICAgICB4MSA9IHRtcDtcblxuICAgICAgICB0bXAgPSB5MDtcbiAgICAgICAgeTAgPSB5MTtcbiAgICAgICAgeTEgPSB0bXA7XG4gICAgfVxuICAgIGRlbHRheCA9IHgxIC0geDA7XG4gICAgZGVsdGF5ID0gTWF0aC5hYnMoeTEgLSB5MCk7XG4gICAgZXJyb3IgPSAoZGVsdGF4IC8gMikgfCAwO1xuICAgIHkgPSB5MDtcbiAgICB5c3RlcCA9IHkwIDwgeTEgPyAxIDogLTE7XG4gICAgZm9yICggeCA9IHgwOyB4IDwgeDE7IHgrKykge1xuICAgICAgICBpZiAoc3RlZXApe1xuICAgICAgICAgICAgcmVhZCh5LCB4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlYWQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvciAtIGRlbHRheTtcbiAgICAgICAgaWYgKGVycm9yIDwgMCkge1xuICAgICAgICAgICAgeSA9IHkgKyB5c3RlcDtcbiAgICAgICAgICAgIGVycm9yID0gZXJyb3IgKyBkZWx0YXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBtaW46IG1pbixcbiAgICAgICAgbWF4OiBtYXhcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHZhciBtaW4gPSByZXN1bHQubWluLFxuICAgICAgICBtYXggPSByZXN1bHQubWF4LFxuICAgICAgICBsaW5lID0gcmVzdWx0LmxpbmUsXG4gICAgICAgIHNsb3BlLFxuICAgICAgICBzbG9wZTIsXG4gICAgICAgIGNlbnRlciA9IG1pbiArIChtYXggLSBtaW4pIC8gMixcbiAgICAgICAgZXh0cmVtYSA9IFtdLFxuICAgICAgICBjdXJyZW50RGlyLFxuICAgICAgICBkaXIsXG4gICAgICAgIHRocmVzaG9sZCA9IChtYXggLSBtaW4pIC8gMTIsXG4gICAgICAgIHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkLFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHZhbDogbGluZVswXVxuICAgIH0pO1xuICAgIGZvciAoIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnREaXIgPSBkaXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgcG9zOiBsaW5lLmxlbmd0aCxcbiAgICAgICAgdmFsOiBsaW5lW2xpbmUubGVuZ3RoIC0gMV1cbiAgICB9KTtcblxuICAgIGZvciAoIGogPSBleHRyZW1hWzBdLnBvczsgaiA8IGV4dHJlbWFbMV0ucG9zOyBqKyspIHtcbiAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiBjZW50ZXIgPyAwIDogMTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgZXh0cmVtYSBhbmQgY29udmVydCB0byBiaW5hcnkgYmFzZWQgb24gYXZnIGJldHdlZW4gbWlubWF4XG4gICAgZm9yICggaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggaiA9IGV4dHJlbWFbaV0ucG9zOyBqIDwgZXh0cmVtYVtpICsgMV0ucG9zOyBqKyspIHtcbiAgICAgICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gdGhyZXNob2xkID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZFxuICAgIH07XG59O1xuXG4vKipcbiAqIFVzZWQgZm9yIGRldmVsb3BtZW50IG9ubHlcbiAqL1xuQnJlc2VuaGFtLmRlYnVnID0ge1xuICAgIHByaW50RnJlcXVlbmN5OiBmdW5jdGlvbihsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDI1NjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiYmx1ZVwiO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oaSwgMjU1KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oaSwgMjU1IC0gbGluZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIHByaW50UGF0dGVybjogZnVuY3Rpb24obGluZSwgY2FudmFzKSB7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCBpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICBjdHguZmlsbENvbG9yID0gXCJibGFja1wiO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsaW5lW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGksIDAsIDEsIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBCcmVzZW5oYW07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZGVjb2Rlci9icmVzZW5oYW0uanMiLCJpbXBvcnQge29taXQsIHBpY2t9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQge2dldFVzZXJNZWRpYSwgZW51bWVyYXRlRGV2aWNlc30gZnJvbSAnbWVkaWFEZXZpY2VzJztcblxuY29uc3QgZmFjaW5nTWF0Y2hpbmcgPSB7XG4gICAgXCJ1c2VyXCI6IC9mcm9udC9pLFxuICAgIFwiZW52aXJvbm1lbnRcIjogL2JhY2svaVxufTtcblxudmFyIHN0cmVhbVJlZjtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2codmlkZW8udmlkZW9XaWR0aCArIFwicHggeCBcIiArIHZpZGVvLnZpZGVvSGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdCgnVW5hYmxlIHRvIHBsYXkgdmlkZW8gc3RyZWFtLiBJcyB3ZWJjYW0gd29ya2luZz8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dGVtcHRzLS07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tWaWRlbygpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGF0dGFjaCB0aGUgY2FtZXJhLXN0cmVhbSB0byBhIGdpdmVuIHZpZGVvLWVsZW1lbnRcbiAqIGFuZCBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiB0aGUgY29udGVudCBpcyByZWFkeVxuICogQHBhcmFtIHtPYmplY3R9IGNvbnN0cmFpbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9cbiAqL1xuZnVuY3Rpb24gaW5pdENhbWVyYSh2aWRlbywgY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxuICAgIC50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW1SZWYgPSBzdHJlYW07XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoXCJhdXRvcGxheVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCB0cnVlKTtcbiAgICAgICAgICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbih3YWl0Rm9yVmlkZW8uYmluZChudWxsLCB2aWRlbykpO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiZmFjaW5nTW9kZVwiLFxuICAgICAgICAgICAgXCJhc3BlY3RSYXRpb1wiLCBcImRldmljZUlkXCJdKTtcblxuICAgIGlmICh0eXBlb2YgdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gPiAwKSB7XG4gICAgICAgIG5vcm1hbGl6ZWQuYXNwZWN0UmF0aW8gPSB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvO1xuICAgICAgICBjb25zb2xlLmxvZyhcIldBUk5JTkc6IENvbnN0cmFpbnQgJ21pbkFzcGVjdFJhdGlvJyBpcyBkZXByZWNhdGVkOyBVc2UgJ2FzcGVjdFJhdGlvJyBpbnN0ZWFkXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMuZmFjaW5nICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBub3JtYWxpemVkLmZhY2luZ01vZGUgPSB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZztcbiAgICAgICAgY29uc29sZS5sb2coXCJXQVJOSU5HOiBDb25zdHJhaW50ICdmYWNpbmcnIGlzIGRlcHJlY2F0ZWQuIFVzZSAnZmFjaW5nTW9kZScgaW5zdGVhZCdcIik7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQ29uc3RyYWludHMgPSB7XG4gICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgdmlkZW86IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKVxuICAgIH07XG5cbiAgICBpZiAobm9ybWFsaXplZENvbnN0cmFpbnRzLnZpZGVvLmRldmljZUlkXG4gICAgICAgICAgICAmJiBub3JtYWxpemVkQ29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZSkge1xuICAgICAgICBkZWxldGUgbm9ybWFsaXplZENvbnN0cmFpbnRzLnZpZGVvLmZhY2luZ01vZGU7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobm9ybWFsaXplZENvbnN0cmFpbnRzKTtcbn1cblxuZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCkge1xuICAgIHJldHVybiBlbnVtZXJhdGVEZXZpY2VzKClcbiAgICAudGhlbihkZXZpY2VzID0+IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0gJ3ZpZGVvaW5wdXQnKSk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCkge1xuICAgIGlmIChzdHJlYW1SZWYpIHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNrc1swXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlcXVlc3Q6IGZ1bmN0aW9uKHZpZGVvLCB2aWRlb0NvbnN0cmFpbnRzKSB7XG4gICAgICAgIHJldHVybiBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cylcbiAgICAgICAgICAgIC50aGVuKGluaXRDYW1lcmEuYmluZChudWxsLCB2aWRlbykpO1xuICAgIH0sXG4gICAgcmVsZWFzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0cmFja3MgPSBzdHJlYW1SZWYgJiYgc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgICAgIGlmICh0cmFja3MgJiYgdHJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJhY2tzWzBdLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1SZWYgPSBudWxsO1xuICAgIH0sXG4gICAgZW51bWVyYXRlVmlkZW9EZXZpY2VzLFxuICAgIGdldEFjdGl2ZVN0cmVhbUxhYmVsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2tcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvaW5wdXQvY2FtZXJhX2FjY2Vzcy5qcyIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7ICAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHsgICAgICAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuUXJDb2RlID0gZmFjdG9yeSgpKTtcbiAgICB9KHVuZGVmaW5lZCwgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbkxldmVsKG9yZGluYWwsIGJpdHMsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsX1JlbmFtZWRfRmllbGQgPSBvcmRpbmFsO1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cblxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLnByb3RvdHlwZS5vcmRpbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZGluYWxfUmVuYW1lZF9GaWVsZDtcbiAgICB9O1xuXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuZm9yQml0cyA9IGZ1bmN0aW9uKGJpdHMpIHtcbiAgICAgICAgaWYgKGJpdHMgPCAwIHx8IGJpdHMgPj0gRk9SX0JJVFMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IFwiQXJndW1lbnRFeGNlcHRpb25cIjtcbiAgICB9XG4gICAgICAgIHJldHVybiBGT1JfQklUU1tiaXRzXTtcbiAgICB9O1xuXG4gICAgdmFyIEZPUl9CSVRTID0gW1xuICAgICAgICBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoMSwgMHgwMCwgXCJNXCIpLFxuICAgICAgICBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoMCwgMHgwMSwgXCJMXCIpLFxuICAgICAgICBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoMywgMHgwMiwgXCJIXCIpLFxuICAgICAgICBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoMiwgMHgwMywgXCJRXCIpLFxuICAgIF07XG5cbi8qXG4gIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiAgbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiovXG5cbi8qXG4qXG4qIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIHZhciBGT1JNQVRfSU5GT19NQVNLX1FSID0gMHg1NDEyO1xuICAgIHZhciBGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQID0gW1xuICBbMHg1NDEyLCAweDAwXSxcbiAgWzB4NTEyNSwgMHgwMV0sXG4gIFsweDVFN0MsIDB4MDJdLFxuICBbMHg1QjRCLCAweDAzXSxcbiAgWzB4NDVGOSwgMHgwNF0sXG4gIFsweDQwQ0UsIDB4MDVdLFxuICBbMHg0Rjk3LCAweDA2XSxcbiAgWzB4NEFBMCwgMHgwN10sXG4gIFsweDc3QzQsIDB4MDhdLFxuICBbMHg3MkYzLCAweDA5XSxcbiAgWzB4N0RBQSwgMHgwQV0sXG4gIFsweDc4OUQsIDB4MEJdLFxuICBbMHg2NjJGLCAweDBDXSxcbiAgWzB4NjMxOCwgMHgwRF0sXG4gIFsweDZDNDEsIDB4MEVdLFxuICBbMHg2OTc2LCAweDBGXSxcbiAgWzB4MTY4OSwgMHgxMF0sXG4gIFsweDEzQkUsIDB4MTFdLFxuICBbMHgxQ0U3LCAweDEyXSxcbiAgWzB4MTlEMCwgMHgxM10sXG4gIFsweDA3NjIsIDB4MTRdLFxuICBbMHgwMjU1LCAweDE1XSxcbiAgWzB4MEQwQywgMHgxNl0sXG4gIFsweDA4M0IsIDB4MTddLFxuICBbMHgzNTVGLCAweDE4XSxcbiAgWzB4MzA2OCwgMHgxOV0sXG4gIFsweDNGMzEsIDB4MUFdLFxuICBbMHgzQTA2LCAweDFCXSxcbiAgWzB4MjRCNCwgMHgxQ10sXG4gIFsweDIxODMsIDB4MURdLFxuICBbMHgyRURBLCAweDFFXSxcbiAgWzB4MkJFRCwgMHgxRl0sXG4gICAgXTtcbiAgICB2YXIgQklUU19TRVRfSU5fSEFMRl9CWVRFID0gWzAsIDEsIDEsIDIsIDEsIDIsIDIsIDMsIDEsIDIsIDIsIDMsIDIsIDMsIDMsIDRdO1xuXG5cbiAgICBmdW5jdGlvbiBGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JCaXRzKChmb3JtYXRJbmZvID4+IDMpICYgMHgwMyk7XG4gICAgICAgIHRoaXMuZGF0YU1hc2sgPSAoZm9ybWF0SW5mbyAmIDB4MDcpO1xuICAgIH1cblxuICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5HZXRIYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwub3JkaW5hbCgpIDw8IDMpIHwgdGhpcy5kYXRhTWFzaztcbiAgICB9O1xuXG4gICAgRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlLkVxdWFscyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgdmFyIG90aGVyID0gbztcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPT09IG90aGVyLmVycm9yQ29ycmVjdGlvbkxldmVsICYmIHRoaXMuZGF0YU1hc2sgPT09IG90aGVyLmRhdGFNYXNrO1xuICAgIH07XG5cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5udW1CaXRzRGlmZmVyaW5nID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBhIF49IGI7IC8vIGEgbm93IGhhcyBhIDEgYml0IGV4YWN0bHkgd2hlcmUgaXRzIGJpdCBkaWZmZXJzIHdpdGggYidzXG4gIC8vIENvdW50IGJpdHMgc2V0IHF1aWNrbHkgd2l0aCBhIHNlcmllcyBvZiBsb29rdXBzOlxuICAgICAgICByZXR1cm4gQklUU19TRVRfSU5fSEFMRl9CWVRFW2EgJiAweDBGXSArIEJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCA0KSAmIDB4MEYpXSArIEJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCA4KSAmIDB4MEYpXSArIEJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCAxMikgJiAweDBGKV0gKyBCSVRTX1NFVF9JTl9IQUxGX0JZVEVbKFVSU2hpZnQoYSwgMTYpICYgMHgwRildICsgQklUU19TRVRfSU5fSEFMRl9CWVRFWyhVUlNoaWZ0KGEsIDIwKSAmIDB4MEYpXSArIEJJVFNfU0VUX0lOX0hBTEZfQllURVsoVVJTaGlmdChhLCAyNCkgJiAweDBGKV0gKyBCSVRTX1NFVF9JTl9IQUxGX0JZVEVbKFVSU2hpZnQoYSwgMjgpICYgMHgwRildO1xuICAgIH07XG5cbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5kZWNvZGVGb3JtYXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKG1hc2tlZEZvcm1hdEluZm8pIHtcbiAgICAgICAgdmFyIGZvcm1hdEluZm8gPSBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uKG1hc2tlZEZvcm1hdEluZm8pO1xuICAgICAgICBpZiAoZm9ybWF0SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0SW5mbztcbiAgICB9XG4gIC8vIFNob3VsZCByZXR1cm4gbnVsbCwgYnV0LCBzb21lIFFSIGNvZGVzIGFwcGFyZW50bHlcbiAgLy8gZG8gbm90IG1hc2sgdGhpcyBpbmZvLiBUcnkgYWdhaW4gYnkgYWN0dWFsbHkgbWFza2luZyB0aGUgcGF0dGVyblxuICAvLyBmaXJzdFxuICAgICAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvIF4gRk9STUFUX0lORk9fTUFTS19RUik7XG4gICAgfTtcbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5kb0RlY29kZUZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24obWFza2VkRm9ybWF0SW5mbykge1xuICAvLyBGaW5kIHRoZSBpbnQgaW4gRk9STUFUX0lORk9fREVDT0RFX0xPT0tVUCB3aXRoIGZld2VzdCBiaXRzIGRpZmZlcmluZ1xuICAgICAgICB2YXIgYmVzdERpZmZlcmVuY2UgPSAweGZmZmZmZmZmO1xuICAgICAgICB2YXIgYmVzdEZvcm1hdEluZm8gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRlY29kZUluZm8gPSBGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQW2ldO1xuICAgICAgICB2YXIgdGFyZ2V0SW5mbyA9IGRlY29kZUluZm9bMF07XG4gICAgICAgIGlmICh0YXJnZXRJbmZvID09PSBtYXNrZWRGb3JtYXRJbmZvKSB7XG4gICAgICAvLyBGb3VuZCBhbiBleGFjdCBtYXRjaFxuICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0SW5mb3JtYXRpb24oZGVjb2RlSW5mb1sxXSk7XG4gICAgICB9XG4gICAgICAgIHZhciBiaXRzRGlmZmVyZW5jZSA9IHRoaXMubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvLCB0YXJnZXRJbmZvKTtcbiAgICAgICAgaWYgKGJpdHNEaWZmZXJlbmNlIDwgYmVzdERpZmZlcmVuY2UpIHtcbiAgICAgICAgICBiZXN0Rm9ybWF0SW5mbyA9IGRlY29kZUluZm9bMV07XG4gICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcbiAgICAgIH1cbiAgICB9XG4gIC8vIEhhbW1pbmcgZGlzdGFuY2Ugb2YgdGhlIDMyIG1hc2tlZCBjb2RlcyBpcyA3LCBieSBjb25zdHJ1Y3Rpb24sIHNvIDw9IDMgYml0c1xuICAvLyBkaWZmZXJpbmcgbWVhbnMgd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGJlc3RGb3JtYXRJbmZvKTtcbiAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbi8qXG4gIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiAgbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiovXG5cbi8qXG4qXG4qIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIGZ1bmN0aW9uIEJpdE1hdHJpeCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICghaGVpZ2h0KVxuICAgICAgICBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XG4gICAgICAgIHRocm93IFwiQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIjtcbiAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHZhciByb3dTaXplID0gd2lkdGggPj4gNTtcbiAgICAgICAgaWYgKCh3aWR0aCAmIDB4MWYpICE9PSAwKSB7XG4gICAgICAgIHJvd1NpemUrKztcbiAgICB9XG4gICAgICAgIHRoaXMucm93U2l6ZSA9IHJvd1NpemU7XG4gICAgICAgIHRoaXMuYml0cyA9IG5ldyBBcnJheShyb3dTaXplICogaGVpZ2h0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJpdHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHRoaXMuYml0c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJpdE1hdHJpeC5wcm90b3R5cGUsIFwiRGltZW5zaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgXCJDYW4ndCBjYWxsIGdldERpbWVuc2lvbigpIG9uIGEgbm9uLXNxdWFyZSBtYXRyaXhcIjtcbiAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIH0pO1xuXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRfUmVuYW1lZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyAoeCA+PiA1KTtcbiAgICAgICAgcmV0dXJuICgoVVJTaGlmdCh0aGlzLmJpdHNbb2Zmc2V0XSwgKHggJiAweDFmKSkpICYgMSkgIT09IDA7XG4gICAgfTtcblxuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuc2V0X1JlbmFtZWQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgKHggPj4gNSk7XG4gICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIHw9IDEgPDwgKHggJiAweDFmKTtcbiAgICB9O1xuXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArICh4ID4+IDUpO1xuICAgICAgICB0aGlzLmJpdHNbb2Zmc2V0XSBePSAxIDw8ICh4ICYgMHgxZik7XG4gICAgfTtcblxuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuYml0cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgdGhpcy5iaXRzW2ldID0gMDtcbiAgICB9XG4gICAgfTtcblxuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuc2V0UmVnaW9uID0gZnVuY3Rpb24obGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh0b3AgPCAwIHx8IGxlZnQgPCAwKSB7XG4gICAgICAgIHRocm93IFwiTGVmdCBhbmQgdG9wIG11c3QgYmUgbm9ubmVnYXRpdmVcIjtcbiAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPCAxIHx8IHdpZHRoIDwgMSkge1xuICAgICAgICB0aHJvdyBcIkhlaWdodCBhbmQgd2lkdGggbXVzdCBiZSBhdCBsZWFzdCAxXCI7XG4gICAgfVxuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG4gICAgICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgICAgIGlmIChib3R0b20gPiB0aGlzLmhlaWdodCB8fCByaWdodCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgdGhyb3cgXCJUaGUgcmVnaW9uIG11c3QgZml0IGluc2lkZSB0aGUgbWF0cml4XCI7XG4gICAgfVxuICAgICAgICBmb3IgKHZhciB5ID0gdG9wOyB5IDwgYm90dG9tOyB5KyspIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemU7XG4gICAgICAgIGZvciAodmFyIHggPSBsZWZ0OyB4IDwgcmlnaHQ7IHgrKykge1xuICAgICAgICAgIHRoaXMuYml0c1tvZmZzZXQgKyAoeCA+PiA1KV0gfD0gMSA8PCAoeCAmIDB4MWYpO1xuICAgICAgfVxuICAgIH1cbiAgICB9O1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICBmdW5jdGlvbiBFQ0IoY291bnQsIGRhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLmRhdGFDb2Rld29yZHMgPSBkYXRhQ29kZXdvcmRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEVDQmxvY2tzKGVjQ29kZXdvcmRzUGVyQmxvY2ssIGVjQmxvY2tzMSwgZWNCbG9ja3MyKSB7XG4gICAgICAgIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayA9IGVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgIGlmIChlY0Jsb2NrczIpXG4gICAgICAgIHRoaXMuZWNCbG9ja3MgPSBbZWNCbG9ja3MxLCBlY0Jsb2NrczJdO1xuICBlbHNlXG4gICAgdGhpcy5lY0Jsb2NrcyA9IFtlY0Jsb2NrczFdO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFQ0Jsb2Nrcy5wcm90b3R5cGUsIFwiVG90YWxFQ0NvZGV3b3Jkc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjQ29kZXdvcmRzUGVyQmxvY2sgKiB0aGlzLk51bUJsb2NrcztcbiAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRUNCbG9ja3MucHJvdG90eXBlLCBcIk51bUJsb2Nrc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lY0Jsb2Nrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRvdGFsICs9IHRoaXMuZWNCbG9ja3NbaV0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICAgIH0pO1xuXG4gICAgRUNCbG9ja3MucHJvdG90eXBlLmdldEVDQmxvY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIsIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzLCBlY0Jsb2NrczEsIGVjQmxvY2tzMiwgZWNCbG9ja3MzLCBlY0Jsb2NrczQpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTnVtYmVyID0gdmVyc2lvbk51bWJlcjtcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycyA9IGFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xuICAgICAgICB0aGlzLmVjQmxvY2tzID0gW2VjQmxvY2tzMSwgZWNCbG9ja3MyLCBlY0Jsb2NrczMsIGVjQmxvY2tzNF07XG5cbiAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgdmFyIGVjQ29kZXdvcmRzID0gZWNCbG9ja3MxLmVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gICAgICAgIHZhciBlY2JBcnJheSA9IGVjQmxvY2tzMS5nZXRFQ0Jsb2NrcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjYkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlY0Jsb2NrID0gZWNiQXJyYXlbaV07XG4gICAgICAgIHRvdGFsICs9IGVjQmxvY2suY291bnQgKiAoZWNCbG9jay5kYXRhQ29kZXdvcmRzICsgZWNDb2Rld29yZHMpO1xuICAgIH1cbiAgICAgICAgdGhpcy50b3RhbENvZGV3b3JkcyA9IHRvdGFsO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJzaW9uLnByb3RvdHlwZSwgXCJEaW1lbnNpb25Gb3JWZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE3ICsgNCAqIHRoaXMudmVyc2lvbk51bWJlcjtcbiAgICB9XG4gICAgfSk7XG5cbiAgICBWZXJzaW9uLnByb3RvdHlwZS5idWlsZEZ1bmN0aW9uUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5EaW1lbnNpb25Gb3JWZXJzaW9uO1xuICAgICAgICB2YXIgYml0TWF0cml4ID0gbmV3IEJpdE1hdHJpeChkaW1lbnNpb24pO1xuXG4gIC8vIFRvcCBsZWZ0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgMCwgOSwgOSk7XG4gIC8vIFRvcCByaWdodCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKGRpbWVuc2lvbiAtIDgsIDAsIDgsIDkpO1xuICAvLyBCb3R0b20gbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxuICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDAsIGRpbWVuc2lvbiAtIDgsIDksIDgpO1xuXG4gIC8vIEFsaWdubWVudCBwYXR0ZXJuc1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4OyB4KyspIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXg7IHkrKykge1xuICAgICAgICAgIGlmICgoeCA9PT0gMCAmJiAoeSA9PT0gMCB8fCB5ID09PSBtYXggLSAxKSkgfHwgKHggPT09IG1heCAtIDEgJiYgeSA9PT0gMCkpIHtcbiAgICAgICAgLy8gTm8gYWxpZ25tZW50IHBhdHRlcm5zIG5lYXIgdGhlIHRocmVlIGZpbmRlciBwYXRlcm5zXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xuICAgICAgfVxuICAgIH1cblxuICAvLyBWZXJ0aWNhbCB0aW1pbmcgcGF0dGVyblxuICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDYsIDksIDEsIGRpbWVuc2lvbiAtIDE3KTtcbiAgLy8gSG9yaXpvbnRhbCB0aW1pbmcgcGF0dGVyblxuICAgICAgICBiaXRNYXRyaXguc2V0UmVnaW9uKDksIDYsIGRpbWVuc2lvbiAtIDE3LCAxKTtcblxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTnVtYmVyID4gNikge1xuICAgIC8vIFZlcnNpb24gaW5mbywgdG9wIHJpZ2h0XG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpO1xuICAgIC8vIFZlcnNpb24gaW5mbywgYm90dG9tIGxlZnRcbiAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbigwLCBkaW1lbnNpb24gLSAxMSwgNiwgMyk7XG4gICAgfVxuXG4gICAgICAgIHJldHVybiBiaXRNYXRyaXg7XG4gICAgfTtcblxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldEVDQmxvY2tzRm9yTGV2ZWwgPSBmdW5jdGlvbihlY0xldmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVjQmxvY2tzW2VjTGV2ZWwub3JkaW5hbCgpXTtcbiAgICB9O1xuXG4gICAgVmVyc2lvbi5WRVJTSU9OX0RFQ09ERV9JTkZPID0gW1xuICAgICAgICAweDA3Qzk0LFxuICAgICAgICAweDA4NUJDLFxuICAgICAgICAweDA5QTk5LFxuICAgICAgICAweDBBNEQzLFxuICAgICAgICAweDBCQkY2LFxuICAgICAgICAweDBDNzYyLFxuICAgICAgICAweDBEODQ3LFxuICAgICAgICAweDBFNjBELFxuICAgICAgICAweDBGOTI4LFxuICAgICAgICAweDEwQjc4LFxuICAgICAgICAweDExNDVELFxuICAgICAgICAweDEyQTE3LFxuICAgICAgICAweDEzNTMyLFxuICAgICAgICAweDE0OUE2LFxuICAgICAgICAweDE1NjgzLFxuICAgICAgICAweDE2OEM5LFxuICAgICAgICAweDE3N0VDLFxuICAgICAgICAweDE4RUM0LFxuICAgICAgICAweDE5MUUxLFxuICAgICAgICAweDFBRkFCLFxuICAgICAgICAweDFCMDhFLFxuICAgICAgICAweDFDQzFBLFxuICAgICAgICAweDFEMzNGLFxuICAgICAgICAweDFFRDc1LFxuICAgICAgICAweDFGMjUwLFxuICAgICAgICAweDIwOUQ1LFxuICAgICAgICAweDIxNkYwLFxuICAgICAgICAweDIyOEJBLFxuICAgICAgICAweDIzNzlGLFxuICAgICAgICAweDI0QjBCLFxuICAgICAgICAweDI1NDJFLFxuICAgICAgICAweDI2QTY0LFxuICAgICAgICAweDI3NTQxLFxuICAgICAgICAweDI4QzY5XG4gICAgXTtcblxuICAgIFZlcnNpb24uVkVSU0lPTlMgPSBidWlsZFZlcnNpb25zKCk7XG5cbiAgICBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIgPSBmdW5jdGlvbih2ZXJzaW9uTnVtYmVyKSB7XG4gICAgICAgIGlmICh2ZXJzaW9uTnVtYmVyIDwgMSB8fCB2ZXJzaW9uTnVtYmVyID4gNDApIHtcbiAgICAgICAgdGhyb3cgXCJBcmd1bWVudEV4Y2VwdGlvblwiO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIFZlcnNpb24uVkVSU0lPTlNbdmVyc2lvbk51bWJlciAtIDFdO1xuICAgIH07XG5cbiAgICBWZXJzaW9uLmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbiA9IGZ1bmN0aW9uKGRpbWVuc2lvbikge1xuICAgICAgICBpZiAoZGltZW5zaW9uICUgNCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBcIkVycm9yIGdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvblwiO1xuICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFZlcnNpb24uZ2V0VmVyc2lvbkZvck51bWJlcigoZGltZW5zaW9uIC0gMTcpID4+IDIpO1xuICAgIH0gY2F0Y2ggKGlhZSkge1xuICAgICAgdGhyb3cgXCJFcnJvciBnZXRWZXJzaW9uRm9yTnVtYmVyXCI7XG4gIH1cbiAgICB9O1xuXG4gICAgVmVyc2lvbi5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24gPSBmdW5jdGlvbih2ZXJzaW9uQml0cykge1xuICAgICAgICB2YXIgYmVzdERpZmZlcmVuY2UgPSAweGZmZmZmZmZmO1xuICAgICAgICB2YXIgYmVzdFZlcnNpb24gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFZlcnNpb24uVkVSU0lPTl9ERUNPREVfSU5GTy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGFyZ2V0VmVyc2lvbiA9IFZlcnNpb24uVkVSU0lPTl9ERUNPREVfSU5GT1tpXTtcbiAgICAvLyBEbyB0aGUgdmVyc2lvbiBpbmZvIGJpdHMgbWF0Y2ggZXhhY3RseT8gZG9uZS5cbiAgICAgICAgaWYgKHRhcmdldFZlcnNpb24gPT09IHZlcnNpb25CaXRzKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbkZvck51bWJlcihpICsgNyk7XG4gICAgICB9XG4gICAgLy8gT3RoZXJ3aXNlIHNlZSBpZiB0aGlzIGlzIHRoZSBjbG9zZXN0IHRvIGEgcmVhbCB2ZXJzaW9uIGluZm8gYml0IHN0cmluZ1xuICAgIC8vIHdlIGhhdmUgc2VlbiBzbyBmYXJcbiAgICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyh2ZXJzaW9uQml0cywgdGFyZ2V0VmVyc2lvbik7XG4gICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XG4gICAgICAgICAgYmVzdFZlcnNpb24gPSBpICsgNztcbiAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xuICAgICAgfVxuICAgIH1cbiAgLy8gV2UgY2FuIHRvbGVyYXRlIHVwIHRvIDMgYml0cyBvZiBlcnJvciBzaW5jZSBubyB0d28gdmVyc2lvbiBpbmZvIGNvZGV3b3JkcyB3aWxsXG4gIC8vIGRpZmZlciBpbiBsZXNzIHRoYW4gNCBiaXRzLlxuICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWZXJzaW9uRm9yTnVtYmVyKGJlc3RWZXJzaW9uKTtcbiAgICB9XG4gIC8vIElmIHdlIGRpZG4ndCBmaW5kIGEgY2xvc2UgZW5vdWdoIG1hdGNoLCBmYWlsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZFZlcnNpb25zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVmVyc2lvbigxLCBbXSwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgMTkpKSwgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDE2KSksIG5ldyBFQ0Jsb2NrcygxMywgbmV3IEVDQigxLCAxMykpLCBuZXcgRUNCbG9ja3MoMTcsIG5ldyBFQ0IoMSwgOSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMiwgWzYsIDE4XSwgbmV3IEVDQmxvY2tzKDEwLCBuZXcgRUNCKDEsIDM0KSksIG5ldyBFQ0Jsb2NrcygxNiwgbmV3IEVDQigxLCAyOCkpLCBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMSwgMjIpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzLCBbNiwgMjJdLCBuZXcgRUNCbG9ja3MoMTUsIG5ldyBFQ0IoMSwgNTUpKSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDEsIDQ0KSksIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCAxNykpLCBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMiwgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDQsIFs2LCAyNl0sIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQigxLCA4MCkpLCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMiwgMzIpKSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDIsIDI0KSksIG5ldyBFQ0Jsb2NrcygxNiwgbmV3IEVDQig0LCA5KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig1LCBbNiwgMzBdLCBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoMSwgMTA4KSksIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQigyLCA0MykpLCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMiwgMTUpLCBuZXcgRUNCKDIsIDE2KSksIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQigyLCAxMSksIG5ldyBFQ0IoMiwgMTIpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDYsIFs2LCAzNF0sIG5ldyBFQ0Jsb2NrcygxOCwgbmV3IEVDQigyLCA2OCkpLCBuZXcgRUNCbG9ja3MoMTYsIG5ldyBFQ0IoNCwgMjcpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDQsIDE5KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig0LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oNywgWzYsIDIyLCAzOF0sIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQigyLCA3OCkpLCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoNCwgMzEpKSwgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDIsIDE0KSwgbmV3IEVDQig0LCAxNSkpLCBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoNCwgMTMpLCBuZXcgRUNCKDEsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig4LCBbNiwgMjQsIDQyXSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDIsIDk3KSksIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQigyLCAzOCksIG5ldyBFQ0IoMiwgMzkpKSwgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDQsIDE4KSwgbmV3IEVDQigyLCAxOSkpLCBuZXcgRUNCbG9ja3MoMjYsIG5ldyBFQ0IoNCwgMTQpLCBuZXcgRUNCKDIsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig5LCBbNiwgMjYsIDQ2XSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIsIDExNikpLCBuZXcgRUNCbG9ja3MoMjIsIG5ldyBFQ0IoMywgMzYpLCBuZXcgRUNCKDIsIDM3KSksIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQig0LCAxNiksIG5ldyBFQ0IoNCwgMTcpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDQsIDEyKSwgbmV3IEVDQig0LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTAsIFs2LCAyOCwgNTBdLCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMiwgNjgpLCBuZXcgRUNCKDIsIDY5KSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQig0LCA0MyksIG5ldyBFQ0IoMSwgNDQpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDYsIDE5KSwgbmV3IEVDQigyLCAyMCkpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNiwgMTUpLCBuZXcgRUNCKDIsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxMSwgWzYsIDMwLCA1NF0sIG5ldyBFQ0Jsb2NrcygyMCwgbmV3IEVDQig0LCA4MSkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMSwgNTApLCBuZXcgRUNCKDQsIDUxKSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig0LCAyMiksIG5ldyBFQ0IoNCwgMjMpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDMsIDEyKSwgbmV3IEVDQig4LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTIsIFs2LCAzMiwgNThdLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMiwgOTIpLCBuZXcgRUNCKDIsIDkzKSksIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQig2LCAzNiksIG5ldyBFQ0IoMiwgMzcpKSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDQsIDIwKSwgbmV3IEVDQig2LCAyMSkpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNywgMTQpLCBuZXcgRUNCKDQsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxMywgWzYsIDM0LCA2Ml0sIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQig0LCAxMDcpKSwgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDgsIDM3KSwgbmV3IEVDQigxLCAzOCkpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoOCwgMjApLCBuZXcgRUNCKDQsIDIxKSksIG5ldyBFQ0Jsb2NrcygyMiwgbmV3IEVDQigxMiwgMTEpLCBuZXcgRUNCKDQsIDEyKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxNCwgWzYsIDI2LCA0NiwgNjZdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMywgMTE1KSwgbmV3IEVDQigxLCAxMTYpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDQsIDQwKSwgbmV3IEVDQig1LCA0MSkpLCBuZXcgRUNCbG9ja3MoMjAsIG5ldyBFQ0IoMTEsIDE2KSwgbmV3IEVDQig1LCAxNykpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMTEsIDEyKSwgbmV3IEVDQig1LCAxMykpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTUsIFs2LCAyNiwgNDgsIDcwXSwgbmV3IEVDQmxvY2tzKDIyLCBuZXcgRUNCKDUsIDg3KSwgbmV3IEVDQigxLCA4OCkpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoNSwgNDEpLCBuZXcgRUNCKDUsIDQyKSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig1LCAyNCksIG5ldyBFQ0IoNywgMjUpKSwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDExLCAxMiksIG5ldyBFQ0IoNywgMTMpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDE2LCBbNiwgMjYsIDUwLCA3NF0sIG5ldyBFQ0Jsb2NrcygyNCwgbmV3IEVDQig1LCA5OCksIG5ldyBFQ0IoMSwgOTkpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDcsIDQ1KSwgbmV3IEVDQigzLCA0NikpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMTUsIDE5KSwgbmV3IEVDQigyLCAyMCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMywgMTUpLCBuZXcgRUNCKDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTcsIFs2LCAzMCwgNTQsIDc4XSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDEwNyksIG5ldyBFQ0IoNSwgMTA4KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxMCwgNDYpLCBuZXcgRUNCKDEsIDQ3KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxLCAyMiksIG5ldyBFQ0IoMTUsIDIzKSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigyLCAxNCksIG5ldyBFQ0IoMTcsIDE1KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigxOCwgWzYsIDMwLCA1NiwgODJdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNSwgMTIwKSwgbmV3IEVDQigxLCAxMjEpKSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDksIDQzKSwgbmV3IEVDQig0LCA0NCkpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTcsIDIyKSwgbmV3IEVDQigxLCAyMykpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMiwgMTQpLCBuZXcgRUNCKDE5LCAxNSkpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMTksIFs2LCAzMCwgNTgsIDg2XSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDMsIDExMyksIG5ldyBFQ0IoNCwgMTE0KSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigzLCA0NCksIG5ldyBFQ0IoMTEsIDQ1KSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigxNywgMjEpLCBuZXcgRUNCKDQsIDIyKSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQig5LCAxMyksIG5ldyBFQ0IoMTYsIDE0KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyMCwgWzYsIDM0LCA2MiwgOTBdLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMywgMTA3KSwgbmV3IEVDQig1LCAxMDgpKSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDMsIDQxKSwgbmV3IEVDQigxMywgNDIpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE1LCAyNCksIG5ldyBFQ0IoNSwgMjUpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE1LCAxNSksIG5ldyBFQ0IoMTAsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyMSwgWzYsIDI4LCA1MCwgNzIsIDk0XSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDQsIDExNiksIG5ldyBFQ0IoNCwgMTE3KSksIG5ldyBFQ0Jsb2NrcygyNiwgbmV3IEVDQigxNywgNDIpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE3LCAyMiksIG5ldyBFQ0IoNiwgMjMpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE5LCAxNiksIG5ldyBFQ0IoNiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDIyLCBbNiwgMjYsIDUwLCA3NCwgOThdLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMiwgMTExKSwgbmV3IEVDQig3LCAxMTIpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE3LCA0NikpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNywgMjQpLCBuZXcgRUNCKDE2LCAyNSkpLCBuZXcgRUNCbG9ja3MoMjQsIG5ldyBFQ0IoMzQsIDEzKSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyMywgWzYsIDMwLCA1NCwgNzQsIDEwMl0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0LCAxMjEpLCBuZXcgRUNCKDUsIDEyMikpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNCwgNDcpLCBuZXcgRUNCKDE0LCA0OCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTEsIDI0KSwgbmV3IEVDQigxNCwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE2LCAxNSksIG5ldyBFQ0IoMTQsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyNCwgWzYsIDI4LCA1NCwgODAsIDEwNl0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig2LCAxMTcpLCBuZXcgRUNCKDQsIDExOCkpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNiwgNDUpLCBuZXcgRUNCKDE0LCA0NikpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTEsIDI0KSwgbmV3IEVDQigxNiwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDMwLCAxNiksIG5ldyBFQ0IoMiwgMTcpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDI1LCBbNiwgMzIsIDU4LCA4NCwgMTEwXSwgbmV3IEVDQmxvY2tzKDI2LCBuZXcgRUNCKDgsIDEwNiksIG5ldyBFQ0IoNCwgMTA3KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig4LCA0NyksIG5ldyBFQ0IoMTMsIDQ4KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig3LCAyNCksIG5ldyBFQ0IoMjIsIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigyMiwgMTUpLCBuZXcgRUNCKDEzLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMjYsIFs2LCAzMCwgNTgsIDg2LCAxMTRdLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTAsIDExNCksIG5ldyBFQ0IoMiwgMTE1KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxOSwgNDYpLCBuZXcgRUNCKDQsIDQ3KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigyOCwgMjIpLCBuZXcgRUNCKDYsIDIzKSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigzMywgMTYpLCBuZXcgRUNCKDQsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyNywgWzYsIDM0LCA2MiwgOTAsIDExOF0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig4LCAxMjIpLCBuZXcgRUNCKDQsIDEyMykpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMjIsIDQ1KSwgbmV3IEVDQigzLCA0NikpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoOCwgMjMpLCBuZXcgRUNCKDI2LCAyNCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTIsIDE1KSwgbmV3IEVDQigyOCwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDI4LCBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigzLCAxMTcpLCBuZXcgRUNCKDEwLCAxMTgpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDMsIDQ1KSwgbmV3IEVDQigyMywgNDYpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQsIDI0KSwgbmV3IEVDQigzMSwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDExLCAxNSksIG5ldyBFQ0IoMzEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigyOSwgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2XSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDcsIDExNiksIG5ldyBFQ0IoNywgMTE3KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigyMSwgNDUpLCBuZXcgRUNCKDcsIDQ2KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxLCAyMyksIG5ldyBFQ0IoMzcsIDI0KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxOSwgMTUpLCBuZXcgRUNCKDI2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzAsIFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig1LCAxMTUpLCBuZXcgRUNCKDEwLCAxMTYpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE5LCA0NyksIG5ldyBFQ0IoMTAsIDQ4KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxNSwgMjQpLCBuZXcgRUNCKDI1LCAyNSkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMjMsIDE1KSwgbmV3IEVDQigyNSwgMTYpKSksXG4gICAgICAgIG5ldyBWZXJzaW9uKDMxLCBbNiwgMzAsIDU2LCA4MiwgMTA4LCAxMzRdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTMsIDExNSksIG5ldyBFQ0IoMywgMTE2KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigyLCA0NiksIG5ldyBFQ0IoMjksIDQ3KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0MiwgMjQpLCBuZXcgRUNCKDEsIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigyMywgMTUpLCBuZXcgRUNCKDI4LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzIsIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxNywgMTE1KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxMCwgNDYpLCBuZXcgRUNCKDIzLCA0NykpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTAsIDI0KSwgbmV3IEVDQigzNSwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE5LCAxNSksIG5ldyBFQ0IoMzUsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzMywgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE3LCAxMTUpLCBuZXcgRUNCKDEsIDExNikpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTQsIDQ2KSwgbmV3IEVDQigyMSwgNDcpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDI5LCAyNCksIG5ldyBFQ0IoMTksIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMSwgMTUpLCBuZXcgRUNCKDQ2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzQsIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigxMywgMTE1KSwgbmV3IEVDQig2LCAxMTYpKSwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDE0LCA0NiksIG5ldyBFQ0IoMjMsIDQ3KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0NCwgMjQpLCBuZXcgRUNCKDcsIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig1OSwgMTYpLCBuZXcgRUNCKDEsIDE3KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzNSwgWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2LCAxNTBdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTIsIDEyMSksIG5ldyBFQ0IoNywgMTIyKSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxMiwgNDcpLCBuZXcgRUNCKDI2LCA0OCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMzksIDI0KSwgbmV3IEVDQigxNCwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIyLCAxNSksIG5ldyBFQ0IoNDEsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbigzNiwgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNiwgMTIxKSwgbmV3IEVDQigxNCwgMTIyKSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQig2LCA0NyksIG5ldyBFQ0IoMzQsIDQ4KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0NiwgMjQpLCBuZXcgRUNCKDEwLCAyNSkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMiwgMTUpLCBuZXcgRUNCKDY0LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzcsIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDE3LCAxMjIpLCBuZXcgRUNCKDQsIDEyMykpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMjksIDQ2KSwgbmV3IEVDQigxNCwgNDcpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQ5LCAyNCksIG5ldyBFQ0IoMTAsIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQigyNCwgMTUpLCBuZXcgRUNCKDQ2LCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzgsIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQsIDEyMiksIG5ldyBFQ0IoMTgsIDEyMykpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoMTMsIDQ2KSwgbmV3IEVDQigzMiwgNDcpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDQ4LCAyNCksIG5ldyBFQ0IoMTQsIDI1KSksIG5ldyBFQ0Jsb2NrcygzMCwgbmV3IEVDQig0MiwgMTUpLCBuZXcgRUNCKDMyLCAxNikpKSxcbiAgICAgICAgbmV3IFZlcnNpb24oMzksIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIwLCAxMTcpLCBuZXcgRUNCKDQsIDExOCkpLCBuZXcgRUNCbG9ja3MoMjgsIG5ldyBFQ0IoNDAsIDQ3KSwgbmV3IEVDQig3LCA0OCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoNDMsIDI0KSwgbmV3IEVDQigyMiwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDEwLCAxNSksIG5ldyBFQ0IoNjcsIDE2KSkpLFxuICAgICAgICBuZXcgVmVyc2lvbig0MCwgWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyLCAxNzBdLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMTksIDExOCksIG5ldyBFQ0IoNiwgMTE5KSksIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxOCwgNDcpLCBuZXcgRUNCKDMxLCA0OCkpLCBuZXcgRUNCbG9ja3MoMzAsIG5ldyBFQ0IoMzQsIDI0KSwgbmV3IEVDQigzNCwgMjUpKSwgbmV3IEVDQmxvY2tzKDMwLCBuZXcgRUNCKDIwLCAxNSksIG5ldyBFQ0IoNjEsIDE2KSkpLFxuICAgIF07XG4gICAgfVxuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuICAgIGZ1bmN0aW9uIEFsaWdubWVudFBhdHRlcm4ocG9zWCwgcG9zWSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSkge1xuICAgICAgICB0aGlzLnggPSBwb3NYO1xuICAgICAgICB0aGlzLnkgPSBwb3NZO1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplID0gZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWxpZ25tZW50UGF0dGVybi5wcm90b3R5cGUsIFwiWFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMueCk7XG4gICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFsaWdubWVudFBhdHRlcm4ucHJvdG90eXBlLCBcIllcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgIH1cbiAgICB9KTtcblxuICAgIEFsaWdubWVudFBhdHRlcm4ucHJvdG90eXBlLmluY3JlbWVudENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICB9O1xuXG4gICAgQWxpZ25tZW50UGF0dGVybi5wcm90b3R5cGUuYWJvdXRFcXVhbHMgPSBmdW5jdGlvbihtb2R1bGVTaXplLCBpLCBqKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhpIC0gdGhpcy55KSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLngpIDw9IG1vZHVsZVNpemUpIHtcbiAgICAgICAgdmFyIG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIHJldHVybiBtb2R1bGVTaXplRGlmZiA8PSAxLjAgfHwgbW9kdWxlU2l6ZURpZmYgLyB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgPD0gMS4wO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyKGltYWdlLCBzdGFydFgsIHN0YXJ0WSwgd2lkdGgsIGhlaWdodCwgbW9kdWxlU2l6ZSwgcmVzdWx0UG9pbnRDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRYID0gc3RhcnRYO1xuICAgICAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5tb2R1bGVTaXplID0gbW9kdWxlU2l6ZTtcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IFswLCAwLCAwXTtcbiAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjaztcbiAgICB9XG5cbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jZW50ZXJGcm9tRW5kID0gZnVuY3Rpb24oc3RhdGVDb3VudCwgZW5kKSB7XG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFsyXSkgLSBzdGF0ZUNvdW50WzFdIC8gMi4wO1xuICAgIH07XG5cbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5mb3VuZFBhdHRlcm5Dcm9zcyA9IGZ1bmN0aW9uKHN0YXRlQ291bnQpIHtcbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemU7XG4gICAgICAgIHZhciBtYXhWYXJpYW5jZSA9IG1vZHVsZVNpemUgLyAyLjA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhtb2R1bGVTaXplIC0gc3RhdGVDb3VudFtpXSkgPj0gbWF4VmFyaWFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24oc3RhcnRJLCBjZW50ZXJKLCBtYXhDb3VudCwgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuXG4gIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgIHZhciBpID0gc3RhcnRJO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgIGktLTtcbiAgICB9XG4gIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgLy8gTm93IGFsc28gY291bnQgZG93biBmcm9tIGNlbnRlclxuICAgICAgICBpID0gc3RhcnRJICsgMTtcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgICAgIGlmIChpID09PSBtYXhJIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5kYXRhW2NlbnRlckogKyBpICogaW1hZ2Uud2lkdGhdICYmIHN0YXRlQ291bnRbMl0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgICAgICBpZiAoc3RhdGVDb3VudFsyXSA+IG1heENvdW50KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IHRoaXMuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICB9O1xuXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuaGFuZGxlUG9zc2libGVDZW50ZXIgPSBmdW5jdGlvbihzdGF0ZUNvdW50LCBpLCBqKSB7XG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XG4gICAgICAgIHZhciBjZW50ZXJKID0gdGhpcy5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopO1xuICAgICAgICB2YXIgY2VudGVySSA9IHRoaXMuY3Jvc3NDaGVja1ZlcnRpY2FsKGksIE1hdGguZmxvb3IoY2VudGVySiksIDIgKiBzdGF0ZUNvdW50WzFdLCBzdGF0ZUNvdW50VG90YWwpO1xuICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7XG4gICAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gKHN0YXRlQ291bnRbMF0gKyBzdGF0ZUNvdW50WzFdICsgc3RhdGVDb3VudFsyXSkgLyAzLjA7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5wb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xuICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICBpZiAoY2VudGVyLmFib3V0RXF1YWxzKGVzdGltYXRlZE1vZHVsZVNpemUsIGNlbnRlckksIGNlbnRlckopKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFsaWdubWVudFBhdHRlcm4oY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAvLyBIYWRuJ3QgZm91bmQgdGhpcyBiZWZvcmU7IHNhdmUgaXRcbiAgICAgICAgdmFyIHBvaW50ID0gbmV3IEFsaWdubWVudFBhdHRlcm4oY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzLnB1c2gocG9pbnQpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgICB2YXIgc3RhcnRYID0gdGhpcy5zdGFydFg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgdmFyIG1heEogPSBzdGFydFggKyB0aGlzLndpZHRoO1xuICAgICAgICB2YXIgbWlkZGxlSSA9IHRoaXMuc3RhcnRZICsgKGhlaWdodCA+PiAxKTtcbiAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW4gMToxOjEgcmF0aW87XG4gIC8vIHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBzZWVuIHNvIGZhclxuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IFswLCAwLCAwXTtcbiAgICAgICAgZm9yICh2YXIgaUdlbiA9IDA7IGlHZW4gPCBoZWlnaHQ7IGlHZW4rKykge1xuICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkc1xuICAgICAgICB2YXIgaSA9IG1pZGRsZUkgKyAoKGlHZW4gJiAweDAxKSA9PT0gMCA/ICgoaUdlbiArIDEpID4+IDEpIDogLSgoaUdlbiArIDEpID4+IDEpKTtcbiAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xuICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgdmFyIGogPSBzdGFydFg7XG4gICAgLy8gQnVybiBvZmYgbGVhZGluZyB3aGl0ZSBwaXhlbHMgYmVmb3JlIGFueXRoaW5nIGVsc2U7IGlmIHdlIHN0YXJ0IGluIHRoZSBtaWRkbGUgb2ZcbiAgICAvLyBhIHdoaXRlIHJ1biwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGNvdW50IGl0cyBsZW5ndGgsIHNpbmNlIHdlIGRvbid0IGtub3cgaWYgdGhlXG4gICAgLy8gd2hpdGUgcnVuIGNvbnRpbnVlZCB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgcG9pbnRcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5kYXRhW2ogKyBpbWFnZS53aWR0aCAqIGldKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKKSB7XG4gICAgICAgICAgaWYgKGltYWdlLmRhdGFbaiArIGkgKiBpbWFnZS53aWR0aF0pIHtcbiAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMikge1xuICAgICAgICAgICAgLy8gQSB3aW5uZXI/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICAgICAgLy8gWWVzXG4gICAgICAgICAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMTtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WysrY3VycmVudFN0YXRlXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hpdGUgcGl4ZWxcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgIH1cbiAgICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XG4gICAgICAgICAgaWYgKGNvbmZpcm1lZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAvLyBIbW0sIG5vdGhpbmcgd2Ugc2F3IHdhcyBvYnNlcnZlZCBhbmQgY29uZmlybWVkIHR3aWNlLiBJZiB3ZSBoYWRcbiAgLy8gYW55IGd1ZXNzIGF0IGFsbCwgcmV0dXJuIGl0LlxuICAgICAgICBpZiAoISh0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlQ2VudGVyc1swXTtcbiAgICB9XG5cbiAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBmaW5kIGVub3VnaCBhbGlnbm1lbnQgcGF0dGVybnNcIjtcbiAgICB9O1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICB2YXIgR3JpZFNhbXBsZXIgPSB7fTtcblxuICAgIEdyaWRTYW1wbGVyLmNoZWNrQW5kTnVkZ2VQb2ludHMgPSBmdW5jdGlvbihpbWFnZSwgcG9pbnRzKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAvLyBDaGVjayBhbmQgbnVkZ2UgcG9pbnRzIGZyb20gc3RhcnQgdW50aWwgd2Ugc2VlIHNvbWUgdGhhdCBhcmUgT0s6XG4gICAgICAgIHZhciBudWRnZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXQgKyAxXSk7XG4gICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgXCJFcnJvci5jaGVja0FuZE51ZGdlUG9pbnRzIFwiO1xuICAgICAgfVxuICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgfVxuICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7XG4gICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoeSA9PT0gaGVpZ2h0KSB7XG4gICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgfVxuICAgIH1cbiAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIGVuZDpcbiAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gcG9pbnRzLmxlbmd0aCAtIDI7IG9mZnNldCA+PSAwICYmIG51ZGdlZDsgb2Zmc2V0IC09IDIpIHtcbiAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXQgKyAxXSk7XG4gICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhyb3cgXCJFcnJvci5jaGVja0FuZE51ZGdlUG9pbnRzIFwiO1xuICAgICAgfVxuICAgICAgICBudWRnZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XG4gICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoeCA9PT0gd2lkdGgpIHtcbiAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgfVxuICAgICAgICBpZiAoeSA9PT0gLTEpIHtcbiAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7XG4gICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoeSA9PT0gaGVpZ2h0KSB7XG4gICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XG4gICAgICAgIG51ZGdlZCA9IHRydWU7XG4gICAgfVxuICAgIH1cbiAgICB9O1xuXG5cblxuICAgIEdyaWRTYW1wbGVyLnNhbXBsZUdyaWQzID0gZnVuY3Rpb24oaW1hZ2UsIGRpbWVuc2lvbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBiaXRzID0gbmV3IEJpdE1hdHJpeChkaW1lbnNpb24pO1xuICAgICAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KGRpbWVuc2lvbiA8PCAxKTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkaW1lbnNpb247IHkrKykge1xuICAgICAgICB2YXIgbWF4ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGlWYWx1ZSA9IHkgKyAwLjU7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbeF0gPSAoeCA+PiAxKSArIDAuNTtcbiAgICAgICAgICBwb2ludHNbeCArIDFdID0gaVZhbHVlO1xuICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm0udHJhbnNmb3JtUG9pbnRzMShwb2ludHMpO1xuICAgIC8vIFF1aWNrIGNoZWNrIHRvIHNlZSBpZiBwb2ludHMgdHJhbnNmb3JtZWQgdG8gc29tZXRoaW5nIGluc2lkZSB0aGUgaW1hZ2VcbiAgICAvLyBzdWZmaWNpZW50IHRvIGNoZWNrIHRoZSBlbmRwb2ludHNcbiAgICAgICAgR3JpZFNhbXBsZXIuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heDsgeCArPSAyKSB7XG4gICAgICAgICAgICB2YXIgYml0ID0gaW1hZ2UuZGF0YVtNYXRoLmZsb29yKHBvaW50c1t4XSkgKyBpbWFnZS53aWR0aCAqIE1hdGguZmxvb3IocG9pbnRzW3ggKyAxXSldO1xuICAgICAgICAgICAgaWYgKGJpdClcbiAgICAgICAgICAgICAgYml0cy5zZXRfUmVuYW1lZCh4ID4+IDEsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChhaW9vYmUpIHtcbiAgICAgIC8vIFRoaXMgZmVlbHMgd3JvbmcsIGJ1dCwgc29tZXRpbWVzIGlmIHRoZSBmaW5kZXIgcGF0dGVybnMgYXJlIG1pc2lkZW50aWZpZWQsIHRoZSByZXN1bHRpbmdcbiAgICAgIC8vIHRyYW5zZm9ybSBnZXRzIFwidHdpc3RlZFwiIHN1Y2ggdGhhdCBpdCBtYXBzIGEgc3RyYWlnaHQgbGluZSBvZiBwb2ludHMgdG8gYSBzZXQgb2YgcG9pbnRzXG4gICAgICAvLyB3aG9zZSBlbmRwb2ludHMgYXJlIGluIGJvdW5kcywgYnV0IG90aGVycyBhcmUgbm90LiBUaGVyZSBpcyBwcm9iYWJseSBzb21lIG1hdGhlbWF0aWNhbFxuICAgICAgLy8gd2F5IHRvIGRldGVjdCB0aGlzIGFib3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiB0aGF0IEkgZG9uJ3Qga25vdyB5ZXQuXG4gICAgICAvLyBUaGlzIHJlc3VsdHMgaW4gYW4gdWdseSBydW50aW1lIGV4Y2VwdGlvbiBkZXNwaXRlIG91ciBjbGV2ZXIgY2hlY2tzIGFib3ZlIC0tIGNhbid0IGhhdmVcbiAgICAgIC8vIHRoYXQuIFdlIGNvdWxkIGNoZWNrIGVhY2ggcG9pbnQncyBjb29yZGluYXRlcyBidXQgdGhhdCBmZWVscyBkdXBsaWNhdGl2ZS4gV2Ugc2V0dGxlIGZvclxuICAgICAgLy8gY2F0Y2hpbmcgYW5kIHdyYXBwaW5nIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5cbiAgICAgICAgdGhyb3cgXCJFcnJvci5jaGVja0FuZE51ZGdlUG9pbnRzXCI7XG4gICAgfVxuICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfTtcblxuLypcbiAgUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuICBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuKi9cblxuLypcbipcbiogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4gICAgdmFyIE1JTl9TS0lQID0gMztcbiAgICB2YXIgTUFYX01PRFVMRVMgPSA1NztcbiAgICB2YXIgSU5URUdFUl9NQVRIX1NISUZUID0gODtcbiAgICB2YXIgQ0VOVEVSX1FVT1JVTSA9IDI7XG5cbiAgICBmdW5jdGlvbiBvcmRlckJlc3RQYXR0ZXJucyhwYXR0ZXJucykge1xuXG4gICAgICAgIGZ1bmN0aW9uIGRpc3RhbmNlKHBhdHRlcm4xLCBwYXR0ZXJuMikge1xuICAgICAgICB2YXIgeERpZmYgPSBwYXR0ZXJuMS5YIC0gcGF0dGVybjIuWDtcbiAgICAgICAgdmFyIHlEaWZmID0gcGF0dGVybjEuWSAtIHBhdHRlcm4yLlk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKSk7XG4gICAgfVxuXG4gIC8vLyA8c3VtbWFyeT4gUmV0dXJucyB0aGUgeiBjb21wb25lbnQgb2YgdGhlIGNyb3NzIHByb2R1Y3QgYmV0d2VlbiB2ZWN0b3JzIEJDIGFuZCBCQS48L3N1bW1hcnk+XG4gICAgICAgIGZ1bmN0aW9uIGNyb3NzUHJvZHVjdFoocG9pbnRBLCBwb2ludEIsIHBvaW50Qykge1xuICAgICAgICB2YXIgYlggPSBwb2ludEIueDtcbiAgICAgICAgdmFyIGJZID0gcG9pbnRCLnk7XG4gICAgICAgIHJldHVybiAoKHBvaW50Qy54IC0gYlgpICogKHBvaW50QS55IC0gYlkpKSAtICgocG9pbnRDLnkgLSBiWSkgKiAocG9pbnRBLnggLSBiWCkpO1xuICAgIH1cblxuXG4gIC8vIEZpbmQgZGlzdGFuY2VzIGJldHdlZW4gcGF0dGVybiBjZW50ZXJzXG4gICAgICAgIHZhciB6ZXJvT25lRGlzdGFuY2UgPSBkaXN0YW5jZShwYXR0ZXJuc1swXSwgcGF0dGVybnNbMV0pO1xuICAgICAgICB2YXIgb25lVHdvRGlzdGFuY2UgPSBkaXN0YW5jZShwYXR0ZXJuc1sxXSwgcGF0dGVybnNbMl0pO1xuICAgICAgICB2YXIgemVyb1R3b0Rpc3RhbmNlID0gZGlzdGFuY2UocGF0dGVybnNbMF0sIHBhdHRlcm5zWzJdKTtcblxuICAgICAgICB2YXIgcG9pbnRBLCBwb2ludEIsIHBvaW50QztcbiAgLy8gQXNzdW1lIG9uZSBjbG9zZXN0IHRvIG90aGVyIHR3byBpcyBCOyBBIGFuZCBDIHdpbGwganVzdCBiZSBndWVzc2VzIGF0IGZpcnN0XG4gICAgICAgIGlmIChvbmVUd29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UgJiYgb25lVHdvRGlzdGFuY2UgPj0gemVyb1R3b0Rpc3RhbmNlKSB7XG4gICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzBdO1xuICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1sxXTtcbiAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMl07XG4gICAgfSBlbHNlIGlmICh6ZXJvVHdvRGlzdGFuY2UgPj0gb25lVHdvRGlzdGFuY2UgJiYgemVyb1R3b0Rpc3RhbmNlID49IHplcm9PbmVEaXN0YW5jZSkge1xuICAgICAgcG9pbnRCID0gcGF0dGVybnNbMV07XG4gICAgICBwb2ludEEgPSBwYXR0ZXJuc1swXTtcbiAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzJdO1xuICB9IGVsc2Uge1xuICAgICAgcG9pbnRCID0gcGF0dGVybnNbMl07XG4gICAgICBwb2ludEEgPSBwYXR0ZXJuc1swXTtcbiAgICAgIHBvaW50QyA9IHBhdHRlcm5zWzFdO1xuICB9XG5cbiAgLy8gVXNlIGNyb3NzIHByb2R1Y3QgdG8gZmlndXJlIG91dCB3aGV0aGVyIEEgYW5kIEMgYXJlIGNvcnJlY3Qgb3IgZmxpcHBlZC5cbiAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XG4gIC8vIHdlIHdhbnQgZm9yIEEsIEIsIEMuIElmIGl0J3MgbmVnYXRpdmUsIHRoZW4gd2UndmUgZ290IGl0IGZsaXBwZWQgYXJvdW5kIGFuZFxuICAvLyBzaG91bGQgc3dhcCBBIGFuZCBDLlxuICAgICAgICBpZiAoY3Jvc3NQcm9kdWN0Wihwb2ludEEsIHBvaW50QiwgcG9pbnRDKSA8IDAuMCkge1xuICAgICAgICB2YXIgdGVtcCA9IHBvaW50QTtcbiAgICAgICAgcG9pbnRBID0gcG9pbnRDO1xuICAgICAgICBwb2ludEMgPSB0ZW1wO1xuICAgIH1cblxuICAgICAgICBwYXR0ZXJuc1swXSA9IHBvaW50QTtcbiAgICAgICAgcGF0dGVybnNbMV0gPSBwb2ludEI7XG4gICAgICAgIHBhdHRlcm5zWzJdID0gcG9pbnRDO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gRmluZGVyUGF0dGVybihwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplKSB7XG4gICAgICAgIHRoaXMueCA9IHBvc1g7XG4gICAgICAgIHRoaXMueSA9IHBvc1k7XG4gICAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgICB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgPSBlc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZSwgXCJYXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmluZGVyUGF0dGVybi5wcm90b3R5cGUsIFwiWVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnk7XG4gICAgfVxuICAgIH0pO1xuXG4gICAgRmluZGVyUGF0dGVybi5wcm90b3R5cGUuaW5jcmVtZW50Q291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgIH07XG5cbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5hYm91dEVxdWFscyA9IGZ1bmN0aW9uKG1vZHVsZVNpemUsIGksIGopIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLnkpIDw9IG1vZHVsZVNpemUgJiYgTWF0aC5hYnMoaiAtIHRoaXMueCkgPD0gbW9kdWxlU2l6ZSkge1xuICAgICAgICB2YXIgbW9kdWxlU2l6ZURpZmYgPSBNYXRoLmFicyhtb2R1bGVTaXplIC0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiAvIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA8PSAxLjA7XG4gICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEZpbmRlclBhdHRlcm5JbmZvKHBhdHRlcm5DZW50ZXJzKSB7XG4gICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzBdO1xuICAgICAgICB0aGlzLnRvcExlZnQgPSBwYXR0ZXJuQ2VudGVyc1sxXTtcbiAgICAgICAgdGhpcy50b3BSaWdodCA9IHBhdHRlcm5DZW50ZXJzWzJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZpbmRlclBhdHRlcm5GaW5kZXIoKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdO1xuICAgICAgICB0aGlzLmhhc1NraXBwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUsIFwiQ3Jvc3NDaGVja1N0YXRlQ291bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50WzBdID0gMDtcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudFsxXSA9IDA7XG4gICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50WzNdID0gMDtcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudFs0XSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuICAgIH1cbiAgICB9KTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZvdW5kUGF0dGVybkNyb3NzID0gZnVuY3Rpb24oc3RhdGVDb3VudCkge1xuICAgICAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgdmFyIGNvdW50ID0gc3RhdGVDb3VudFtpXTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gY291bnQ7XG4gICAgfVxuICAgICAgICBpZiAodG90YWxNb2R1bGVTaXplIDwgNykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IE1hdGguZmxvb3IoKHRvdGFsTW9kdWxlU2l6ZSA8PCBJTlRFR0VSX01BVEhfU0hJRlQpIC8gNyk7XG4gICAgICAgIHZhciBtYXhWYXJpYW5jZSA9IE1hdGguZmxvb3IobW9kdWxlU2l6ZSAvIDIpO1xuICAvLyBBbGxvdyBsZXNzIHRoYW4gNTAlIHZhcmlhbmNlIGZyb20gMS0xLTMtMS0xIHByb3BvcnRpb25zXG4gICAgICAgIHJldHVybiBNYXRoLmFicyhtb2R1bGVTaXplIC0gKHN0YXRlQ291bnRbMF0gPDwgSU5URUdFUl9NQVRIX1NISUZUKSkgPCBtYXhWYXJpYW5jZSAmJiBNYXRoLmFicyhtb2R1bGVTaXplIC0gKHN0YXRlQ291bnRbMV0gPDwgSU5URUdFUl9NQVRIX1NISUZUKSkgPCBtYXhWYXJpYW5jZSAmJiBNYXRoLmFicygzICogbW9kdWxlU2l6ZSAtIChzdGF0ZUNvdW50WzJdIDw8IElOVEVHRVJfTUFUSF9TSElGVCkpIDwgMyAqIG1heFZhcmlhbmNlICYmIE1hdGguYWJzKG1vZHVsZVNpemUgLSAoc3RhdGVDb3VudFszXSA8PCBJTlRFR0VSX01BVEhfU0hJRlQpKSA8IG1heFZhcmlhbmNlICYmIE1hdGguYWJzKG1vZHVsZVNpemUgLSAoc3RhdGVDb3VudFs0XSA8PCBJTlRFR0VSX01BVEhfU0hJRlQpKSA8IG1heFZhcmlhbmNlO1xuICAgIH07XG5cbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5jZW50ZXJGcm9tRW5kID0gZnVuY3Rpb24oc3RhdGVDb3VudCwgZW5kKSB7XG4gICAgICAgIHJldHVybiAoZW5kIC0gc3RhdGVDb3VudFs0XSAtIHN0YXRlQ291bnRbM10pIC0gc3RhdGVDb3VudFsyXSAvIDIuMDtcbiAgICB9O1xuXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24oc3RhcnRJLCBjZW50ZXJKLCBtYXhDb3VudCwgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLkNyb3NzQ2hlY2tTdGF0ZUNvdW50O1xuXG4gIC8vIFN0YXJ0IGNvdW50aW5nIHVwIGZyb20gY2VudGVyXG4gICAgICAgIHZhciBpID0gc3RhcnRJO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0pIHtcbiAgICAgICAgc3RhdGVDb3VudFsyXSsrO1xuICAgICAgICBpLS07XG4gICAgfVxuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFsxXSA8PSBtYXhDb3VudCkge1xuICAgICAgICBzdGF0ZUNvdW50WzFdKys7XG4gICAgICAgIGktLTtcbiAgICB9XG4gIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XG4gICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZGF0YVtjZW50ZXJKICsgaSAqIGltYWdlLndpZHRoXSAmJiBzdGF0ZUNvdW50WzBdIDw9IG1heENvdW50KSB7XG4gICAgICAgIHN0YXRlQ291bnRbMF0rKztcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXG4gICAgICAgIGkgPSBzdGFydEkgKyAxO1xuICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgaW1hZ2UuZGF0YVtjZW50ZXJKICsgaSAqIGltYWdlLndpZHRoXSkge1xuICAgICAgICBzdGF0ZUNvdW50WzJdKys7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgICAgIGlmIChpID09PSBtYXhJKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgICAgICB3aGlsZSAoaSA8IG1heEkgJiYgIWltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XG4gICAgICAgIHN0YXRlQ291bnRbM10rKztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICAgICAgaWYgKGkgPT09IG1heEkgfHwgc3RhdGVDb3VudFszXSA+PSBtYXhDb3VudCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmRhdGFbY2VudGVySiArIGkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XG4gICAgICAgIHN0YXRlQ291bnRbNF0rKztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICAgICAgaWYgKHN0YXRlQ291bnRbNF0gPj0gbWF4Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgLy8gSWYgd2UgZm91bmQgYSBmaW5kZXItcGF0dGVybi1saWtlIHNlY3Rpb24sIGJ1dCBpdHMgc2l6ZSBpcyBtb3JlIHRoYW4gNDAlIGRpZmZlcmVudCB0aGFuXG4gIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XG4gICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IHRoaXMuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcbiAgICB9O1xuXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja0hvcml6b250YWwgPSBmdW5jdGlvbihzdGFydEosIGNlbnRlckksIG1heENvdW50LCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAgIHZhciBtYXhKID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gdGhpcy5Dcm9zc0NoZWNrU3RhdGVDb3VudDtcblxuICAgICAgICB2YXIgaiA9IHN0YXJ0SjtcbiAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBpbWFnZS5kYXRhW2ogKyBjZW50ZXJJICogaW1hZ2Uud2lkdGhdKSB7XG4gICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgai0tO1xuICAgIH1cbiAgICAgICAgaWYgKGogPCAwKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgICAgICB3aGlsZSAoaiA+PSAwICYmICFpbWFnZS5kYXRhW2ogKyBjZW50ZXJJICogaW1hZ2Uud2lkdGhdICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcbiAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xuICAgICAgICBqLS07XG4gICAgfVxuICAgICAgICBpZiAoaiA8IDAgfHwgc3RhdGVDb3VudFsxXSA+IG1heENvdW50KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgICAgICB3aGlsZSAoaiA+PSAwICYmIGltYWdlLmRhdGFbaiArIGNlbnRlckkgKiBpbWFnZS53aWR0aF0gJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xuICAgICAgICBzdGF0ZUNvdW50WzBdKys7XG4gICAgICAgIGotLTtcbiAgICB9XG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAgICAgaiA9IHN0YXJ0SiArIDE7XG4gICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiBpbWFnZS5kYXRhW2ogKyBjZW50ZXJJICogaW1hZ2Uud2lkdGhdKSB7XG4gICAgICAgIHN0YXRlQ291bnRbMl0rKztcbiAgICAgICAgaisrO1xuICAgIH1cbiAgICAgICAgaWYgKGogPT09IG1heEopIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgICAgIHdoaWxlIChqIDwgbWF4SiAmJiAhaW1hZ2UuZGF0YVtqICsgY2VudGVySSAqIGltYWdlLndpZHRoXSAmJiBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgc3RhdGVDb3VudFszXSsrO1xuICAgICAgICBqKys7XG4gICAgfVxuICAgICAgICBpZiAoaiA9PT0gbWF4SiB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgaW1hZ2UuZGF0YVtqICsgY2VudGVySSAqIGltYWdlLndpZHRoXSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcbiAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xuICAgICAgICBqKys7XG4gICAgfVxuICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIHNpZ25pZmljYW50bHkgZGlmZmVyZW50IHRoYW5cbiAgLy8gdGhlIG9yaWdpbmFsLCBhc3N1bWUgaXQncyBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICsgc3RhdGVDb3VudFs0XTtcbiAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkgPyB0aGlzLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaikgOiBOYU47XG4gICAgfTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmhhbmRsZVBvc3NpYmxlQ2VudGVyID0gZnVuY3Rpb24oc3RhdGVDb3VudCwgaSwgaikge1xuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XG4gICAgICAgIHZhciBjZW50ZXJKID0gdGhpcy5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGopOyAvL2Zsb2F0XG4gICAgICAgIHZhciBjZW50ZXJJID0gdGhpcy5jcm9zc0NoZWNrVmVydGljYWwoaSwgTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTsgLy9mbG9hdFxuICAgICAgICBpZiAoIWlzTmFOKGNlbnRlckkpKSB7XG4gICAgLy8gUmUtY3Jvc3MgY2hlY2tcbiAgICAgICAgY2VudGVySiA9IHRoaXMuY3Jvc3NDaGVja0hvcml6b250YWwoTWF0aC5mbG9vcihjZW50ZXJKKSwgTWF0aC5mbG9vcihjZW50ZXJJKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcbiAgICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSkge1xuICAgICAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gc3RhdGVDb3VudFRvdGFsIC8gNy4wO1xuICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMucG9zc2libGVDZW50ZXJzW2luZGV4XTtcbiAgICAgICAgLy8gTG9vayBmb3IgYWJvdXQgdGhlIHNhbWUgY2VudGVyIGFuZCBtb2R1bGUgc2l6ZTpcbiAgICAgICAgICAgIGlmIChjZW50ZXIuYWJvdXRFcXVhbHMoZXN0aW1hdGVkTW9kdWxlU2l6ZSwgY2VudGVySSwgY2VudGVySikpIHtcbiAgICAgICAgICAgICAgY2VudGVyLmluY3JlbWVudENvdW50KCk7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IEZpbmRlclBhdHRlcm4oY2VudGVySiwgY2VudGVySSwgZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLnNlbGVjdEJlc3RQYXR0ZXJucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzdGFydFNpemUgPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydFNpemUgPCAzKSB7XG4gICAgLy8gQ291bGRuJ3QgZmluZCBlbm91Z2ggZmluZGVyIHBhdHRlcm5zXG4gICAgICAgIHRocm93IFwiQ291bGRuJ3QgZmluZCBlbm91Z2ggZmluZGVyIHBhdHRlcm5zOlwiICsgc3RhcnRTaXplICsgXCIgcGF0dGVybnMgZm91bmRcIjtcbiAgICB9XG5cbiAgLy8gRmlsdGVyIG91dGxpZXIgcG9zc2liaWxpdGllcyB3aG9zZSBtb2R1bGUgc2l6ZSBpcyB0b28gZGlmZmVyZW50XG4gICAgICAgIGlmIChzdGFydFNpemUgPiAzKSB7XG4gICAgLy8gQnV0IHdlIGNhbiBvbmx5IGFmZm9yZCB0byBkbyBzbyBpZiB3ZSBoYXZlIGF0IGxlYXN0IDQgcG9zc2liaWxpdGllcyB0byBjaG9vc2UgZnJvbVxuICAgICAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMC4wO1xuICAgICAgICB2YXIgc3F1YXJlID0gMC4wO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNlbnRlclZhbHVlID0gdGhpcy5wb3NzaWJsZUNlbnRlcnNbaV0uZXN0aW1hdGVkTW9kdWxlU2l6ZTtcbiAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gY2VudGVyVmFsdWU7XG4gICAgICAgICAgc3F1YXJlICs9IChjZW50ZXJWYWx1ZSAqIGNlbnRlclZhbHVlKTtcbiAgICAgIH1cbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBzdGFydFNpemU7XG4gICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzLnNvcnQoZnVuY3Rpb24oY2VudGVyMSwgY2VudGVyMikge1xuICAgICAgICAgIHZhciBkQSA9IE1hdGguYWJzKGNlbnRlcjIuZXN0aW1hdGVkTW9kdWxlU2l6ZSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgIHZhciBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZXN0aW1hdGVkTW9kdWxlU2l6ZSAtIGF2ZXJhZ2UpO1xuICAgICAgICAgIGlmIChkQSA8IGRCKSB7XG4gICAgICAgICAgICByZXR1cm4gKC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChkQSA9PT0gZEIpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICB9KTtcblxuICAgICAgICB2YXIgc3RkRGV2ID0gTWF0aC5zcXJ0KHNxdWFyZSAvIHN0YXJ0U2l6ZSAtIGF2ZXJhZ2UgKiBhdmVyYWdlKTtcbiAgICAgICAgdmFyIGxpbWl0ID0gTWF0aC5tYXgoMC4yICogYXZlcmFnZSwgc3RkRGV2KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucG9zc2libGVDZW50ZXJzIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucG9zc2libGVDZW50ZXJzW2ldO1xuICAgICAgICAgIGlmIChNYXRoLmFicyhwYXR0ZXJuLmVzdGltYXRlZE1vZHVsZVNpemUgLSBhdmVyYWdlKSA+IGxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDMpIHtcbiAgICAvLyBUaHJvdyBhd2F5IGFsbCBidXQgdGhvc2UgZmlyc3Qgc2l6ZSBjYW5kaWRhdGUgcG9pbnRzIHdlIGZvdW5kLlxuICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICBpZiAoYS5jb3VudCA+IGIuY291bnQpIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoYS5jb3VudCA8IGIuY291bnQpIHJldHVybiAxO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgICAgIHJldHVybiBbdGhpcy5wb3NzaWJsZUNlbnRlcnNbMF0sIHRoaXMucG9zc2libGVDZW50ZXJzWzFdLCB0aGlzLnBvc3NpYmxlQ2VudGVyc1syXV07XG4gICAgfTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmRSb3dTa2lwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XG4gICAgICAgIGlmIChtYXggPD0gMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgICAgIHZhciBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMucG9zc2libGVDZW50ZXJzW2ldO1xuICAgICAgICBpZiAoY2VudGVyLmNvdW50ID49IENFTlRFUl9RVU9SVU0pIHtcbiAgICAgICAgICBpZiAoZmlyc3RDb25maXJtZWRDZW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpcnN0Q29uZmlybWVkQ2VudGVyID0gY2VudGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBoYXZlIHR3byBjb25maXJtZWQgY2VudGVyc1xuICAgICAgICAvLyBIb3cgZmFyIGRvd24gY2FuIHdlIHNraXAgYmVmb3JlIHJlc3VtaW5nIGxvb2tpbmcgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIHBhdHRlcm4/IEluIHRoZSB3b3JzdCBjYXNlLCBvbmx5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlXG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gdGhlIHggLyB5IGNvb3JkaW5hdGVzIG9mIHRoZSB0d28gY2VudGVycy5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB5b3UgZmluZCB0b3AgbGVmdCBsYXN0LlxuICAgICAgICAgICAgdGhpcy5oYXNTa2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKChNYXRoLmFicyhmaXJzdENvbmZpcm1lZENlbnRlci5YIC0gY2VudGVyLlgpIC0gTWF0aC5hYnMoZmlyc3RDb25maXJtZWRDZW50ZXIuWSAtIGNlbnRlci5ZKSkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDtcbiAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMucG9zc2libGVDZW50ZXJzW2ldO1xuICAgICAgICBpZiAocGF0dGVybi5jb3VudCA+PSBDRU5URVJfUVVPUlVNKSB7XG4gICAgICAgICAgY29uZmlybWVkQ291bnQrKztcbiAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gcGF0dGVybi5lc3RpbWF0ZWRNb2R1bGVTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAgICAgaWYgKGNvbmZpcm1lZENvdW50IDwgMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAvLyBPSywgd2UgaGF2ZSBhdCBsZWFzdCAzIGNvbmZpcm1lZCBjZW50ZXJzLCBidXQsIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgaXMgYSBcImZhbHNlIHBvc2l0aXZlXCJcbiAgLy8gYW5kIHRoYXQgd2UgbmVlZCB0byBrZWVwIGxvb2tpbmcuIFdlIGRldGVjdCB0aGlzIGJ5IGFza2luZyBpZiB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplc1xuICAvLyB2YXJ5IHRvbyBtdWNoLiBXZSBhcmJpdHJhcmlseSBzYXkgdGhhdCB3aGVuIHRoZSB0b3RhbCBkZXZpYXRpb24gZnJvbSBhdmVyYWdlIGV4Y2VlZHNcbiAgLy8gNSUgb2YgdGhlIHRvdGFsIG1vZHVsZSBzaXplIGVzdGltYXRlcywgaXQncyB0b28gbXVjaC5cbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBtYXg7XG4gICAgICAgIHZhciB0b3RhbERldmlhdGlvbiA9IDAuMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICBwYXR0ZXJuID0gdGhpcy5wb3NzaWJsZUNlbnRlcnNbaV07XG4gICAgICAgIHRvdGFsRGV2aWF0aW9uICs9IE1hdGguYWJzKHBhdHRlcm4uZXN0aW1hdGVkTW9kdWxlU2l6ZSAtIGF2ZXJhZ2UpO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsRGV2aWF0aW9uIDw9IDAuMDUgKiB0b3RhbE1vZHVsZVNpemU7XG4gICAgfTtcblxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmRGaW5kZXJQYXR0ZXJuID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICAgICAgdmFyIHRyeUhhcmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIHZhciBtYXhJID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICB2YXIgbWF4SiA9IGltYWdlLndpZHRoO1xuICAgICAgICB2YXIgaVNraXAgPSBNYXRoLmZsb29yKCgzICogbWF4SSkgLyAoNCAqIE1BWF9NT0RVTEVTKSk7XG4gICAgICAgIGlmIChpU2tpcCA8IE1JTl9TS0lQIHx8IHRyeUhhcmRlcikge1xuICAgICAgICBpU2tpcCA9IE1JTl9TS0lQO1xuICAgIH1cblxuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhdGVDb3VudCA9IG5ldyBBcnJheSg1KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcbiAgICAvLyBHZXQgYSByb3cgb2YgYmxhY2svd2hpdGUgdmFsdWVzXG4gICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xuICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XG4gICAgICAgIHN0YXRlQ291bnRbM10gPSAwO1xuICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4SjsgaisrKSB7XG4gICAgICAgICAgaWYgKGltYWdlLmRhdGFbaiArIGkgKiBpbWFnZS53aWR0aF0pIHtcbiAgICAgICAgLy8gQmxhY2sgcGl4ZWxcbiAgICAgICAgICAgIGlmICgoY3VycmVudFN0YXRlICYgMSkgPT09IDEpIHtcbiAgICAgICAgICAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XG4gICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGVDb3VudFtjdXJyZW50U3RhdGVdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoaXRlIHBpeGVsXG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRTdGF0ZSAmIDEpID09PSAwKSB7XG4gICAgICAgICAgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIC8vIEEgd2lubmVyP1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7XG4gICAgICAgICAgICAgIC8vIFllc1xuICAgICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgaik7XG4gICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZXhhbWluaW5nIGV2ZXJ5IG90aGVyIGxpbmUuIENoZWNraW5nIGVhY2ggbGluZSB0dXJuZWQgb3V0IHRvIGJlIHRvb1xuICAgICAgICAgICAgICAgIC8vIGV4cGVuc2l2ZSBhbmQgZGlkbid0IGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgICAgICAgIGlTa2lwID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2tpcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHJvd1NraXAgPSB0aGlzLmZpbmRSb3dTa2lwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd1NraXAgPiBzdGF0ZUNvdW50WzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZXR3ZWVuIHJvdyBvZiBsb3dlciBjb25maXJtZWQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0b3Agb2YgcHJlc3VtZWQgdGhpcmQgY29uZmlybWVkIGNlbnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgYmFjayB1cCBhIGJpdCB0byBnZXQgYSBmdWxsIGNoYW5jZSBvZiBkZXRlY3RpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQsIGVudGlyZSB3aWR0aCBvZiBjZW50ZXIgb2YgZmluZGVyIHBhdHRlcm5cblxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIHBhdHRlcm4gd2Ugc2F3KSB0byBiZSBjb25zZXJ2YXRpdmUsIGFuZCBhbHNvIGJhY2sgb2ZmIGJ5IGlTa2lwIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFib3V0IHRvIGJlIHJlLWFkZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IHJvd1NraXAgLSBzdGF0ZUNvdW50WzJdIC0gaVNraXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gbWF4SiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gbmV4dCBibGFjayBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmRhdGFbaiArIGkgKiBpbWFnZS53aWR0aF0pO1xuICAgICAgICAgICAgICAgICAgICBqLS07IC8vIGJhY2sgdXAgdG8gdGhhdCBsYXN0IHdoaXRlIHBpeGVsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBDbGVhciBzdGF0ZSB0byBzdGFydCBsb29raW5nIGFnYWluXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDA7XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm8sIHNoaWZ0IGNvdW50cyBiYWNrIGJ5IHR3b1xuICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IHN0YXRlQ291bnRbMl07XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcbiAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSBzdGF0ZUNvdW50WzRdO1xuICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFszXSA9IDE7XG4gICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvdW50aW5nIHdoaXRlIHBpeGVsc1xuICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm91bmRQYXR0ZXJuQ3Jvc3Moc3RhdGVDb3VudCkpIHtcbiAgICAgICAgICB2YXIgY29uZmlybWVkID0gdGhpcy5oYW5kbGVQb3NzaWJsZUNlbnRlcihzdGF0ZUNvdW50LCBpLCBtYXhKKTtcbiAgICAgICAgICBpZiAoY29uZmlybWVkKSB7XG4gICAgICAgICAgICBpU2tpcCA9IHN0YXRlQ291bnRbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkKSB7XG4gICAgICAgICAgLy8gRm91bmQgYSB0aGlyZCBvbmVcbiAgICAgICAgICAgICAgZG9uZSA9IHRoaXMuaGF2ZU11bHRpcGx5Q29uZmlybWVkQ2VudGVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICAgICB2YXIgcGF0dGVybkluZm8gPSB0aGlzLnNlbGVjdEJlc3RQYXR0ZXJucygpO1xuICAgICAgICBvcmRlckJlc3RQYXR0ZXJucyhwYXR0ZXJuSW5mbyk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGaW5kZXJQYXR0ZXJuSW5mbyhwYXR0ZXJuSW5mbyk7XG4gICAgfTtcblxuLypcbiAgUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuICBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuKi9cblxuLypcbipcbiogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG4gICAgZnVuY3Rpb24gUGVyc3BlY3RpdmVUcmFuc2Zvcm0oYTExLCBhMjEsIGEzMSwgYTEyLCBhMjIsIGEzMiwgYTEzLCBhMjMsIGEzMykge1xuICAgICAgICB0aGlzLmExMSA9IGExMTtcbiAgICAgICAgdGhpcy5hMTIgPSBhMTI7XG4gICAgICAgIHRoaXMuYTEzID0gYTEzO1xuICAgICAgICB0aGlzLmEyMSA9IGEyMTtcbiAgICAgICAgdGhpcy5hMjIgPSBhMjI7XG4gICAgICAgIHRoaXMuYTIzID0gYTIzO1xuICAgICAgICB0aGlzLmEzMSA9IGEzMTtcbiAgICAgICAgdGhpcy5hMzIgPSBhMzI7XG4gICAgICAgIHRoaXMuYTMzID0gYTMzO1xuICAgIH1cblxuICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludHMxID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgIHZhciBtYXggPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgYTExID0gdGhpcy5hMTE7XG4gICAgICAgIHZhciBhMTIgPSB0aGlzLmExMjtcbiAgICAgICAgdmFyIGExMyA9IHRoaXMuYTEzO1xuICAgICAgICB2YXIgYTIxID0gdGhpcy5hMjE7XG4gICAgICAgIHZhciBhMjIgPSB0aGlzLmEyMjtcbiAgICAgICAgdmFyIGEyMyA9IHRoaXMuYTIzO1xuICAgICAgICB2YXIgYTMxID0gdGhpcy5hMzE7XG4gICAgICAgIHZhciBhMzIgPSB0aGlzLmEzMjtcbiAgICAgICAgdmFyIGEzMyA9IHRoaXMuYTMzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB4ID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IGExMyAqIHggKyBhMjMgKiB5ICsgYTMzO1xuICAgICAgICBwb2ludHNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICAgIH07XG5cbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnRzMiA9IGZ1bmN0aW9uKHhWYWx1ZXMsIHlWYWx1ZXMpIHtcbiAgICAgICAgdmFyIG4gPSB4VmFsdWVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHggPSB4VmFsdWVzW2ldO1xuICAgICAgICB2YXIgeSA9IHlWYWx1ZXNbaV07XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMuYTEzICogeCArIHRoaXMuYTIzICogeSArIHRoaXMuYTMzO1xuICAgICAgICB4VmFsdWVzW2ldID0gKHRoaXMuYTExICogeCArIHRoaXMuYTIxICogeSArIHRoaXMuYTMxKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICB5VmFsdWVzW2ldID0gKHRoaXMuYTEyICogeCArIHRoaXMuYTIyICogeSArIHRoaXMuYTMyKSAvIGRlbm9taW5hdG9yO1xuICAgIH1cbiAgICB9O1xuXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLmJ1aWxkQWRqb2ludCA9IGZ1bmN0aW9uKCkge1xuICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDpcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh0aGlzLmEyMiAqIHRoaXMuYTMzIC0gdGhpcy5hMjMgKiB0aGlzLmEzMiwgdGhpcy5hMjMgKiB0aGlzLmEzMSAtIHRoaXMuYTIxICogdGhpcy5hMzMsIHRoaXMuYTIxICogdGhpcy5hMzIgLSB0aGlzLmEyMiAqIHRoaXMuYTMxLCB0aGlzLmExMyAqIHRoaXMuYTMyIC0gdGhpcy5hMTIgKiB0aGlzLmEzMywgdGhpcy5hMTEgKiB0aGlzLmEzMyAtIHRoaXMuYTEzICogdGhpcy5hMzEsIHRoaXMuYTEyICogdGhpcy5hMzEgLSB0aGlzLmExMSAqIHRoaXMuYTMyLCB0aGlzLmExMiAqIHRoaXMuYTIzIC0gdGhpcy5hMTMgKiB0aGlzLmEyMiwgdGhpcy5hMTMgKiB0aGlzLmEyMSAtIHRoaXMuYTExICogdGhpcy5hMjMsIHRoaXMuYTExICogdGhpcy5hMjIgLSB0aGlzLmExMiAqIHRoaXMuYTIxKTtcbiAgICB9O1xuXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLnRpbWVzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh0aGlzLmExMSAqIG90aGVyLmExMSArIHRoaXMuYTIxICogb3RoZXIuYTEyICsgdGhpcy5hMzEgKiBvdGhlci5hMTMsIHRoaXMuYTExICogb3RoZXIuYTIxICsgdGhpcy5hMjEgKiBvdGhlci5hMjIgKyB0aGlzLmEzMSAqIG90aGVyLmEyMywgdGhpcy5hMTEgKiBvdGhlci5hMzEgKyB0aGlzLmEyMSAqIG90aGVyLmEzMiArIHRoaXMuYTMxICogb3RoZXIuYTMzLCB0aGlzLmExMiAqIG90aGVyLmExMSArIHRoaXMuYTIyICogb3RoZXIuYTEyICsgdGhpcy5hMzIgKiBvdGhlci5hMTMsIHRoaXMuYTEyICogb3RoZXIuYTIxICsgdGhpcy5hMjIgKiBvdGhlci5hMjIgKyB0aGlzLmEzMiAqIG90aGVyLmEyMywgdGhpcy5hMTIgKiBvdGhlci5hMzEgKyB0aGlzLmEyMiAqIG90aGVyLmEzMiArIHRoaXMuYTMyICogb3RoZXIuYTMzLCB0aGlzLmExMyAqIG90aGVyLmExMSArIHRoaXMuYTIzICogb3RoZXIuYTEyICsgdGhpcy5hMzMgKiBvdGhlci5hMTMsIHRoaXMuYTEzICogb3RoZXIuYTIxICsgdGhpcy5hMjMgKiBvdGhlci5hMjIgKyB0aGlzLmEzMyAqIG90aGVyLmEyMywgdGhpcy5hMTMgKiBvdGhlci5hMzEgKyB0aGlzLmEyMyAqIG90aGVyLmEzMiArIHRoaXMuYTMzICogb3RoZXIuYTMzKTtcbiAgICB9O1xuXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDBwLCB5MHAsIHgxcCwgeTFwLCB4MnAsIHkycCwgeDNwLCB5M3ApIHtcblxuICAgICAgICB2YXIgcVRvUyA9IHRoaXMucXVhZHJpbGF0ZXJhbFRvU3F1YXJlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gICAgICAgIHZhciBzVG9RID0gdGhpcy5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDBwLCB5MHAsIHgxcCwgeTFwLCB4MnAsIHkycCwgeDNwLCB5M3ApO1xuICAgICAgICByZXR1cm4gc1RvUS50aW1lcyhxVG9TKTtcbiAgICB9O1xuXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAgIHZhciBkeTIgPSB5MyAtIHkyO1xuICAgICAgICB2YXIgZHkzID0geTAgLSB5MSArIHkyIC0geTM7XG4gICAgICAgIGlmIChkeTIgPT09IDAuMCAmJiBkeTMgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHgxIC0geDAsIHgyIC0geDEsIHgwLCB5MSAtIHkwLCB5MiAtIHkxLCB5MCwgMC4wLCAwLjAsIDEuMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGR4MSA9IHgxIC0geDI7XG4gICAgICAgIHZhciBkeDIgPSB4MyAtIHgyO1xuICAgICAgICB2YXIgZHgzID0geDAgLSB4MSArIHgyIC0geDM7XG4gICAgICAgIHZhciBkeTEgPSB5MSAtIHkyO1xuICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XG4gICAgICAgIHZhciBhMTMgPSAoZHgzICogZHkyIC0gZHgyICogZHkzKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICB2YXIgYTIzID0gKGR4MSAqIGR5MyAtIGR4MyAqIGR5MSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh4MSAtIHgwICsgYTEzICogeDEsIHgzIC0geDAgKyBhMjMgKiB4MywgeDAsIHkxIC0geTAgKyBhMTMgKiB5MSwgeTMgLSB5MCArIGEyMyAqIHkzLCB5MCwgYTEzLCBhMjMsIDEuMCk7XG4gICAgfVxuICAgIH07XG5cbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUgPSBmdW5jdGlvbih4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgLy8gSGVyZSwgdGhlIGFkam9pbnQgc2VydmVzIGFzIHRoZSBpbnZlcnNlOlxuICAgICAgICByZXR1cm4gdGhpcy5zcXVhcmVUb1F1YWRyaWxhdGVyYWwoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKS5idWlsZEFkam9pbnQoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzKSB7XG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERldGVjdG9yKGltYWdlKSB7XG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSkge1xuICAvLyBNaWxkIHZhcmlhbnQgb2YgQnJlc2VuaGFtJ3MgYWxnb3JpdGhtO1xuICAvLyBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVzZW5oYW0nc19saW5lX2FsZ29yaXRobVxuICAgICAgICB2YXIgc3RlZXAgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSkgPiBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XG4gICAgICAgIGlmIChzdGVlcCkge1xuICAgICAgICB2YXIgdGVtcCA9IGZyb21YO1xuICAgICAgICBmcm9tWCA9IGZyb21ZO1xuICAgICAgICBmcm9tWSA9IHRlbXA7XG4gICAgICAgIHRlbXAgPSB0b1g7XG4gICAgICAgIHRvWCA9IHRvWTtcbiAgICAgICAgdG9ZID0gdGVtcDtcbiAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSk7XG4gICAgICAgIHZhciBlcnJvciA9IC1keCA+PiAxO1xuICAgICAgICB2YXIgeXN0ZXAgPSBmcm9tWSA8IHRvWSA/IDEgOiAtMTtcbiAgICAgICAgdmFyIHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XG4gICAgICAgIHZhciBzdGF0ZSA9IDA7IC8vIEluIGJsYWNrIHBpeGVscywgbG9va2luZyBmb3Igd2hpdGUsIGZpcnN0IG9yIHNlY29uZCB0aW1lXG4gICAgICAgIGZvciAodmFyIHggPSBmcm9tWCwgeSA9IGZyb21ZOyB4ICE9PSB0b1g7IHggKz0geHN0ZXApIHtcblxuICAgICAgICB2YXIgcmVhbFggPSBzdGVlcCA/IHkgOiB4O1xuICAgICAgICB2YXIgcmVhbFkgPSBzdGVlcCA/IHggOiB5O1xuICAgICAgICBpZiAoc3RhdGUgPT09IDEpIHtcbiAgICAgIC8vIEluIHdoaXRlIHBpeGVscywgbG9va2luZyBmb3IgYmxhY2tcbiAgICAgICAgICBpZiAodGhpcy5pbWFnZS5kYXRhW3JlYWxYICsgcmVhbFkgKiB0aGlzLmltYWdlLndpZHRoXSkge1xuICAgICAgICAgICAgc3RhdGUrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaW1hZ2UuZGF0YVtyZWFsWCArIHJlYWxZICogdGhpcy5pbWFnZS53aWR0aF0pIHtcbiAgICAgICAgICAgIHN0YXRlKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUgPT09IDMpIHtcbiAgICAgIC8vIEZvdW5kIGJsYWNrLCB3aGl0ZSwgYmxhY2ssIGFuZCBzdHVtYmxlZCBiYWNrIG9udG8gd2hpdGU7IGRvbmVcbiAgICAgICAgICB2YXIgZGlmZlggPSB4IC0gZnJvbVg7XG4gICAgICAgICAgdmFyIGRpZmZZID0geSAtIGZyb21ZO1xuICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoKGRpZmZYICogZGlmZlggKyBkaWZmWSAqIGRpZmZZKSk7XG4gICAgICB9XG4gICAgICAgIGVycm9yICs9IGR5O1xuICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XG4gICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgICB5ICs9IHlzdGVwO1xuICAgICAgICAgIGVycm9yIC09IGR4O1xuICAgICAgfVxuICAgIH1cbiAgICAgICAgdmFyIGRpZmZYMiA9IHRvWCAtIGZyb21YO1xuICAgICAgICB2YXIgZGlmZlkyID0gdG9ZIC0gZnJvbVk7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoKGRpZmZYMiAqIGRpZmZYMiArIGRpZmZZMiAqIGRpZmZZMikpO1xuICAgIH07XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMgPSBmdW5jdGlvbihmcm9tWCwgZnJvbVksIHRvWCwgdG9ZKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YLCBmcm9tWSwgdG9YLCB0b1kpO1xuXG4gIC8vIE5vdyBjb3VudCBvdGhlciB3YXkgLS0gZG9uJ3QgcnVuIG9mZiBpbWFnZSB0aG91Z2ggb2YgY291cnNlXG4gICAgICAgIHZhciBzY2FsZSA9IDEuMDtcbiAgICAgICAgdmFyIG90aGVyVG9YID0gZnJvbVggLSAodG9YIC0gZnJvbVgpO1xuICAgICAgICBpZiAob3RoZXJUb1ggPCAwKSB7XG4gICAgICAgIHNjYWxlID0gZnJvbVggLyAoZnJvbVggLSBvdGhlclRvWCk7XG4gICAgICAgIG90aGVyVG9YID0gMDtcbiAgICB9IGVsc2UgaWYgKG90aGVyVG9YID49IHRoaXMuaW1hZ2Uud2lkdGgpIHtcbiAgICAgIHNjYWxlID0gKHRoaXMuaW1hZ2Uud2lkdGggLSAxIC0gZnJvbVgpIC8gKG90aGVyVG9YIC0gZnJvbVgpO1xuICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLndpZHRoIC0gMTtcbiAgfVxuICAgICAgICB2YXIgb3RoZXJUb1kgPSBNYXRoLmZsb29yKGZyb21ZIC0gKHRvWSAtIGZyb21ZKSAqIHNjYWxlKTtcblxuICAgICAgICBzY2FsZSA9IDEuMDtcbiAgICAgICAgaWYgKG90aGVyVG9ZIDwgMCkge1xuICAgICAgICBzY2FsZSA9IGZyb21ZIC8gKGZyb21ZIC0gb3RoZXJUb1kpO1xuICAgICAgICBvdGhlclRvWSA9IDA7XG4gICAgfSBlbHNlIGlmIChvdGhlclRvWSA+PSB0aGlzLmltYWdlLmhlaWdodCkge1xuICAgICAgc2NhbGUgPSAodGhpcy5pbWFnZS5oZWlnaHQgLSAxIC0gZnJvbVkpIC8gKG90aGVyVG9ZIC0gZnJvbVkpO1xuICAgICAgb3RoZXJUb1kgPSB0aGlzLmltYWdlLmhlaWdodCAtIDE7XG4gIH1cbiAgICAgICAgb3RoZXJUb1ggPSBNYXRoLmZsb29yKGZyb21YICsgKG90aGVyVG9YIC0gZnJvbVgpICogc2NhbGUpO1xuXG4gICAgICAgIHJlc3VsdCArPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bihmcm9tWCwgZnJvbVksIG90aGVyVG9YLCBvdGhlclRvWSk7XG4gICAgICAgIHJldHVybiByZXN1bHQgLSAxLjA7IC8vIC0xIGJlY2F1c2Ugd2UgY291bnRlZCB0aGUgbWlkZGxlIHBpeGVsIHR3aWNlXG4gICAgfTtcblxuICAgIERldGVjdG9yLnByb3RvdHlwZS5jYWxjdWxhdGVNb2R1bGVTaXplT25lV2F5ID0gZnVuY3Rpb24ocGF0dGVybiwgb3RoZXJQYXR0ZXJuKSB7XG4gICAgICAgIHZhciBtb2R1bGVTaXplRXN0MSA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoTWF0aC5mbG9vcihwYXR0ZXJuLlgpLCBNYXRoLmZsb29yKHBhdHRlcm4uWSksIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLlgpLCBNYXRoLmZsb29yKG90aGVyUGF0dGVybi5ZKSk7XG4gICAgICAgIHZhciBtb2R1bGVTaXplRXN0MiA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMoTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uWCksIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLlkpLCBNYXRoLmZsb29yKHBhdHRlcm4uWCksIE1hdGguZmxvb3IocGF0dGVybi5ZKSk7XG4gICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MSkpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVFc3QyIC8gNy4wO1xuICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKG1vZHVsZVNpemVFc3QyKSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDEgLyA3LjA7XG4gICAgfVxuICAvLyBBdmVyYWdlIHRoZW0sIGFuZCBkaXZpZGUgYnkgNyBzaW5jZSB3ZSd2ZSBjb3VudGVkIHRoZSB3aWR0aCBvZiAzIGJsYWNrIG1vZHVsZXMsXG4gIC8vIGFuZCAxIHdoaXRlIGFuZCAxIGJsYWNrIG1vZHVsZSBvbiBlaXRoZXIgc2lkZS4gRXJnbywgZGl2aWRlIHN1bSBieSAxNC5cbiAgICAgICAgcmV0dXJuIChtb2R1bGVTaXplRXN0MSArIG1vZHVsZVNpemVFc3QyKSAvIDE0LjA7XG4gICAgfTtcblxuICAgIERldGVjdG9yLnByb3RvdHlwZS5jYWxjdWxhdGVNb2R1bGVTaXplID0gZnVuY3Rpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQpIHtcbiAgLy8gVGFrZSB0aGUgYXZlcmFnZVxuICAgICAgICByZXR1cm4gKHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCB0b3BSaWdodCkgKyB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wO1xuICAgIH07XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbihwYXR0ZXJuMSwgcGF0dGVybjIpIHtcbiAgICAgICAgdmFyIHhEaWZmID0gcGF0dGVybjEuWCAtIHBhdHRlcm4yLlg7XG4gICAgICAgIHZhciB5RGlmZiA9IHBhdHRlcm4xLlkgLSBwYXR0ZXJuMi5ZO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4RGlmZiAqIHhEaWZmICsgeURpZmYgKiB5RGlmZikpO1xuICAgIH07XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuY29tcHV0ZURpbWVuc2lvbiA9IGZ1bmN0aW9uKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBtb2R1bGVTaXplKSB7XG4gICAgICAgIHZhciB0bHRyQ2VudGVyc0RpbWVuc2lvbiA9IE1hdGgucm91bmQodGhpcy5kaXN0YW5jZSh0b3BMZWZ0LCB0b3BSaWdodCkgLyBtb2R1bGVTaXplKTtcbiAgICAgICAgdmFyIHRsYmxDZW50ZXJzRGltZW5zaW9uID0gTWF0aC5yb3VuZCh0aGlzLmRpc3RhbmNlKHRvcExlZnQsIGJvdHRvbUxlZnQpIC8gbW9kdWxlU2l6ZSk7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSAoKHRsdHJDZW50ZXJzRGltZW5zaW9uICsgdGxibENlbnRlcnNEaW1lbnNpb24pID4+IDEpICsgNztcbiAgICAgICAgc3dpdGNoIChkaW1lbnNpb24gJiAweDAzKSB7XG4gIC8vIG1vZCA0XG4gICAgY2FzZSAwOlxuICAgICAgICBkaW1lbnNpb24rKztcbiAgICAgICAgYnJlYWs7XG4gIC8vIDE/IGRvIG5vdGhpbmdcblxuICAgIGNhc2UgMjpcbiAgICAgICAgZGltZW5zaW9uLS07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAzOlxuICAgICAgICB0aHJvdyBcIkVycm9yXCI7XG4gICAgfVxuICAgICAgICByZXR1cm4gZGltZW5zaW9uO1xuICAgIH07XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZmluZEFsaWdubWVudEluUmVnaW9uID0gZnVuY3Rpb24ob3ZlcmFsbEVzdE1vZHVsZVNpemUsIGVzdEFsaWdubWVudFgsIGVzdEFsaWdubWVudFksIGFsbG93YW5jZUZhY3Rvcikge1xuICAvLyBMb29rIGZvciBhbiBhbGlnbm1lbnQgcGF0dGVybiAoMyBtb2R1bGVzIGluIHNpemUpIGFyb3VuZCB3aGVyZSBpdFxuICAvLyBzaG91bGQgYmVcbiAgICAgICAgdmFyIGFsbG93YW5jZSA9IE1hdGguZmxvb3IoYWxsb3dhbmNlRmFjdG9yICogb3ZlcmFsbEVzdE1vZHVsZVNpemUpO1xuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYUxlZnRYID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WCAtIGFsbG93YW5jZSk7XG4gICAgICAgIHZhciBhbGlnbm1lbnRBcmVhUmlnaHRYID0gTWF0aC5taW4odGhpcy5pbWFnZS53aWR0aCAtIDEsIGVzdEFsaWdubWVudFggKyBhbGxvd2FuY2UpO1xuICAgICAgICBpZiAoYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xuICAgICAgICB0aHJvdyBcIkVycm9yXCI7XG4gICAgfVxuXG4gICAgICAgIHZhciBhbGlnbm1lbnRBcmVhVG9wWSA9IE1hdGgubWF4KDAsIGVzdEFsaWdubWVudFkgLSBhbGxvd2FuY2UpO1xuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYUJvdHRvbVkgPSBNYXRoLm1pbih0aGlzLmltYWdlLmhlaWdodCAtIDEsIGVzdEFsaWdubWVudFkgKyBhbGxvd2FuY2UpO1xuXG4gICAgICAgIHZhciBhbGlnbm1lbnRGaW5kZXIgPSBuZXcgQWxpZ25tZW50UGF0dGVybkZpbmRlcih0aGlzLmltYWdlLCBhbGlnbm1lbnRBcmVhTGVmdFgsIGFsaWdubWVudEFyZWFUb3BZLCBhbGlnbm1lbnRBcmVhUmlnaHRYIC0gYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhQm90dG9tWSAtIGFsaWdubWVudEFyZWFUb3BZLCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSwgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGFsaWdubWVudEZpbmRlci5maW5kKCk7XG4gICAgfTtcblxuICAgIERldGVjdG9yLnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm0gPSBmdW5jdGlvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYWxpZ25tZW50UGF0dGVybiwgZGltZW5zaW9uKSB7XG4gICAgICAgIHZhciBkaW1NaW51c1RocmVlID0gZGltZW5zaW9uIC0gMy41O1xuICAgICAgICB2YXIgYm90dG9tUmlnaHRYO1xuICAgICAgICB2YXIgYm90dG9tUmlnaHRZO1xuICAgICAgICB2YXIgc291cmNlQm90dG9tUmlnaHRYO1xuICAgICAgICB2YXIgc291cmNlQm90dG9tUmlnaHRZO1xuICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiAhPT0gbnVsbCkge1xuICAgICAgICBib3R0b21SaWdodFggPSBhbGlnbm1lbnRQYXR0ZXJuLlg7XG4gICAgICAgIGJvdHRvbVJpZ2h0WSA9IGFsaWdubWVudFBhdHRlcm4uWTtcbiAgICAgICAgc291cmNlQm90dG9tUmlnaHRYID0gc291cmNlQm90dG9tUmlnaHRZID0gZGltTWludXNUaHJlZSAtIDMuMDtcbiAgICB9IGVsc2Uge1xuICAgIC8vIERvbid0IGhhdmUgYW4gYWxpZ25tZW50IHBhdHRlcm4sIGp1c3QgbWFrZSB1cCB0aGUgYm90dG9tLXJpZ2h0IHBvaW50XG4gICAgICAgIGJvdHRvbVJpZ2h0WCA9ICh0b3BSaWdodC5YIC0gdG9wTGVmdC5YKSArIGJvdHRvbUxlZnQuWDtcbiAgICAgICAgYm90dG9tUmlnaHRZID0gKHRvcFJpZ2h0LlkgLSB0b3BMZWZ0LlkpICsgYm90dG9tTGVmdC5ZO1xuICAgICAgICBzb3VyY2VCb3R0b21SaWdodFggPSBzb3VyY2VCb3R0b21SaWdodFkgPSBkaW1NaW51c1RocmVlO1xuICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbCgzLjUsIDMuNSwgZGltTWludXNUaHJlZSwgMy41LCBzb3VyY2VCb3R0b21SaWdodFgsIHNvdXJjZUJvdHRvbVJpZ2h0WSwgMy41LCBkaW1NaW51c1RocmVlLCB0b3BMZWZ0LlgsIHRvcExlZnQuWSwgdG9wUmlnaHQuWCwgdG9wUmlnaHQuWSwgYm90dG9tUmlnaHRYLCBib3R0b21SaWdodFksIGJvdHRvbUxlZnQuWCwgYm90dG9tTGVmdC5ZKTtcblxuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH07XG5cbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuc2FtcGxlR3JpZCA9IGZ1bmN0aW9uKGltYWdlLCB0cmFuc2Zvcm0sIGRpbWVuc2lvbikge1xuXG4gICAgICAgIHZhciBzYW1wbGVyID0gR3JpZFNhbXBsZXI7XG4gICAgICAgIHJldHVybiBzYW1wbGVyLnNhbXBsZUdyaWQzKGltYWdlLCBkaW1lbnNpb24sIHRyYW5zZm9ybSk7XG4gICAgfTtcblxuICAgIERldGVjdG9yLnByb3RvdHlwZS5wcm9jZXNzRmluZGVyUGF0dGVybkluZm8gPSBmdW5jdGlvbihpbmZvKSB7XG5cbiAgICAgICAgdmFyIHRvcExlZnQgPSBpbmZvLnRvcExlZnQ7XG4gICAgICAgIHZhciB0b3BSaWdodCA9IGluZm8udG9wUmlnaHQ7XG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gaW5mby5ib3R0b21MZWZ0O1xuXG4gICAgICAgIHZhciBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcbiAgICAgICAgaWYgKG1vZHVsZVNpemUgPCAxLjApIHtcbiAgICAgICAgdGhyb3cgXCJFcnJvclwiO1xuICAgIH1cbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuY29tcHV0ZURpbWVuc2lvbih0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSk7XG4gICAgICAgIHZhciBwcm92aXNpb25hbFZlcnNpb24gPSBWZXJzaW9uLmdldFByb3Zpc2lvbmFsVmVyc2lvbkZvckRpbWVuc2lvbihkaW1lbnNpb24pO1xuICAgICAgICB2YXIgbW9kdWxlc0JldHdlZW5GUENlbnRlcnMgPSBwcm92aXNpb25hbFZlcnNpb24uRGltZW5zaW9uRm9yVmVyc2lvbiAtIDc7XG5cbiAgICAgICAgdmFyIGFsaWdubWVudFBhdHRlcm4gPSBudWxsO1xuICAvLyBBbnl0aGluZyBhYm92ZSB2ZXJzaW9uIDEgaGFzIGFuIGFsaWdubWVudCBwYXR0ZXJuXG4gICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24uYWxpZ25tZW50UGF0dGVybkNlbnRlcnMubGVuZ3RoID4gMCkge1xuXG4gICAgLy8gR3Vlc3Mgd2hlcmUgYSBcImJvdHRvbSByaWdodFwiIGZpbmRlciBwYXR0ZXJuIHdvdWxkIGhhdmUgYmVlblxuICAgICAgICB2YXIgYm90dG9tUmlnaHRYID0gdG9wUmlnaHQuWCAtIHRvcExlZnQuWCArIGJvdHRvbUxlZnQuWDtcbiAgICAgICAgdmFyIGJvdHRvbVJpZ2h0WSA9IHRvcFJpZ2h0LlkgLSB0b3BMZWZ0LlkgKyBib3R0b21MZWZ0Llk7XG5cbiAgICAvLyBFc3RpbWF0ZSB0aGF0IGFsaWdubWVudCBwYXR0ZXJuIGlzIGNsb3NlciBieSAzIG1vZHVsZXNcbiAgICAvLyBmcm9tIFwiYm90dG9tIHJpZ2h0XCIgdG8ga25vd24gdG9wIGxlZnQgbG9jYXRpb25cbiAgICAgICAgdmFyIGNvcnJlY3Rpb25Ub1RvcExlZnQgPSAxLjAgLSAzLjAgLyBtb2R1bGVzQmV0d2VlbkZQQ2VudGVycztcbiAgICAgICAgdmFyIGVzdEFsaWdubWVudFggPSBNYXRoLmZsb29yKHRvcExlZnQuWCArIGNvcnJlY3Rpb25Ub1RvcExlZnQgKiAoYm90dG9tUmlnaHRYIC0gdG9wTGVmdC5YKSk7XG4gICAgICAgIHZhciBlc3RBbGlnbm1lbnRZID0gTWF0aC5mbG9vcih0b3BMZWZ0LlkgKyBjb3JyZWN0aW9uVG9Ub3BMZWZ0ICogKGJvdHRvbVJpZ2h0WSAtIHRvcExlZnQuWSkpO1xuXG4gICAgLy8gS2luZCBvZiBhcmJpdHJhcnkgLS0gZXhwYW5kIHNlYXJjaCByYWRpdXMgYmVmb3JlIGdpdmluZyB1cFxuICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8PSAxNjsgaSA8PD0gMSkge1xuICAgICAgLy90cnlcbiAgICAgIC8ve1xuICAgICAgICAgIGFsaWdubWVudFBhdHRlcm4gPSB0aGlzLmZpbmRBbGlnbm1lbnRJblJlZ2lvbihtb2R1bGVTaXplLCBlc3RBbGlnbm1lbnRYLCBlc3RBbGlnbm1lbnRZLCBpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIC8vfVxuICAgICAgLy9jYXRjaCAocmUpXG4gICAgICAvL3tcbiAgICAgIC8vIHRyeSBuZXh0IHJvdW5kXG4gICAgICAvL31cbiAgICAgIH1cbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbGlnbm1lbnQgcGF0dGVybi4uLiB3ZWxsIHRyeSBhbnl3YXkgd2l0aG91dCBpdFxuICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbik7XG5cbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLnNhbXBsZUdyaWQodGhpcy5pbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24pO1xuXG4gICAgICAgIHZhciBwb2ludHM7XG4gICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuID09PSBudWxsKSB7XG4gICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gW2JvdHRvbUxlZnQsIHRvcExlZnQsIHRvcFJpZ2h0LCBhbGlnbm1lbnRQYXR0ZXJuXTtcbiAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzKTtcbiAgICB9O1xuXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaW5mbyA9IG5ldyBGaW5kZXJQYXR0ZXJuRmluZGVyKCkuZmluZEZpbmRlclBhdHRlcm4odGhpcy5pbWFnZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvKGluZm8pO1xuICAgIH07XG5cbi8qXG4gIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiAgbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiovXG5cbi8qXG4qXG4qIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIGZ1bmN0aW9uIEdGMjU2UG9seShmaWVsZCwgY29lZmZpY2llbnRzKSB7XG4gICAgICAgIGlmIChjb2VmZmljaWVudHMgPT09IG51bGwgfHwgY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBcIlN5c3RlbS5Bcmd1bWVudEV4Y2VwdGlvblwiO1xuICAgIH1cbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB2YXIgY29lZmZpY2llbnRzTGVuZ3RoID0gY29lZmZpY2llbnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50c0xlbmd0aCA+IDEgJiYgY29lZmZpY2llbnRzWzBdID09PSAwKSB7XG4gICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxuICAgICAgICB2YXIgZmlyc3ROb25aZXJvID0gMTtcbiAgICAgICAgd2hpbGUgKGZpcnN0Tm9uWmVybyA8IGNvZWZmaWNpZW50c0xlbmd0aCAmJiBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvXSA9PT0gMCkge1xuICAgICAgICAgIGZpcnN0Tm9uWmVybysrO1xuICAgICAgfVxuICAgICAgICBpZiAoZmlyc3ROb25aZXJvID09PSBjb2VmZmljaWVudHNMZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IGZpZWxkLlplcm8uY29lZmZpY2llbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBBcnJheShjb2VmZmljaWVudHNMZW5ndGggLSBmaXJzdE5vblplcm8pO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHRoaXMuY29lZmZpY2llbnRzW2ldID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoOyBjaSsrKSB0aGlzLmNvZWZmaWNpZW50c1tjaV0gPSBjb2VmZmljaWVudHNbZmlyc3ROb25aZXJvICsgY2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xuICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoR0YyNTZQb2x5LnByb3RvdHlwZSwgXCJaZXJvXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzWzBdID09PSAwO1xuICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHRjI1NlBvbHkucHJvdG90eXBlLCBcIkRlZ3JlZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICB9KTtcblxuICAgIEdGMjU2UG9seS5wcm90b3R5cGUuZ2V0Q29lZmZpY2llbnQgPSBmdW5jdGlvbihkZWdyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xuICAgIH07XG5cbiAgICBHRjI1NlBvbHkucHJvdG90eXBlLmV2YWx1YXRlQXQgPSBmdW5jdGlvbihhKSB7XG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcbiAgICB9XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoYSA9PT0gMSkge1xuICAgIC8vIEp1c3QgdGhlIHN1bSBvZiB0aGUgY29lZmZpY2llbnRzXG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmllbGQuYWRkT3JTdWJ0cmFjdChyZXN1bHQsIHRoaXMuY29lZmZpY2llbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgICAgIHZhciByZXN1bHQyID0gdGhpcy5jb2VmZmljaWVudHNbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdDIgPSB0aGlzLmZpZWxkLmFkZE9yU3VidHJhY3QodGhpcy5maWVsZC5tdWx0aXBseShhLCByZXN1bHQyKSwgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcblxuICAgIEdGMjU2UG9seS5wcm90b3R5cGUuYWRkT3JTdWJ0cmFjdCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkICE9PSBvdGhlci5maWVsZCkge1xuICAgICAgICB0aHJvdyBcIkdGMjU2UG9seXMgZG8gbm90IGhhdmUgc2FtZSBHRjI1NiBmaWVsZFwiO1xuICAgIH1cbiAgICAgICAgaWYgKHRoaXMuWmVybykge1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgICAgICBpZiAob3RoZXIuWmVybykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAgICAgdmFyIHNtYWxsZXJDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcbiAgICAgICAgdmFyIGxhcmdlckNvZWZmaWNpZW50cyA9IG90aGVyLmNvZWZmaWNpZW50cztcbiAgICAgICAgaWYgKHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoID4gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGVtcCA9IHNtYWxsZXJDb2VmZmljaWVudHM7XG4gICAgICAgIHNtYWxsZXJDb2VmZmljaWVudHMgPSBsYXJnZXJDb2VmZmljaWVudHM7XG4gICAgICAgIGxhcmdlckNvZWZmaWNpZW50cyA9IHRlbXA7XG4gICAgfVxuICAgICAgICB2YXIgc3VtRGlmZiA9IG5ldyBBcnJheShsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGxlbmd0aERpZmYgPSBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XG4gIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgbGVuZ3RoRGlmZjsgY2krKylzdW1EaWZmW2NpXSA9IGxhcmdlckNvZWZmaWNpZW50c1tjaV07XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtRGlmZltpXSA9IHRoaXMuZmllbGQuYWRkT3JTdWJ0cmFjdChzbWFsbGVyQ29lZmZpY2llbnRzW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyQ29lZmZpY2llbnRzW2ldKTtcbiAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBHRjI1NlBvbHkodGhpcy5maWVsZCwgc3VtRGlmZik7XG4gICAgfTtcblxuICAgIEdGMjU2UG9seS5wcm90b3R5cGUubXVsdGlwbHkxID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuZmllbGQgIT09IG90aGVyLmZpZWxkKSB7XG4gICAgICAgIHRocm93IFwiR0YyNTZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdGMjU2IGZpZWxkXCI7XG4gICAgfVxuICAgICAgICBpZiAodGhpcy5aZXJvIHx8IG90aGVyLlplcm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuWmVybztcbiAgICB9XG4gICAgICAgIHZhciBhQ29lZmZpY2llbnRzID0gdGhpcy5jb2VmZmljaWVudHM7XG4gICAgICAgIHZhciBhTGVuZ3RoID0gYUNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBiQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xuICAgICAgICB2YXIgYkxlbmd0aCA9IGJDb2VmZmljaWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBBcnJheShhTGVuZ3RoICsgYkxlbmd0aCAtIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYUNvZWZmID0gYUNvZWZmaWNpZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBwcm9kdWN0W2kgKyBqXSA9IHRoaXMuZmllbGQuYWRkT3JTdWJ0cmFjdChwcm9kdWN0W2kgKyBqXSwgdGhpcy5maWVsZC5tdWx0aXBseShhQ29lZmYsIGJDb2VmZmljaWVudHNbal0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR0YyNTZQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgIH07XG5cbiAgICBHRjI1NlBvbHkucHJvdG90eXBlLm11bHRpcGx5MiA9IGZ1bmN0aW9uKHNjYWxhcikge1xuICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLlplcm87XG4gICAgfVxuICAgICAgICBpZiAoc2NhbGFyID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBwcm9kdWN0W2ldID0gdGhpcy5maWVsZC5tdWx0aXBseSh0aGlzLmNvZWZmaWNpZW50c1tpXSwgc2NhbGFyKTtcbiAgICB9XG4gICAgICAgIHJldHVybiBuZXcgR0YyNTZQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xuICAgIH07XG5cbiAgICBHRjI1NlBvbHkucHJvdG90eXBlLm11bHRpcGx5QnlNb25vbWlhbCA9IGZ1bmN0aW9uKGRlZ3JlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcbiAgICAgICAgdGhyb3cgXCJTeXN0ZW0uQXJndW1lbnRFeGNlcHRpb25cIjtcbiAgICB9XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5aZXJvO1xuICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEFycmF5KHNpemUgKyBkZWdyZWUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2R1Y3QubGVuZ3RoOyBpKyspcHJvZHVjdFtpXSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHByb2R1Y3RbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KHRoaXMuY29lZmZpY2llbnRzW2ldLCBjb2VmZmljaWVudCk7XG4gICAgfVxuICAgICAgICByZXR1cm4gbmV3IEdGMjU2UG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcbiAgICB9O1xuXG4gICAgR0YyNTZQb2x5LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5maWVsZCAhPT0gb3RoZXIuZmllbGQpIHtcbiAgICAgICAgdGhyb3cgXCJHRjI1NlBvbHlzIGRvIG5vdCBoYXZlIHNhbWUgR0YyNTYgZmllbGRcIjtcbiAgICB9XG4gICAgICAgIGlmIChvdGhlci5aZXJvKSB7XG4gICAgICAgIHRocm93IFwiRGl2aWRlIGJ5IDBcIjtcbiAgICB9XG5cbiAgICAgICAgdmFyIHF1b3RpZW50ID0gdGhpcy5maWVsZC5aZXJvO1xuICAgICAgICB2YXIgcmVtYWluZGVyID0gdGhpcztcblxuICAgICAgICB2YXIgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLkRlZ3JlZSk7XG4gICAgICAgIHZhciBpbnZlcnNlRGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHRoaXMuZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcblxuICAgICAgICB3aGlsZSAocmVtYWluZGVyLkRlZ3JlZSA+PSBvdGhlci5EZWdyZWUgJiYgIXJlbWFpbmRlci5aZXJvKSB7XG4gICAgICAgIHZhciBkZWdyZWVEaWZmZXJlbmNlID0gcmVtYWluZGVyLkRlZ3JlZSAtIG90aGVyLkRlZ3JlZTtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5maWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLkRlZ3JlZSksIGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcbiAgICAgICAgdmFyIHRlcm0gPSBvdGhlci5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICB2YXIgaXRlcmF0aW9uUXVvdGllbnQgPSB0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xuICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpO1xuICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuYWRkT3JTdWJ0cmFjdCh0ZXJtKTtcbiAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyXTtcbiAgICB9O1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICBmdW5jdGlvbiBHRjI1NihwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5leHBUYWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgICB0aGlzLmxvZ1RhYmxlID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICAgIHZhciB4ID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB0aGlzLmV4cFRhYmxlW2ldID0geDtcbiAgICAgICAgeCA8PD0gMTsgLy8geCA9IHggKiAyOyB3ZSdyZSBhc3N1bWluZyB0aGUgZ2VuZXJhdG9yIGFscGhhIGlzIDJcbiAgICAgICAgaWYgKHggPj0gMHgxMDApIHtcbiAgICAgICAgICB4IF49IHByaW1pdGl2ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICAgICAgdGhpcy5sb2dUYWJsZVt0aGlzLmV4cFRhYmxlW2ldXSA9IGk7XG4gICAgfVxuICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgIHZhciBhdDAgPSBuZXcgQXJyYXkoMSk7IGF0MFswXSA9IDA7XG4gICAgICAgIHRoaXMuemVybyA9IG5ldyBHRjI1NlBvbHkodGhpcywgbmV3IEFycmF5KGF0MCkpO1xuICAgICAgICB2YXIgYXQxID0gbmV3IEFycmF5KDEpOyBhdDFbMF0gPSAxO1xuICAgICAgICB0aGlzLm9uZSA9IG5ldyBHRjI1NlBvbHkodGhpcywgbmV3IEFycmF5KGF0MSkpO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHRjI1Ni5wcm90b3R5cGUsIFwiWmVyb1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnplcm87XG4gICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEdGMjU2LnByb3RvdHlwZSwgXCJPbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbmU7XG4gICAgfVxuICAgIH0pO1xuXG4gICAgR0YyNTYucHJvdG90eXBlLmJ1aWxkTW9ub21pYWwgPSBmdW5jdGlvbihkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XG4gICAgICAgIHRocm93IFwiU3lzdGVtLkFyZ3VtZW50RXhjZXB0aW9uXCI7XG4gICAgfVxuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuemVybztcbiAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgQXJyYXkoZGVncmVlICsgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKWNvZWZmaWNpZW50c1tpXSA9IDA7XG4gICAgICAgIGNvZWZmaWNpZW50c1swXSA9IGNvZWZmaWNpZW50O1xuICAgICAgICByZXR1cm4gbmV3IEdGMjU2UG9seSh0aGlzLCBjb2VmZmljaWVudHMpO1xuICAgIH07XG5cbiAgICBHRjI1Ni5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVthXTtcbiAgICB9O1xuXG4gICAgR0YyNTYucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgdGhyb3cgXCJTeXN0ZW0uQXJndW1lbnRFeGNlcHRpb25cIjtcbiAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxvZ1RhYmxlW2FdO1xuICAgIH07XG5cbiAgICBHRjI1Ni5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgdGhyb3cgXCJTeXN0ZW0uQXJpdGhtZXRpY0V4Y2VwdGlvblwiO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbMjU1IC0gdGhpcy5sb2dUYWJsZVthXV07XG4gICAgfTtcblxuICAgIEdGMjU2LnByb3RvdHlwZS5hZGRPclN1YnRyYWN0ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYSBeIGI7XG4gICAgfTtcblxuICAgIEdGMjU2LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgICAgIGlmIChhID09PSAxKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICAgICAgaWYgKGIgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVsodGhpcy5sb2dUYWJsZVthXSArIHRoaXMubG9nVGFibGVbYl0pICUgMjU1XTtcbiAgICB9O1xuXG4gICAgR0YyNTYuUVJfQ09ERV9GSUVMRCA9IG5ldyBHRjI1NigweDAxMUQpO1xuICAgIEdGMjU2LkRBVEFfTUFUUklYX0ZJRUxEID0gbmV3IEdGMjU2KDB4MDEyRCk7XG5cbi8qXG4gIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiAgbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiovXG5cbi8qXG4qXG4qIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIGZ1bmN0aW9uIFJlZWRTb2xvbW9uRGVjb2RlcihmaWVsZCkge1xuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgfVxuXG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihyZWNlaXZlZCwgdHdvUykge1xuICAgICAgICB2YXIgcG9seSA9IG5ldyBHRjI1NlBvbHkodGhpcy5maWVsZCwgcmVjZWl2ZWQpO1xuICAgICAgICB2YXIgc3luZHJvbWVDb2VmZmljaWVudHMgPSBuZXcgQXJyYXkodHdvUyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3luZHJvbWVDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspc3luZHJvbWVDb2VmZmljaWVudHNbaV0gPSAwO1xuICAgICAgICB2YXIgZGF0YU1hdHJpeCA9IGZhbHNlOy8vdGhpcy5maWVsZC5FcXVhbHMoR0YyNTYuREFUQV9NQVRSSVhfRklFTEQpO1xuICAgICAgICB2YXIgbm9FcnJvciA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHdvUzsgaSsrKSB7XG4gICAgLy8gVGhhbmtzIHRvIHNhbmZvcmRzcXVpcmVzIGZvciB0aGlzIGZpeDpcbiAgICAgICAgdmFyIF9ldmFsID0gcG9seS5ldmFsdWF0ZUF0KHRoaXMuZmllbGQuZXhwKGRhdGFNYXRyaXggPyBpICsgMSA6IGkpKTtcbiAgICAgICAgc3luZHJvbWVDb2VmZmljaWVudHNbc3luZHJvbWVDb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGldID0gX2V2YWw7XG4gICAgICAgIGlmIChfZXZhbCAhPT0gMCkge1xuICAgICAgICAgIG5vRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIGlmIChub0Vycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgICAgIHZhciBzeW5kcm9tZSA9IG5ldyBHRjI1NlBvbHkodGhpcy5maWVsZCwgc3luZHJvbWVDb2VmZmljaWVudHMpO1xuICAgICAgICB2YXIgc2lnbWFPbWVnYSA9IHRoaXMucnVuRXVjbGlkZWFuQWxnb3JpdGhtKHRoaXMuZmllbGQuYnVpbGRNb25vbWlhbCh0d29TLCAxKSwgc3luZHJvbWUsIHR3b1MpO1xuICAgICAgICB2YXIgc2lnbWEgPSBzaWdtYU9tZWdhWzBdO1xuICAgICAgICB2YXIgb21lZ2EgPSBzaWdtYU9tZWdhWzFdO1xuICAgICAgICB2YXIgZXJyb3JMb2NhdGlvbnMgPSB0aGlzLmZpbmRFcnJvckxvY2F0aW9ucyhzaWdtYSk7XG4gICAgICAgIHZhciBlcnJvck1hZ25pdHVkZXMgPSB0aGlzLmZpbmRFcnJvck1hZ25pdHVkZXMob21lZ2EsIGVycm9yTG9jYXRpb25zLCBkYXRhTWF0cml4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvckxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSByZWNlaXZlZC5sZW5ndGggLSAxIC0gdGhpcy5maWVsZC5sb2coZXJyb3JMb2NhdGlvbnNbaV0pO1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgdGhyb3cgXCJSZWVkU29sb21vbkV4Y2VwdGlvbiBCYWQgZXJyb3IgbG9jYXRpb25cIjtcbiAgICAgIH1cbiAgICAgICAgcmVjZWl2ZWRbcG9zaXRpb25dID0gR0YyNTYucHJvdG90eXBlLmFkZE9yU3VidHJhY3QocmVjZWl2ZWRbcG9zaXRpb25dLCBlcnJvck1hZ25pdHVkZXNbaV0pO1xuICAgIH1cbiAgICB9O1xuXG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5ydW5FdWNsaWRlYW5BbGdvcml0aG0gPSBmdW5jdGlvbihhLCBiLCBSKSB7XG4gIC8vIEFzc3VtZSBhJ3MgZGVncmVlIGlzID49IGInc1xuICAgICAgICBpZiAoYS5EZWdyZWUgPCBiLkRlZ3JlZSkge1xuICAgICAgICB2YXIgdGVtcCA9IGE7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBiID0gdGVtcDtcbiAgICB9XG5cbiAgICAgICAgdmFyIHJMYXN0ID0gYTtcbiAgICAgICAgdmFyIHIgPSBiO1xuICAgICAgICB2YXIgc0xhc3QgPSB0aGlzLmZpZWxkLk9uZTtcbiAgICAgICAgdmFyIHMgPSB0aGlzLmZpZWxkLlplcm87XG4gICAgICAgIHZhciB0TGFzdCA9IHRoaXMuZmllbGQuWmVybztcbiAgICAgICAgdmFyIHQgPSB0aGlzLmZpZWxkLk9uZTtcblxuICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcbiAgICAgICAgd2hpbGUgKHIuRGVncmVlID49IE1hdGguZmxvb3IoUiAvIDIpKSB7XG4gICAgICAgIHZhciByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgdmFyIHNMYXN0TGFzdCA9IHNMYXN0O1xuICAgICAgICB2YXIgdExhc3RMYXN0ID0gdExhc3Q7XG4gICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgc0xhc3QgPSBzO1xuICAgICAgICB0TGFzdCA9IHQ7XG5cbiAgICAvLyBEaXZpZGUgckxhc3RMYXN0IGJ5IHJMYXN0LCB3aXRoIHF1b3RpZW50IGluIHEgYW5kIHJlbWFpbmRlciBpbiByXG4gICAgICAgIGlmIChyTGFzdC5aZXJvKSB7XG4gICAgICAvLyBPb3BzLCBFdWNsaWRlYW4gYWxnb3JpdGhtIGFscmVhZHkgdGVybWluYXRlZD9cbiAgICAgICAgICB0aHJvdyBcInJfe2ktMX0gd2FzIHplcm9cIjtcbiAgICAgIH1cbiAgICAgICAgciA9IHJMYXN0TGFzdDtcbiAgICAgICAgdmFyIHEgPSB0aGlzLmZpZWxkLlplcm87XG4gICAgICAgIHZhciBkZW5vbWluYXRvckxlYWRpbmdUZXJtID0gckxhc3QuZ2V0Q29lZmZpY2llbnQockxhc3QuRGVncmVlKTtcbiAgICAgICAgdmFyIGRsdEludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XG4gICAgICAgIHdoaWxlIChyLkRlZ3JlZSA+PSByTGFzdC5EZWdyZWUgJiYgIXIuWmVybykge1xuICAgICAgICAgIHZhciBkZWdyZWVEaWZmID0gci5EZWdyZWUgLSByTGFzdC5EZWdyZWU7XG4gICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5maWVsZC5tdWx0aXBseShyLmdldENvZWZmaWNpZW50KHIuRGVncmVlKSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgcSA9IHEuYWRkT3JTdWJ0cmFjdCh0aGlzLmZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICByID0gci5hZGRPclN1YnRyYWN0KHJMYXN0Lm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgfVxuXG4gICAgICAgIHMgPSBxLm11bHRpcGx5MShzTGFzdCkuYWRkT3JTdWJ0cmFjdChzTGFzdExhc3QpO1xuICAgICAgICB0ID0gcS5tdWx0aXBseTEodExhc3QpLmFkZE9yU3VidHJhY3QodExhc3RMYXN0KTtcbiAgICB9XG5cbiAgICAgICAgdmFyIHNpZ21hVGlsZGVBdFplcm8gPSB0LmdldENvZWZmaWNpZW50KDApO1xuICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBcIlJlZWRTb2xvbW9uRXhjZXB0aW9uIHNpZ21hVGlsZGUoMCkgd2FzIHplcm9cIjtcbiAgICB9XG5cbiAgICAgICAgdmFyIGludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgIHZhciBzaWdtYSA9IHQubXVsdGlwbHkyKGludmVyc2UpO1xuICAgICAgICB2YXIgb21lZ2EgPSByLm11bHRpcGx5MihpbnZlcnNlKTtcbiAgICAgICAgcmV0dXJuIFtzaWdtYSwgb21lZ2FdO1xuICAgIH07XG5cbiAgICBSZWVkU29sb21vbkRlY29kZXIucHJvdG90eXBlLmZpbmRFcnJvckxvY2F0aW9ucyA9IGZ1bmN0aW9uKGVycm9yTG9jYXRvcikge1xuICAvLyBUaGlzIGlzIGEgZGlyZWN0IGFwcGxpY2F0aW9uIG9mIENoaWVuJ3Mgc2VhcmNoXG4gICAgICAgIHZhciBudW1FcnJvcnMgPSBlcnJvckxvY2F0b3IuRGVncmVlO1xuICAgICAgICBpZiAobnVtRXJyb3JzID09PSAxKSB7XG4gICAgLy8gc2hvcnRjdXRcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShlcnJvckxvY2F0b3IuZ2V0Q29lZmZpY2llbnQoMSkpO1xuICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShudW1FcnJvcnMpO1xuICAgICAgICB2YXIgZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMjU2ICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xuICAgICAgICBpZiAoZXJyb3JMb2NhdG9yLmV2YWx1YXRlQXQoaSkgPT09IDApIHtcbiAgICAgICAgICByZXN1bHRbZV0gPSB0aGlzLmZpZWxkLmludmVyc2UoaSk7XG4gICAgICAgICAgZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykge1xuICAgICAgICB0aHJvdyBcIkVycm9yIGxvY2F0b3IgZGVncmVlIGRvZXMgbm90IG1hdGNoIG51bWJlciBvZiByb290c1wiO1xuICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5maW5kRXJyb3JNYWduaXR1ZGVzID0gZnVuY3Rpb24oZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRpb25zLCBkYXRhTWF0cml4KSB7XG4gIC8vIFRoaXMgaXMgZGlyZWN0bHkgYXBwbHlpbmcgRm9ybmV5J3MgRm9ybXVsYVxuICAgICAgICB2YXIgcyA9IGVycm9yTG9jYXRpb25zLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdmFyIHhpSW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IDE7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gdGhpcy5maWVsZC5tdWx0aXBseShkZW5vbWluYXRvciwgR0YyNTYucHJvdG90eXBlLmFkZE9yU3VidHJhY3QoMSwgdGhpcy5maWVsZC5tdWx0aXBseShlcnJvckxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkoZXJyb3JFdmFsdWF0b3IuZXZhbHVhdGVBdCh4aUludmVyc2UpLCB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3IpKTtcbiAgICAvLyBUaGFua3MgdG8gc2FuZm9yZHNxdWlyZXMgZm9yIHRoaXMgZml4OlxuICAgICAgICBpZiAoZGF0YU1hdHJpeCkge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkocmVzdWx0W2ldLCB4aUludmVyc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICB2YXIgRGF0YU1hc2sgPSB7fTtcblxuICAgIERhdGFNYXNrLmZvclJlZmVyZW5jZSA9IGZ1bmN0aW9uKHJlZmVyZW5jZSkge1xuICAgICAgICBpZiAocmVmZXJlbmNlIDwgMCB8fCByZWZlcmVuY2UgPiA3KSB7XG4gICAgICAgIHRocm93IFwiU3lzdGVtLkFyZ3VtZW50RXhjZXB0aW9uXCI7XG4gICAgfVxuICAgICAgICByZXR1cm4gRGF0YU1hc2suREFUQV9NQVNLU1tyZWZlcmVuY2VdO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBEYXRhTWFzazAwMCgpIHtcbiAgICAgICAgdGhpcy51bm1hc2tCaXRNYXRyaXggPSBmdW5jdGlvbihiaXRzLCBkaW1lbnNpb24pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1lbnNpb247IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XG4gICAgICAgICAgICAgIGJpdHMuZmxpcChqLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgICAgICB0aGlzLmlzTWFza2VkID0gZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gKChpICsgaikgJiAweDAxKSA9PT0gMDtcbiAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERhdGFNYXNrMDAxKCkge1xuICAgICAgICB0aGlzLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgICAgIHRoaXMuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiAoaSAmIDB4MDEpID09PSAwO1xuICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGF0YU1hc2swMTAoKSB7XG4gICAgICAgIHRoaXMudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24oYml0cywgZGltZW5zaW9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkge1xuICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAgICAgdGhpcy5pc01hc2tlZCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIGogJSAzID09PSAwO1xuICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGF0YU1hc2swMTEoKSB7XG4gICAgICAgIHRoaXMudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24oYml0cywgZGltZW5zaW9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkge1xuICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAgICAgdGhpcy5pc01hc2tlZCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIChpICsgaikgJSAzID09PSAwO1xuICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRGF0YU1hc2sxMDAoKSB7XG4gICAgICAgIHRoaXMudW5tYXNrQml0TWF0cml4ID0gZnVuY3Rpb24oYml0cywgZGltZW5zaW9uKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRpbWVuc2lvbjsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc01hc2tlZChpLCBqKSkge1xuICAgICAgICAgICAgICBiaXRzLmZsaXAoaiwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICAgICAgdGhpcy5pc01hc2tlZCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuICgoKFVSU2hpZnQoaSwgMSkpICsgKGogLyAzKSkgJiAweDAxKSA9PT0gMDtcbiAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERhdGFNYXNrMTAxKCkge1xuICAgICAgICB0aGlzLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgICAgIHRoaXMuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHZhciB0ZW1wID0gaSAqIGo7XG4gICAgICAgIHJldHVybiAodGVtcCAmIDB4MDEpICsgKHRlbXAgJSAzKSA9PT0gMDtcbiAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIERhdGFNYXNrMTEwKCkge1xuICAgICAgICB0aGlzLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgICAgIHRoaXMuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHZhciB0ZW1wID0gaSAqIGo7XG4gICAgICAgIHJldHVybiAoKCh0ZW1wICYgMHgwMSkgKyAodGVtcCAlIDMpKSAmIDB4MDEpID09PSAwO1xuICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIERhdGFNYXNrMTExKCkge1xuICAgICAgICB0aGlzLnVubWFza0JpdE1hdHJpeCA9IGZ1bmN0aW9uKGJpdHMsIGRpbWVuc2lvbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNYXNrZWQoaSwgaikpIHtcbiAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgICAgIHRoaXMuaXNNYXNrZWQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiAoKCgoaSArIGopICYgMHgwMSkgKyAoKGkgKiBqKSAlIDMpKSAmIDB4MDEpID09PSAwO1xuICAgIH07XG4gICAgfVxuXG4gICAgRGF0YU1hc2suREFUQV9NQVNLUyA9IFtuZXcgRGF0YU1hc2swMDAoKSwgbmV3IERhdGFNYXNrMDAxKCksIG5ldyBEYXRhTWFzazAxMCgpLCBuZXcgRGF0YU1hc2swMTEoKSwgbmV3IERhdGFNYXNrMTAwKCksIG5ldyBEYXRhTWFzazEwMSgpLCBuZXcgRGF0YU1hc2sxMTAoKSwgbmV3IERhdGFNYXNrMTExKCldO1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICBmdW5jdGlvbiBCaXRNYXRyaXhQYXJzZXIoYml0TWF0cml4KSB7XG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBiaXRNYXRyaXguRGltZW5zaW9uO1xuICAgICAgICBpZiAoZGltZW5zaW9uIDwgMjEgfHwgKGRpbWVuc2lvbiAmIDB4MDMpICE9PSAxKSB7XG4gICAgICAgIHRocm93IFwiRXJyb3IgQml0TWF0cml4UGFyc2VyXCI7XG4gICAgfVxuICAgICAgICB0aGlzLmJpdE1hdHJpeCA9IGJpdE1hdHJpeDtcbiAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gbnVsbDtcbiAgICB9XG5cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLmNvcHlCaXQgPSBmdW5jdGlvbihpLCBqLCB2ZXJzaW9uQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5iaXRNYXRyaXguZ2V0X1JlbmFtZWQoaSwgaikgPyAodmVyc2lvbkJpdHMgPDwgMSkgfCAweDEgOiB2ZXJzaW9uQml0cyA8PCAxO1xuICAgIH07XG5cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRGb3JtYXRJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XG4gICAgfVxuXG4gIC8vIFJlYWQgdG9wLWxlZnQgZm9ybWF0IGluZm8gYml0c1xuICAgICAgICB2YXIgZm9ybWF0SW5mb0JpdHMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICBmb3JtYXRJbmZvQml0cyA9IHRoaXMuY29weUJpdChpLCA4LCBmb3JtYXRJbmZvQml0cyk7XG4gICAgfVxuICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXG4gICAgICAgIGZvcm1hdEluZm9CaXRzID0gdGhpcy5jb3B5Qml0KDcsIDgsIGZvcm1hdEluZm9CaXRzKTtcbiAgICAgICAgZm9ybWF0SW5mb0JpdHMgPSB0aGlzLmNvcHlCaXQoOCwgOCwgZm9ybWF0SW5mb0JpdHMpO1xuICAgICAgICBmb3JtYXRJbmZvQml0cyA9IHRoaXMuY29weUJpdCg4LCA3LCBmb3JtYXRJbmZvQml0cyk7XG4gIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cbiAgICAgICAgZm9yICh2YXIgaiA9IDU7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGZvcm1hdEluZm9CaXRzID0gdGhpcy5jb3B5Qml0KDgsIGosIGZvcm1hdEluZm9CaXRzKTtcbiAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24oZm9ybWF0SW5mb0JpdHMpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XG4gICAgfVxuXG4gIC8vIEhtbSwgZmFpbGVkLiBUcnkgdGhlIHRvcC1yaWdodC9ib3R0b20tbGVmdCBwYXR0ZXJuXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5EaW1lbnNpb247XG4gICAgICAgIGZvcm1hdEluZm9CaXRzID0gMDtcbiAgICAgICAgdmFyIGlNaW4gPSBkaW1lbnNpb24gLSA4O1xuICAgICAgICBmb3IgKHZhciBpID0gZGltZW5zaW9uIC0gMTsgaSA+PSBpTWluOyBpLS0pIHtcbiAgICAgICAgZm9ybWF0SW5mb0JpdHMgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMpO1xuICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IGRpbWVuc2lvbiAtIDc7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgICBmb3JtYXRJbmZvQml0cyA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0cyk7XG4gICAgfVxuXG4gICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IEZvcm1hdEluZm9ybWF0aW9uLmRlY29kZUZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm9CaXRzKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRGb3JtYXRJbmZvO1xuICAgIH1cbiAgICAgICAgdGhyb3cgXCJFcnJvciByZWFkRm9ybWF0SW5mb3JtYXRpb25cIjtcbiAgICB9O1xuXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZWFkVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XG4gICAgfVxuXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5EaW1lbnNpb247XG5cbiAgICAgICAgdmFyIHByb3Zpc2lvbmFsVmVyc2lvbiA9IChkaW1lbnNpb24gLSAxNykgPj4gMjtcbiAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbiA8PSA2KSB7XG4gICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIocHJvdmlzaW9uYWxWZXJzaW9uKTtcbiAgICB9XG5cbiAgLy8gUmVhZCB0b3AtcmlnaHQgdmVyc2lvbiBpbmZvOiAzIHdpZGUgYnkgNiB0YWxsXG4gICAgICAgIHZhciB2ZXJzaW9uQml0cyA9IDA7XG4gICAgICAgIHZhciBpak1pbiA9IGRpbWVuc2lvbiAtIDExO1xuICAgICAgICBmb3IgKHZhciBqID0gNTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbWVuc2lvbiAtIDk7IGkgPj0gaWpNaW47IGktLSkge1xuICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gVmVyc2lvbi5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xuICAgICAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoaXMucGFyc2VkVmVyc2lvbi5EaW1lbnNpb25Gb3JWZXJzaW9uID09PSBkaW1lbnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkVmVyc2lvbjtcbiAgICB9XG5cbiAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbFxuICAgICAgICB2ZXJzaW9uQml0cyA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSA1OyBpID49IDA7IGktLSkge1xuICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gOTsgaiA+PSBpak1pbjsgai0tKSB7XG4gICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSBWZXJzaW9uLmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRWZXJzaW9uLkRpbWVuc2lvbkZvclZlcnNpb24gPT09IGRpbWVuc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZWRWZXJzaW9uO1xuICAgIH1cbiAgICAgICAgdGhyb3cgXCJFcnJvciByZWFkVmVyc2lvblwiO1xuICAgIH07XG5cbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb2Rld29yZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZvcm1hdEluZm8gPSB0aGlzLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMucmVhZFZlcnNpb24oKTtcblxuICAvLyBHZXQgdGhlIGRhdGEgbWFzayBmb3IgdGhlIGZvcm1hdCB1c2VkIGluIHRoaXMgUVIgQ29kZS4gVGhpcyB3aWxsIGV4Y2x1ZGVcbiAgLy8gc29tZSBiaXRzIGZyb20gcmVhZGluZyBhcyB3ZSB3aW5kIHRocm91Z2ggdGhlIGJpdCBtYXRyaXguXG4gICAgICAgIHZhciBkYXRhTWFzayA9IERhdGFNYXNrLmZvclJlZmVyZW5jZShmb3JtYXRJbmZvLmRhdGFNYXNrKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LkRpbWVuc2lvbjtcbiAgICAgICAgZGF0YU1hc2sudW5tYXNrQml0TWF0cml4KHRoaXMuYml0TWF0cml4LCBkaW1lbnNpb24pO1xuXG4gICAgICAgIHZhciBmdW5jdGlvblBhdHRlcm4gPSB2ZXJzaW9uLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuKCk7XG5cbiAgICAgICAgdmFyIHJlYWRpbmdVcCA9IHRydWU7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodmVyc2lvbi50b3RhbENvZGV3b3Jkcyk7XG4gICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xuICAgICAgICB2YXIgYml0c1JlYWQgPSAwO1xuICAvLyBSZWFkIGNvbHVtbnMgaW4gcGFpcnMsIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgICBmb3IgKHZhciBqID0gZGltZW5zaW9uIC0gMTsgaiA+IDA7IGogLT0gMikge1xuICAgICAgICBpZiAoaiA9PT0gNikge1xuICAgICAgLy8gU2tpcCB3aG9sZSBjb2x1bW4gd2l0aCB2ZXJ0aWNhbCBhbGlnbm1lbnQgcGF0dGVybjtcbiAgICAgIC8vIHNhdmVzIHRpbWUgYW5kIG1ha2VzIHRoZSBvdGhlciBjb2RlIHByb2NlZWQgbW9yZSBjbGVhbmx5XG4gICAgICAgICAgai0tO1xuICAgICAgfVxuICAgIC8vIFJlYWQgYWx0ZXJuYXRpbmdseSBmcm9tIGJvdHRvbSB0byB0b3AgdGhlbiB0b3AgdG8gYm90dG9tXG4gICAgICAgIGZvciAodmFyIGNvdW50ID0gMDsgY291bnQgPCBkaW1lbnNpb247IGNvdW50KyspIHtcbiAgICAgICAgICB2YXIgaSA9IHJlYWRpbmdVcCA/IGRpbWVuc2lvbiAtIDEgLSBjb3VudCA6IGNvdW50O1xuICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IDI7IGNvbCsrKSB7XG4gICAgICAgIC8vIElnbm9yZSBiaXRzIGNvdmVyZWQgYnkgdGhlIGZ1bmN0aW9uIHBhdHRlcm5cbiAgICAgICAgICAgIGlmICghZnVuY3Rpb25QYXR0ZXJuLmdldF9SZW5hbWVkKGogLSBjb2wsIGkpKSB7XG4gICAgICAgICAgLy8gUmVhZCBhIGJpdFxuICAgICAgICAgICAgICBiaXRzUmVhZCsrO1xuICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TWF0cml4LmdldF9SZW5hbWVkKGogLSBjb2wsIGkpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYWRlIGEgd2hvbGUgYnl0ZSwgc2F2ZSBpdCBvZmZcbiAgICAgICAgICAgICAgaWYgKGJpdHNSZWFkID09PSA4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IGN1cnJlbnRCeXRlO1xuICAgICAgICAgICAgICAgIGJpdHNSZWFkID0gMDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAgIHJlYWRpbmdVcCBePSB0cnVlOyAvLyByZWFkaW5nVXAgPSAhcmVhZGluZ1VwOyAvLyBzd2l0Y2ggZGlyZWN0aW9uc1xuICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdmVyc2lvbi50b3RhbENvZGV3b3Jkcykge1xuICAgICAgICB0aHJvdyBcIkVycm9yIHJlYWRDb2Rld29yZHNcIjtcbiAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuLypcbiAgUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgTGF6YXIgTGFzemxvIDIwMTFcblxuICBsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm9cblxuKi9cblxuLypcbipcbiogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbiAgICBmdW5jdGlvbiBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcywgY29kZXdvcmRzKSB7XG4gICAgICAgIHRoaXMubnVtRGF0YUNvZGV3b3JkcyA9IG51bURhdGFDb2Rld29yZHM7XG4gICAgICAgIHRoaXMuY29kZXdvcmRzID0gY29kZXdvcmRzO1xuICAgIH1cblxuICAgIERhdGFCbG9jay5nZXREYXRhQmxvY2tzID0gZnVuY3Rpb24ocmF3Q29kZXdvcmRzLCB2ZXJzaW9uLCBlY0xldmVsKSB7XG5cbiAgICAgICAgaWYgKHJhd0NvZGV3b3Jkcy5sZW5ndGggIT09IHZlcnNpb24udG90YWxDb2Rld29yZHMpIHtcbiAgICAgICAgdGhyb3cgXCJBcmd1bWVudEV4Y2VwdGlvblwiO1xuICAgIH1cblxuICAvLyBGaWd1cmUgb3V0IHRoZSBudW1iZXIgYW5kIHNpemUgb2YgZGF0YSBibG9ja3MgdXNlZCBieSB0aGlzIHZlcnNpb24gYW5kXG4gIC8vIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWxcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xuXG4gIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3NcbiAgICAgICAgdmFyIHRvdGFsQmxvY2tzID0gMDtcbiAgICAgICAgdmFyIGVjQmxvY2tBcnJheSA9IGVjQmxvY2tzLmdldEVDQmxvY2tzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNCbG9ja0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsQmxvY2tzICs9IGVjQmxvY2tBcnJheVtpXS5jb3VudDtcbiAgICB9XG5cbiAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XG4gICAgICAgIHZhciBudW1SZXN1bHRCbG9ja3MgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVjQmxvY2tBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWNCbG9jayA9IGVjQmxvY2tBcnJheVtqXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlY0Jsb2NrLmNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZGF0YUNvZGV3b3JkcztcbiAgICAgICAgICB2YXIgbnVtQmxvY2tDb2Rld29yZHMgPSBlY0Jsb2Nrcy5lY0NvZGV3b3Jkc1BlckJsb2NrICsgbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBuZXcgQXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXG4gIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbW9yZSBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxuICAgICAgICB2YXIgc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XG4gICAgICAgIHZhciBsb25nZXJCbG9ja3NTdGFydEF0ID0gcmVzdWx0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChsb25nZXJCbG9ja3NTdGFydEF0ID49IDApIHtcbiAgICAgICAgdmFyIG51bUNvZGV3b3JkcyA9IHJlc3VsdFtsb25nZXJCbG9ja3NTdGFydEF0XS5jb2Rld29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobnVtQ29kZXdvcmRzID09PSBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdC0tO1xuICAgIH1cbiAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdCsrO1xuXG4gICAgICAgIHZhciBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyAtIGVjQmxvY2tzLmVjQ29kZXdvcmRzUGVyQmxvY2s7XG4gIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IGxvbmdlcjtcbiAgLy8gZmlyc3QgZmlsbCBvdXQgYXMgbWFueSBlbGVtZW50cyBhcyBhbGwgb2YgdGhlbSBoYXZlXG4gICAgICAgIHZhciByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbaV0gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xuICAgICAgfVxuICAgIH1cbiAgLy8gRmlsbCBvdXQgdGhlIGxhc3QgZGF0YSBibG9jayBpbiB0aGUgbG9uZ2VyIG9uZXNcbiAgICAgICAgZm9yICh2YXIgaiA9IGxvbmdlckJsb2Nrc1N0YXJ0QXQ7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW3Nob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgfVxuICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXG4gICAgICAgIHZhciBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xuICAgICAgICAgIHZhciBpT2Zmc2V0ID0gaiA8IGxvbmdlckJsb2Nrc1N0YXJ0QXQgPyBpIDogaSArIDE7XG4gICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpT2Zmc2V0XSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XG4gICAgICB9XG4gICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbi8qXG4gIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IExhemFyIExhc3psbyAyMDExXG5cbiAgbGF6YXJzb2Z0QGdtYWlsLmNvbSwgd3d3LmxhemFyc29mdC5pbmZvXG5cbiovXG5cbi8qXG4qXG4qIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcbipcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIGZ1bmN0aW9uIFFSQ29kZURhdGFCbG9ja1JlYWRlcihibG9ja3MsIHZlcnNpb24sIG51bUVycm9yQ29ycmVjdGlvbkNvZGUpIHtcbiAgICAgICAgdGhpcy5ibG9ja1BvaW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmJpdFBvaW50ZXIgPSA3O1xuICAgICAgICB0aGlzLmRhdGFMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgdGhpcy5udW1FcnJvckNvcnJlY3Rpb25Db2RlID0gbnVtRXJyb3JDb3JyZWN0aW9uQ29kZTtcbiAgICAgICAgaWYgKHZlcnNpb24gPD0gOSlcbiAgICAgICAgdGhpcy5kYXRhTGVuZ3RoTW9kZSA9IDA7XG4gIGVsc2UgaWYgKHZlcnNpb24gPj0gMTAgJiYgdmVyc2lvbiA8PSAyNilcbiAgICAgIHRoaXMuZGF0YUxlbmd0aE1vZGUgPSAxO1xuICBlbHNlIGlmICh2ZXJzaW9uID49IDI3ICYmIHZlcnNpb24gPD0gNDApXG4gICAgICB0aGlzLmRhdGFMZW5ndGhNb2RlID0gMjtcbiAgICB9XG5cbiAgICBRUkNvZGVEYXRhQmxvY2tSZWFkZXIucHJvdG90eXBlLmdldE5leHRCaXRzID0gZnVuY3Rpb24obnVtQml0cykge1xuICAgICAgICB2YXIgYml0cyA9IDA7XG4gICAgICAgIGlmIChudW1CaXRzIDwgdGhpcy5iaXRQb2ludGVyICsgMSkge1xuICAgIC8vIG5leHQgd29yZCBmaXRzIGludG8gY3VycmVudCBkYXRhIGJsb2NrXG4gICAgICAgIHZhciBtYXNrID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1CaXRzOyBpKyspIHtcbiAgICAgICAgICBtYXNrICs9ICgxIDw8IGkpO1xuICAgICAgfVxuICAgICAgICBtYXNrIDw8PSAodGhpcy5iaXRQb2ludGVyIC0gbnVtQml0cyArIDEpO1xuXG4gICAgICAgIGJpdHMgPSAodGhpcy5ibG9ja3NbdGhpcy5ibG9ja1BvaW50ZXJdICYgbWFzaykgPj4gKHRoaXMuYml0UG9pbnRlciAtIG51bUJpdHMgKyAxKTtcbiAgICAgICAgdGhpcy5iaXRQb2ludGVyIC09IG51bUJpdHM7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH0gZWxzZSBpZiAobnVtQml0cyA8IHRoaXMuYml0UG9pbnRlciArIDEgKyA4KSB7XG4gICAgLy8gbmV4dCB3b3JkIGNyb3NzZXMgMiBkYXRhIGJsb2Nrc1xuICAgICAgdmFyIG1hc2sxID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5iaXRQb2ludGVyICsgMTsgaSsrKSB7XG4gICAgICAgICAgbWFzazEgKz0gKDEgPDwgaSk7XG4gICAgICB9XG4gICAgICBiaXRzID0gKHRoaXMuYmxvY2tzW3RoaXMuYmxvY2tQb2ludGVyXSAmIG1hc2sxKSA8PCAobnVtQml0cyAtICh0aGlzLmJpdFBvaW50ZXIgKyAxKSk7XG4gICAgICB0aGlzLmJsb2NrUG9pbnRlcisrO1xuICAgICAgYml0cyArPSAoKHRoaXMuYmxvY2tzW3RoaXMuYmxvY2tQb2ludGVyXSkgPj4gKDggLSAobnVtQml0cyAtICh0aGlzLmJpdFBvaW50ZXIgKyAxKSkpKTtcblxuICAgICAgdGhpcy5iaXRQb2ludGVyID0gdGhpcy5iaXRQb2ludGVyIC0gbnVtQml0cyAlIDg7XG4gICAgICBpZiAodGhpcy5iaXRQb2ludGVyIDwgMCkge1xuICAgICAgICAgIHRoaXMuYml0UG9pbnRlciA9IDggKyB0aGlzLmJpdFBvaW50ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYml0cztcbiAgfSBlbHNlIGlmIChudW1CaXRzIDwgdGhpcy5iaXRQb2ludGVyICsgMSArIDE2KSB7XG4gICAgLy8gbmV4dCB3b3JkIGNyb3NzZXMgMyBkYXRhIGJsb2Nrc1xuICAgICAgdmFyIG1hc2sxID0gMDsgLy8gbWFzayBvZiBmaXJzdCBibG9ja1xuICAgICAgdmFyIG1hc2szID0gMDsgLy8gbWFzayBvZiAzcmQgYmxvY2tcbiAgICAvL2JpdFBvaW50ZXIgKyAxIDogbnVtYmVyIG9mIGJpdHMgb2YgdGhlIDFzdCBibG9ja1xuICAgIC8vOCA6IG51bWJlciBvZiB0aGUgMm5kIGJsb2NrIChub3RlIHRoYXQgdXNlIGFscmVhZHkgOGJpdHMgYmVjYXVzZSBuZXh0IHdvcmQgdXNlcyAzIGRhdGEgYmxvY2tzKVxuICAgIC8vbnVtQml0cyAtIChiaXRQb2ludGVyICsgMSArIDgpIDogbnVtYmVyIG9mIGJpdHMgb2YgdGhlIDNyZCBibG9ja1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJpdFBvaW50ZXIgKyAxOyBpKyspIHtcbiAgICAgICAgICBtYXNrMSArPSAoMSA8PCBpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiaXRzRmlyc3RCbG9jayA9ICh0aGlzLmJsb2Nrc1t0aGlzLmJsb2NrUG9pbnRlcl0gJiBtYXNrMSkgPDwgKG51bUJpdHMgLSAodGhpcy5iaXRQb2ludGVyICsgMSkpO1xuICAgICAgdGhpcy5ibG9ja1BvaW50ZXIrKztcblxuICAgICAgdmFyIGJpdHNTZWNvbmRCbG9jayA9IHRoaXMuYmxvY2tzW3RoaXMuYmxvY2tQb2ludGVyXSA8PCAobnVtQml0cyAtICh0aGlzLmJpdFBvaW50ZXIgKyAxICsgOCkpO1xuICAgICAgdGhpcy5ibG9ja1BvaW50ZXIrKztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1CaXRzIC0gKHRoaXMuYml0UG9pbnRlciArIDEgKyA4KTsgaSsrKSB7XG4gICAgICAgICAgbWFzazMgKz0gKDEgPDwgaSk7XG4gICAgICB9XG4gICAgICBtYXNrMyA8PD0gOCAtIChudW1CaXRzIC0gKHRoaXMuYml0UG9pbnRlciArIDEgKyA4KSk7XG4gICAgICB2YXIgYml0c1RoaXJkQmxvY2sgPSAodGhpcy5ibG9ja3NbdGhpcy5ibG9ja1BvaW50ZXJdICYgbWFzazMpID4+ICg4IC0gKG51bUJpdHMgLSAodGhpcy5iaXRQb2ludGVyICsgMSArIDgpKSk7XG5cbiAgICAgIGJpdHMgPSBiaXRzRmlyc3RCbG9jayArIGJpdHNTZWNvbmRCbG9jayArIGJpdHNUaGlyZEJsb2NrO1xuICAgICAgdGhpcy5iaXRQb2ludGVyID0gdGhpcy5iaXRQb2ludGVyIC0gKG51bUJpdHMgLSA4KSAlIDg7XG4gICAgICBpZiAodGhpcy5iaXRQb2ludGVyIDwgMCkge1xuICAgICAgICAgIHRoaXMuYml0UG9pbnRlciA9IDggKyB0aGlzLmJpdFBvaW50ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYml0cztcbiAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICB9XG4gICAgfTtcblxuICAgIFFSQ29kZURhdGFCbG9ja1JlYWRlci5wcm90b3R5cGUuTmV4dE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCh0aGlzLmJsb2NrUG9pbnRlciA+IHRoaXMuYmxvY2tzLmxlbmd0aCAtIHRoaXMubnVtRXJyb3JDb3JyZWN0aW9uQ29kZSAtIDIpKVxuICAgICAgICByZXR1cm4gMDtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmdldE5leHRCaXRzKDQpO1xuICAgIH07XG5cbiAgICBRUkNvZGVEYXRhQmxvY2tSZWFkZXIucHJvdG90eXBlLmdldERhdGFMZW5ndGggPSBmdW5jdGlvbihtb2RlSW5kaWNhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICgobW9kZUluZGljYXRvciA+PiBpbmRleCkgPT09IDEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRCaXRzKHFyY29kZS5zaXplT2ZEYXRhTGVuZ3RoSW5mb1t0aGlzLmRhdGFMZW5ndGhNb2RlXVtpbmRleF0pO1xuICAgIH07XG5cbiAgICBRUkNvZGVEYXRhQmxvY2tSZWFkZXIucHJvdG90eXBlLmdldFJvbWFuQW5kRmlndXJlU3RyaW5nID0gZnVuY3Rpb24oZGF0YUxlbmd0aCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YUxlbmd0aDtcbiAgICAgICAgdmFyIGludERhdGEgPSAwO1xuICAgICAgICB2YXIgc3RyRGF0YSA9IFwiXCI7XG4gICAgICAgIHZhciB0YWJsZVJvbWFuQW5kRmlndXJlID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICcgJywgJyQnLCAnJScsICcqJywgJysnLCAnLScsICcuJywgJy8nLCAnOiddO1xuICAgICAgICBkbyB7XG4gICAgICAgIGlmIChsZW5ndGggPiAxKSB7XG4gICAgICAgICAgaW50RGF0YSA9IHRoaXMuZ2V0TmV4dEJpdHMoMTEpO1xuICAgICAgICAgIHZhciBmaXJzdExldHRlciA9IE1hdGguZmxvb3IoaW50RGF0YSAvIDQ1KTtcbiAgICAgICAgICB2YXIgc2Vjb25kTGV0dGVyID0gaW50RGF0YSAlIDQ1O1xuICAgICAgICAgIHN0ckRhdGEgKz0gdGFibGVSb21hbkFuZEZpZ3VyZVtmaXJzdExldHRlcl07XG4gICAgICAgICAgc3RyRGF0YSArPSB0YWJsZVJvbWFuQW5kRmlndXJlW3NlY29uZExldHRlcl07XG4gICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpbnREYXRhID0gdGhpcy5nZXROZXh0Qml0cyg2KTtcbiAgICAgICAgc3RyRGF0YSArPSB0YWJsZVJvbWFuQW5kRmlndXJlW2ludERhdGFdO1xuICAgICAgICBsZW5ndGggLT0gMTtcbiAgICB9XG4gICAgfVxuICB3aGlsZSAobGVuZ3RoID4gMCk7XG5cbiAgICAgICAgcmV0dXJuIHN0ckRhdGE7XG4gICAgfTtcblxuICAgIFFSQ29kZURhdGFCbG9ja1JlYWRlci5wcm90b3R5cGUuZ2V0RmlndXJlU3RyaW5nID0gZnVuY3Rpb24oZGF0YUxlbmd0aCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YUxlbmd0aDtcbiAgICAgICAgdmFyIGludERhdGEgPSAwO1xuICAgICAgICB2YXIgc3RyRGF0YSA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgaW50RGF0YSA9IHRoaXMuZ2V0TmV4dEJpdHMoMTApO1xuICAgICAgICAgIGlmIChpbnREYXRhIDwgMTAwKVxuICAgICAgICAgICAgc3RyRGF0YSArPSBcIjBcIjtcbiAgICAgICAgICBpZiAoaW50RGF0YSA8IDEwKVxuICAgICAgICAgICAgc3RyRGF0YSArPSBcIjBcIjtcbiAgICAgICAgICBsZW5ndGggLT0gMztcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGludERhdGEgPSB0aGlzLmdldE5leHRCaXRzKDcpO1xuICAgICAgICBpZiAoaW50RGF0YSA8IDEwKVxuICAgICAgICAgICAgc3RyRGF0YSArPSBcIjBcIjtcbiAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgaW50RGF0YSA9IHRoaXMuZ2V0TmV4dEJpdHMoNCk7XG4gICAgICAgIGxlbmd0aCAtPSAxO1xuICAgIH1cbiAgICAgICAgc3RyRGF0YSArPSBpbnREYXRhO1xuICAgIH1cbiAgd2hpbGUgKGxlbmd0aCA+IDApO1xuXG4gICAgICAgIHJldHVybiBzdHJEYXRhO1xuICAgIH07XG5cbiAgICBRUkNvZGVEYXRhQmxvY2tSZWFkZXIucHJvdG90eXBlLmdldDhiaXRCeXRlQXJyYXkgPSBmdW5jdGlvbihkYXRhTGVuZ3RoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhTGVuZ3RoO1xuICAgICAgICB2YXIgaW50RGF0YSA9IDA7XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgIGludERhdGEgPSB0aGlzLmdldE5leHRCaXRzKDgpO1xuICAgICAgICBvdXRwdXQucHVzaChpbnREYXRhKTtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgfVxuICB3aGlsZSAobGVuZ3RoID4gMCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcblxuICAgIFFSQ29kZURhdGFCbG9ja1JlYWRlci5wcm90b3R5cGUuZ2V0S2FuamlTdHJpbmcgPSBmdW5jdGlvbihkYXRhTGVuZ3RoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkYXRhTGVuZ3RoO1xuICAgICAgICB2YXIgaW50RGF0YSA9IDA7XG4gICAgICAgIHZhciB1bmljb2RlU3RyaW5nID0gXCJcIjtcbiAgICAgICAgZG8ge1xuICAgICAgICBpbnREYXRhID0gdGhpcy5nZXROZXh0Qml0cygxMyk7XG4gICAgICAgIHZhciBsb3dlckJ5dGUgPSBpbnREYXRhICUgMHhDMDtcbiAgICAgICAgdmFyIGhpZ2hlckJ5dGUgPSBpbnREYXRhIC8gMHhDMDtcblxuICAgICAgICB2YXIgdGVtcFdvcmQgPSAoaGlnaGVyQnl0ZSA8PCA4KSArIGxvd2VyQnl0ZTtcbiAgICAgICAgdmFyIHNoaWZ0amlzV29yZCA9IDA7XG4gICAgICAgIGlmICh0ZW1wV29yZCArIDB4ODE0MCA8PSAweDlGRkMpIHtcbiAgICAgIC8vIGJldHdlZW4gODE0MCAtIDlGRkMgb24gU2hpZnRfSklTIGNoYXJhY3RlciBzZXRcbiAgICAgICAgICBzaGlmdGppc1dvcmQgPSB0ZW1wV29yZCArIDB4ODE0MDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBiZXR3ZWVuIEUwNDAgLSBFQkJGIG9uIFNoaWZ0X0pJUyBjaGFyYWN0ZXIgc2V0XG4gICAgICAgICAgc2hpZnRqaXNXb3JkID0gdGVtcFdvcmQgKyAweEMxNDA7XG4gICAgICB9XG5cbiAgICAgICAgdW5pY29kZVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNoaWZ0amlzV29yZCk7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgd2hpbGUgKGxlbmd0aCA+IDApO1xuXG5cbiAgICAgICAgcmV0dXJuIHVuaWNvZGVTdHJpbmc7XG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShRUkNvZGVEYXRhQmxvY2tSZWFkZXIucHJvdG90eXBlLCBcIkRhdGFCeXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICB2YXIgTU9ERV9OVU1CRVIgPSAxO1xuICAgICAgICB2YXIgTU9ERV9ST01BTl9BTkRfTlVNQkVSID0gMjtcbiAgICAgICAgdmFyIE1PREVfOEJJVF9CWVRFID0gNDtcbiAgICAgICAgdmFyIE1PREVfS0FOSkkgPSA4O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIG1vZGUgPSB0aGlzLk5leHRNb2RlKCk7XG4gICAgICAgICAgaWYgKG1vZGUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBcIkVtcHR5IGRhdGEgYmxvY2tcIjtcbiAgICAgICAgfVxuICAgICAgLy9pZiAobW9kZSAhPSAxICYmIG1vZGUgIT0gMiAmJiBtb2RlICE9IDQgJiYgbW9kZSAhPSA4KVxuICAgICAgLy99XG4gICAgICAgICAgaWYgKG1vZGUgIT09IE1PREVfTlVNQkVSICYmIG1vZGUgIT09IE1PREVfUk9NQU5fQU5EX05VTUJFUiAmJiBtb2RlICE9PSBNT0RFXzhCSVRfQllURSAmJiBtb2RlICE9PSBNT0RFX0tBTkpJICYmIG1vZGUgIT09IDcpIHtcbiAgICAgICAgLyogICAgICAgICAgY2FudmFzLnByaW50bG4oXCJJbnZhbGlkIG1vZGU6IFwiICsgbW9kZSk7XG4gICAgICAgICBtb2RlID0gZ3Vlc3NNb2RlKG1vZGUpO1xuICAgICAgICAgY2FudmFzLnByaW50bG4oXCJHdWVzc2VkIG1vZGU6IFwiICsgbW9kZSk7ICovXG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgbW9kZTogXCIgKyBtb2RlICsgXCIgaW4gKGJsb2NrOlwiICsgdGhpcy5ibG9ja1BvaW50ZXIgKyBcIiBiaXQ6XCIgKyB0aGlzLmJpdFBvaW50ZXIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gdGhpcy5nZXREYXRhTGVuZ3RoKG1vZGUpO1xuICAgICAgICAgIGlmIChkYXRhTGVuZ3RoIDwgMSlcbiAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBkYXRhIGxlbmd0aDogXCIgKyBkYXRhTGVuZ3RoO1xuICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuXG4gICAgICAgIGNhc2UgTU9ERV9OVU1CRVI6XG4gICAgICAgICAgICB2YXIgdGVtcF9zdHIgPSB0aGlzLmdldEZpZ3VyZVN0cmluZyhkYXRhTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB0YSA9IG5ldyBBcnJheSh0ZW1wX3N0ci5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZW1wX3N0ci5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgdGFbal0gPSB0ZW1wX3N0ci5jaGFyQ29kZUF0KGopO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godGEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBNT0RFX1JPTUFOX0FORF9OVU1CRVI6XG4gICAgICAgICAgICB2YXIgdGVtcF9zdHIgPSB0aGlzLmdldFJvbWFuQW5kRmlndXJlU3RyaW5nKGRhdGFMZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHRhID0gbmV3IEFycmF5KHRlbXBfc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlbXBfc3RyLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICB0YVtqXSA9IHRlbXBfc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0YSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE1PREVfOEJJVF9CWVRFOlxuICAgICAgICAgICAgdmFyIHRlbXBfc2J5dGVBcnJheTMgPSB0aGlzLmdldDhiaXRCeXRlQXJyYXkoZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0ZW1wX3NieXRlQXJyYXkzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgTU9ERV9LQU5KSTpcbiAgICAgICAgICAgIHZhciB0ZW1wX3N0ciA9IHRoaXMuZ2V0S2FuamlTdHJpbmcoZGF0YUxlbmd0aCk7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh0ZW1wX3N0cik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy9cbiAgICAgIH1cbiAgICB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIH0pO1xuXG4vKlxuICBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBMYXphciBMYXN6bG8gMjAxMVxuXG4gIGxhemFyc29mdEBnbWFpbC5jb20sIHd3dy5sYXphcnNvZnQuaW5mb1xuXG4qL1xuXG4vKlxuKlxuKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXG4qXG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbiAgICB2YXIgRGVjb2RlciA9IHt9O1xuICAgIERlY29kZXIucnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2RlcihHRjI1Ni5RUl9DT0RFX0ZJRUxEKTtcblxuICAgIERlY29kZXIuY29ycmVjdEVycm9ycyA9IGZ1bmN0aW9uKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpIHtcbiAgICAgICAgdmFyIG51bUNvZGV3b3JkcyA9IGNvZGV3b3JkQnl0ZXMubGVuZ3RoO1xuICAvLyBGaXJzdCByZWFkIGludG8gYW4gYXJyYXkgb2YgaW50c1xuICAgICAgICB2YXIgY29kZXdvcmRzSW50cyA9IG5ldyBBcnJheShudW1Db2Rld29yZHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvZGV3b3JkczsgaSsrKSB7XG4gICAgICAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRjtcbiAgICB9XG4gICAgICAgIHZhciBudW1FQ0NvZGV3b3JkcyA9IGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgRGVjb2Rlci5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIG51bUVDQ29kZXdvcmRzKTtcbiAgICB9IGNhdGNoIChyc2UpIHtcbiAgICAgIHRocm93IHJzZTtcbiAgfVxuICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXG4gIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICBjb2Rld29yZEJ5dGVzW2ldID0gY29kZXdvcmRzSW50c1tpXTtcbiAgICB9XG4gICAgfTtcblxuICAgIERlY29kZXIuZGVjb2RlID0gZnVuY3Rpb24oYml0cykge1xuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlcihiaXRzKTtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBwYXJzZXIucmVhZFZlcnNpb24oKTtcbiAgICAgICAgdmFyIGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG5cbiAgLy8gUmVhZCBjb2Rld29yZHNcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHBhcnNlci5yZWFkQ29kZXdvcmRzKCk7XG5cbiAgLy8gU2VwYXJhdGUgaW50byBkYXRhIGJsb2Nrc1xuICAgICAgICB2YXIgZGF0YUJsb2NrcyA9IERhdGFCbG9jay5nZXREYXRhQmxvY2tzKGNvZGV3b3JkcywgdmVyc2lvbiwgZWNMZXZlbCk7XG5cbiAgLy8gQ291bnQgdG90YWwgbnVtYmVyIG9mIGRhdGEgYnl0ZXNcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxCeXRlcyArPSBkYXRhQmxvY2tzW2ldLm51bURhdGFDb2Rld29yZHM7XG4gICAgfVxuICAgICAgICB2YXIgcmVzdWx0Qnl0ZXMgPSBuZXcgQXJyYXkodG90YWxCeXRlcyk7XG4gICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwO1xuXG4gIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFCbG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3Nbal07XG4gICAgICAgIHZhciBjb2Rld29yZEJ5dGVzID0gZGF0YUJsb2NrLmNvZGV3b3JkcztcbiAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHMgPSBkYXRhQmxvY2subnVtRGF0YUNvZGV3b3JkcztcbiAgICAgICAgRGVjb2Rlci5jb3JyZWN0RXJyb3JzKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xuICAgICAgICAgIHJlc3VsdEJ5dGVzW3Jlc3VsdE9mZnNldCsrXSA9IGNvZGV3b3JkQnl0ZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gIC8vIERlY29kZSB0aGUgY29udGVudHMgb2YgdGhhdCBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBRUkNvZGVEYXRhQmxvY2tSZWFkZXIocmVzdWx0Qnl0ZXMsIHZlcnNpb24udmVyc2lvbk51bWJlciwgZWNMZXZlbC5iaXRzKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9O1xuXG4vKlxuICAgQ29weXJpZ2h0IDIwMTEgTGF6YXIgTGFzemxvIChsYXphcnNvZnRAZ21haWwuY29tLCB3d3cubGF6YXJzb2Z0LmluZm8pXG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuICAgIHZhciBxcmNvZGUgPSB7fTtcbiAgICBxcmNvZGUuc2l6ZU9mRGF0YUxlbmd0aEluZm8gPSBbWzEwLCA5LCA4LCA4XSwgWzEyLCAxMSwgMTYsIDEwXSwgWzE0LCAxMywgMTYsIDEyXV07XG5cbiAgICBmdW5jdGlvbiBRckNvZGUkMSgpIHtcblxuICAgICAgICB0aGlzLmltYWdlZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMucXJDb2RlU3ltYm9sID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsO1xuICAgIH1cblxuXG4gICAgUXJDb2RlJDEucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHNyYywgZGF0YSkge1xuXG4gICAgICAgIHZhciBkZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5wcm9jZXNzKHRoaXMuaW1hZ2VkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IGU7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5lcnJvciwgdGhpcy5yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcblxuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgICAgaWYgKHNyYyAhPT0gdW5kZWZpbmVkICYmIHNyYy53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLyogZGVjb2RlIGZyb20gY2FudmFzIGNhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YSAqL1xuICAgICAgICB0aGlzLndpZHRoID0gc3JjLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuaW1hZ2VkYXRhID0ge1wiZGF0YVwiOiBkYXRhIHx8IHNyYy5kYXRhfTtcbiAgICAgICAgdGhpcy5pbWFnZWRhdGEud2lkdGggPSBzcmMud2lkdGg7XG4gICAgICAgIHRoaXMuaW1hZ2VkYXRhLmhlaWdodCA9IHNyYy5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIGRlY29kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgSW1hZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNvdXJjZSBmb3JtYXQgaXMgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGVudmlyb25tZW50LCB5b3UgbmVlZCB0byBwYXNzIGFuIGltYWdlIGJ1ZmZlciB3aXRoIHdpZHRoIGFuZCBoZWlnaHQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZWRpOTk5OS9qc3FyY29kZS9ibG9iL21hc3Rlci90ZXN0L3FyY29kZS5qcylcIik7XG4gICAgICB9XG4gICAgLyogZGVjb2RlIGZyb20gVVJMICovXG5cbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcblxuICAgICAgICBpbWFnZS5vbmxvYWQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICB2YXIgY2FudmFzX3FyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXNfcXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB2YXIgY2FudmFzX291dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3V0LWNhbnZhc1wiKTtcblxuICAgICAgICAgIGlmIChjYW52YXNfb3V0ICE9PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHZhciBvdXRjdHggPSBjYW52YXNfb3V0LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBvdXRjdHguY2xlYXJSZWN0KDAsIDAsIDMyMCwgMjQwKTtcbiAgICAgICAgICAgIG91dGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDMyMCwgMjQwKTtcbiAgICAgICAgfVxuXG4gICAgICAgICAgY2FudmFzX3FyLndpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgY2FudmFzX3FyLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLnJlc3VsdCA9IFwiQ3Jvc3MgZG9tYWluIGltYWdlIHJlYWRpbmcgbm90IHN1cHBvcnRlZCBpbiB5b3VyIGJyb3dzZXIhIFNhdmUgaXQgdG8geW91ciBjb21wdXRlciB0aGVuIGRyYWcgYW5kIGRyb3AgdGhlIGZpbGUhXCI7XG4gICAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgIT09IG51bGwpIHJldHVybiB0aGlzLmNhbGxiYWNrKG51bGwsIHRoaXMucmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgICAgIGRlY29kZSgpO1xuXG4gICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9XG4gICAgfTtcblxuICAgIFFyQ29kZSQxLnByb3RvdHlwZS5kZWNvZGVfdXRmOCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocykpO1xuICAgIH07XG5cbiAgICBRckNvZGUkMS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmdyYXlTY2FsZVRvQml0bWFwKGltYWdlRGF0YSk7XG5cbiAgICAgICAgdmFyIGRldGVjdG9yID0gbmV3IERldGVjdG9yKGltYWdlKTtcblxuICAgICAgICB2YXIgcVJDb2RlTWF0cml4ID0gZGV0ZWN0b3IuZGV0ZWN0KCk7XG5cbiAgLypmb3IgKHZhciB5ID0gMDsgeSA8IHFSQ29kZU1hdHJpeC5iaXRzLmhlaWdodDsgeSsrKVxuICAge1xuICAgZm9yICh2YXIgeCA9IDA7IHggPCBxUkNvZGVNYXRyaXguYml0cy53aWR0aDsgeCsrKVxuICAge1xuICAgdmFyIHBvaW50ID0gKHggKiA0KjIpICsgKHkqMiAqIGltYWdlRGF0YS53aWR0aCAqIDQpO1xuICAgaW1hZ2VEYXRhLmRhdGFbcG9pbnRdID0gcVJDb2RlTWF0cml4LmJpdHMuZ2V0X1JlbmFtZWQoeCx5KT8wOjA7XG4gICBpbWFnZURhdGEuZGF0YVtwb2ludCsxXSA9IHFSQ29kZU1hdHJpeC5iaXRzLmdldF9SZW5hbWVkKHgseSk/MDowO1xuICAgaW1hZ2VEYXRhLmRhdGFbcG9pbnQrMl0gPSBxUkNvZGVNYXRyaXguYml0cy5nZXRfUmVuYW1lZCh4LHkpPzI1NTowO1xuICAgfVxuICAgfSovXG5cbiAgICAgICAgdmFyIHJlYWRlciA9IERlY29kZXIuZGVjb2RlKHFSQ29kZU1hdHJpeC5iaXRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSByZWFkZXIuRGF0YUJ5dGU7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKVxuICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV1bal0pO1xuICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdRUiBDb2RlIHByb2Nlc3NpbmcgdGltZSAobXMpOiAnICsgdGltZSk7XG4gICAgfVxuICAgICAgICByZXR1cm4ge3Jlc3VsdDogdGhpcy5kZWNvZGVfdXRmOChzdHIpLCBwb2ludHM6IHFSQ29kZU1hdHJpeC5wb2ludHN9O1xuICAgIH07XG5cbiAgICBRckNvZGUkMS5wcm90b3R5cGUuZ2V0UGl4ZWwgPSBmdW5jdGlvbihpbWFnZURhdGEsIHgsIHkpIHtcbiAgICAgICAgaWYgKGltYWdlRGF0YS53aWR0aCA8IHgpIHtcbiAgICAgICAgdGhyb3cgXCJwb2ludCBlcnJvclwiO1xuICAgIH1cbiAgICAgICAgaWYgKGltYWdlRGF0YS5oZWlnaHQgPCB5KSB7XG4gICAgICAgIHRocm93IFwicG9pbnQgZXJyb3JcIjtcbiAgICB9XG4gICAgICAgIHZhciBwb2ludCA9ICh4ICogNCkgKyAoeSAqIGltYWdlRGF0YS53aWR0aCAqIDQpO1xuICAgICAgICByZXR1cm4gKGltYWdlRGF0YS5kYXRhW3BvaW50XSAqIDMzICsgaW1hZ2VEYXRhLmRhdGFbcG9pbnQgKyAxXSAqIDM0ICsgaW1hZ2VEYXRhLmRhdGFbcG9pbnQgKyAyXSAqIDMzKSAvIDEwMDtcbiAgICB9O1xuXG4gICAgUXJDb2RlJDEucHJvdG90eXBlLmJpbmFyaXplID0gZnVuY3Rpb24odGgpIHtcbiAgICAgICAgdmFyIHJldCA9IG5ldyBBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICB2YXIgZ3JheSA9IHRoaXMuZ2V0UGl4ZWwoeCwgeSk7XG5cbiAgICAgICAgICByZXRbeCArIHkgKiB0aGlzLndpZHRoXSA9IGdyYXkgPD0gdGg7XG4gICAgICB9XG4gICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBRckNvZGUkMS5wcm90b3R5cGUuZ2V0TWlkZGxlQnJpZ2h0bmVzc1BlckFyZWEgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAgICAgdmFyIG51bVNxcnRBcmVhID0gNDtcbiAgLy9vYnRhaW4gbWlkZGxlIGJyaWdodG5lc3MoKG1pbiArIG1heCkgLyAyKSBwZXIgYXJlYVxuICAgICAgICB2YXIgYXJlYVdpZHRoID0gTWF0aC5mbG9vcihpbWFnZURhdGEud2lkdGggLyBudW1TcXJ0QXJlYSk7XG4gICAgICAgIHZhciBhcmVhSGVpZ2h0ID0gTWF0aC5mbG9vcihpbWFnZURhdGEuaGVpZ2h0IC8gbnVtU3FydEFyZWEpO1xuICAgICAgICB2YXIgbWlubWF4ID0gbmV3IEFycmF5KG51bVNxcnRBcmVhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TcXJ0QXJlYTsgaSsrKSB7XG4gICAgICAgIG1pbm1heFtpXSA9IG5ldyBBcnJheShudW1TcXJ0QXJlYSk7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBudW1TcXJ0QXJlYTsgaTIrKykge1xuICAgICAgICAgIG1pbm1heFtpXVtpMl0gPSBbMCwgMF07XG4gICAgICB9XG4gICAgfVxuICAgICAgICBmb3IgKHZhciBheSA9IDA7IGF5IDwgbnVtU3FydEFyZWE7IGF5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYXggPSAwOyBheCA8IG51bVNxcnRBcmVhOyBheCsrKSB7XG4gICAgICAgICAgbWlubWF4W2F4XVtheV1bMF0gPSAweEZGO1xuICAgICAgICAgIGZvciAodmFyIGR5ID0gMDsgZHkgPCBhcmVhSGVpZ2h0OyBkeSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkeCA9IDA7IGR4IDwgYXJlYVdpZHRoOyBkeCsrKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBpbWFnZURhdGEuZGF0YVthcmVhV2lkdGggKiBheCArIGR4ICsgKGFyZWFIZWlnaHQgKiBheSArIGR5KSAqIGltYWdlRGF0YS53aWR0aF07XG4gICAgICAgICAgICAgIGlmICh0YXJnZXQgPCBtaW5tYXhbYXhdW2F5XVswXSlcbiAgICAgICAgICAgICAgICBtaW5tYXhbYXhdW2F5XVswXSA9IHRhcmdldDtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldCA+IG1pbm1heFtheF1bYXldWzFdKVxuICAgICAgICAgICAgICAgIG1pbm1heFtheF1bYXldWzFdID0gdGFyZ2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAgICAgdmFyIG1pZGRsZSA9IG5ldyBBcnJheShudW1TcXJ0QXJlYSk7XG4gICAgICAgIGZvciAodmFyIGkzID0gMDsgaTMgPCBudW1TcXJ0QXJlYTsgaTMrKykge1xuICAgICAgICBtaWRkbGVbaTNdID0gbmV3IEFycmF5KG51bVNxcnRBcmVhKTtcbiAgICB9XG4gICAgICAgIGZvciAodmFyIGF5ID0gMDsgYXkgPCBudW1TcXJ0QXJlYTsgYXkrKykge1xuICAgICAgICBmb3IgKHZhciBheCA9IDA7IGF4IDwgbnVtU3FydEFyZWE7IGF4KyspIHtcbiAgICAgICAgICBtaWRkbGVbYXhdW2F5XSA9IE1hdGguZmxvb3IoKG1pbm1heFtheF1bYXldWzBdICsgbWlubWF4W2F4XVtheV1bMV0pIC8gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfTtcblxuICAgIFFyQ29kZSQxLnByb3RvdHlwZS5ncmF5U2NhbGVUb0JpdG1hcCA9IGZ1bmN0aW9uKGdyYXlTY2FsZUltYWdlRGF0YSkge1xuICAgICAgICB2YXIgbWlkZGxlID0gdGhpcy5nZXRNaWRkbGVCcmlnaHRuZXNzUGVyQXJlYShncmF5U2NhbGVJbWFnZURhdGEpO1xuICAgICAgICB2YXIgc3FydE51bUFyZWEgPSBtaWRkbGUubGVuZ3RoO1xuICAgICAgICB2YXIgYXJlYVdpZHRoID0gTWF0aC5mbG9vcihncmF5U2NhbGVJbWFnZURhdGEud2lkdGggLyBzcXJ0TnVtQXJlYSk7XG4gICAgICAgIHZhciBhcmVhSGVpZ2h0ID0gTWF0aC5mbG9vcihncmF5U2NhbGVJbWFnZURhdGEuaGVpZ2h0IC8gc3FydE51bUFyZWEpO1xuXG4gICAgICAgIGZvciAodmFyIGF5ID0gMDsgYXkgPCBzcXJ0TnVtQXJlYTsgYXkrKykge1xuICAgICAgICBmb3IgKHZhciBheCA9IDA7IGF4IDwgc3FydE51bUFyZWE7IGF4KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBkeSA9IDA7IGR5IDwgYXJlYUhlaWdodDsgZHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZHggPSAwOyBkeCA8IGFyZWFXaWR0aDsgZHgrKykge1xuICAgICAgICAgICAgICBncmF5U2NhbGVJbWFnZURhdGEuZGF0YVthcmVhV2lkdGggKiBheCArIGR4ICsgKGFyZWFIZWlnaHQgKiBheSArIGR5KSAqIGdyYXlTY2FsZUltYWdlRGF0YS53aWR0aF0gPSAoZ3JheVNjYWxlSW1hZ2VEYXRhLmRhdGFbYXJlYVdpZHRoICogYXggKyBkeCArIChhcmVhSGVpZ2h0ICogYXkgKyBkeSkgKiBncmF5U2NhbGVJbWFnZURhdGEud2lkdGhdIDwgbWlkZGxlW2F4XVtheV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAgICAgcmV0dXJuIGdyYXlTY2FsZUltYWdlRGF0YTtcbiAgICB9O1xuXG4gICAgUXJDb2RlJDEucHJvdG90eXBlLmdyYXlzY2FsZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KGltYWdlRGF0YS53aWR0aCAqIGltYWdlRGF0YS5oZWlnaHQpO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW1hZ2VEYXRhLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgaW1hZ2VEYXRhLndpZHRoOyB4KyspIHtcbiAgICAgICAgICB2YXIgZ3JheSA9IHRoaXMuZ2V0UGl4ZWwoaW1hZ2VEYXRhLCB4LCB5KTtcblxuICAgICAgICAgIHJldFt4ICsgeSAqIGltYWdlRGF0YS53aWR0aF0gPSBncmF5O1xuICAgICAgfVxuICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBpbWFnZURhdGEud2lkdGgsXG4gICAgICAgIGRhdGE6IHJldFxuICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFVSU2hpZnQobnVtYmVyLCBiaXRzKSB7XG4gICAgICAgIGlmIChudW1iZXIgPj0gMClcbiAgICAgICAgcmV0dXJuIG51bWJlciA+PiBiaXRzO1xuICBlbHNlXG4gICAgcmV0dXJuIChudW1iZXIgPj4gYml0cykgKyAoMiA8PCB+Yml0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFFyQ29kZSQxO1xuXG59KSkpO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGliL3FyY29kZS1yZWFkZXIvaW5kZXguanMiLCJpbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4uL2NvbW1vbi9pbWFnZV93cmFwcGVyJztcbmltcG9ydCB7XG4gICAgY2FsY3VsYXRlUGF0Y2hTaXplLFxuICAgIG90c3VUaHJlc2hvbGQsXG4gICAgaHN2MnJnYixcbiAgICBjbHVzdGVyLFxuICAgIHRvcEdlbmVyaWMsXG4gICAgaW1hZ2VSZWYsXG4gICAgaGFsZlNhbXBsZSxcbiAgICBjb21wdXRlSW1hZ2VBcmVhXG59IGZyb20gJy4uL2NvbW1vbi9jdl91dGlscyc7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5pbXBvcnQgSW1hZ2VEZWJ1ZyBmcm9tICcuLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJhc3Rlcml6ZXIgZnJvbSAnLi9yYXN0ZXJpemVyJztcbmltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuaW1wb3J0IHNrZWxldG9uaXplciBmcm9tICcuL3NrZWxldG9uaXplcic7XG5jb25zdCB2ZWMyID0ge1xuICAgIGNsb25lOiByZXF1aXJlKCdnbC12ZWMyL2Nsb25lJyksXG4gICAgZG90OiAgcmVxdWlyZSgnZ2wtdmVjMi9kb3QnKSxcbiAgICBzY2FsZTogcmVxdWlyZSgnZ2wtdmVjMi9zY2FsZScpLFxuICAgIHRyYW5zZm9ybU1hdDI6IHJlcXVpcmUoJ2dsLXZlYzIvdHJhbnNmb3JtTWF0MicpXG59O1xuY29uc3QgbWF0MiA9IHtcbiAgICBjb3B5OiByZXF1aXJlKCdnbC1tYXQyL2NvcHknKSxcbiAgICBjcmVhdGU6IHJlcXVpcmUoJ2dsLW1hdDIvY3JlYXRlJyksXG4gICAgaW52ZXJ0OiByZXF1aXJlKCdnbC1tYXQyL2ludmVydCcpXG59XG5cbnZhciBfY29uZmlnLFxuICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyLFxuICAgIF9za2VsSW1hZ2VXcmFwcGVyLFxuICAgIF9zdWJJbWFnZVdyYXBwZXIsXG4gICAgX2xhYmVsSW1hZ2VXcmFwcGVyLFxuICAgIF9wYXRjaEdyaWQsXG4gICAgX3BhdGNoTGFiZWxHcmlkLFxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkLFxuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIsXG4gICAgX3BhdGNoU2l6ZSxcbiAgICBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgIGJpbmFyeTogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBkb206IHtcbiAgICAgICAgICAgIGJpbmFyeTogbnVsbFxuICAgICAgICB9XG4gICAgfSxcbiAgICBfbnVtUGF0Y2hlcyA9IHt4OiAwLCB5OiAwfSxcbiAgICBfaW5wdXRJbWFnZVdyYXBwZXIsXG4gICAgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgdmFyIHNrZWxldG9uSW1hZ2VEYXRhO1xuXG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgeDogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCAvIDIgfCAwLFxuICAgICAgICAgICAgeTogX2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueSAvIDIgfCAwXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgX251bVBhdGNoZXMueCA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueCAvIF9wYXRjaFNpemUueCB8IDA7XG4gICAgX251bVBhdGNoZXMueSA9IF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9wYXRjaFNpemUueSB8IDA7XG5cbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfY3VycmVudEltYWdlV3JhcHBlci5zaXplLCB1bmRlZmluZWQsIFVpbnQ4QXJyYXksIGZhbHNlKTtcblxuICAgIF9sYWJlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG5cbiAgICBza2VsZXRvbkltYWdlRGF0YSA9IG5ldyBBcnJheUJ1ZmZlcig2NCAqIDEwMjQpO1xuICAgIF9zdWJJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCAwLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpKTtcbiAgICBfc2tlbEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX3BhdGNoU2l6ZSxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoc2tlbGV0b25JbWFnZURhdGEsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSAqIDMsIF9wYXRjaFNpemUueCAqIF9wYXRjaFNpemUueSksXG4gICAgICAgIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgX3NrZWxldG9uaXplciA9IHNrZWxldG9uaXplcigodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpID8gd2luZG93IDogKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogZ2xvYmFsLCB7XG4gICAgICAgIHNpemU6IF9wYXRjaFNpemUueFxuICAgIH0sIHNrZWxldG9uSW1hZ2VEYXRhKTtcblxuICAgIF9pbWFnZVRvUGF0Y2hHcmlkID0gbmV3IEltYWdlV3JhcHBlcih7XG4gICAgICAgIHg6IChfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnggLyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCkgfCAwLFxuICAgICAgICB5OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLnkpIHwgMFxuICAgIH0sIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuICAgIF9wYXRjaEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBfcGF0Y2hMYWJlbEdyaWQgPSBuZXcgSW1hZ2VXcmFwcGVyKF9pbWFnZVRvUGF0Y2hHcmlkLnNpemUsIHVuZGVmaW5lZCwgSW50MzJBcnJheSwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXRDYW52YXMoKSB7XG4gICAgaWYgKF9jb25maWcudXNlV29ya2VyIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSBcImJpbmFyeUJ1ZmZlclwiO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Q2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGVidWdcIikuYXBwZW5kQ2hpbGQoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5KTtcbiAgICB9XG4gICAgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5ID0gX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICB2YXIgb3ZlckF2ZyxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgcGF0Y2gsXG4gICAgICAgIHRyYW5zTWF0LFxuICAgICAgICBtaW54ID1cbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLngsXG4gICAgICAgIG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueSxcbiAgICAgICAgYm94LFxuICAgICAgICBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIG92ZXJBdmcgKz0gcGF0Y2gucmFkO1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1BhdGNoZXMpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiBcInJlZFwifSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvdmVyQXZnIC89IHBhdGNoZXMubGVuZ3RoO1xuICAgIG92ZXJBdmcgPSAob3ZlckF2ZyAqIDE4MCAvIE1hdGguUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICBpZiAob3ZlckF2ZyA8IDApIHtcbiAgICAgICAgb3ZlckF2ZyArPSAxODA7XG4gICAgfVxuXG4gICAgb3ZlckF2ZyA9ICgxODAgLSBvdmVyQXZnKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdHJhbnNNYXQgPSBtYXQyLmNvcHkobWF0Mi5jcmVhdGUoKSwgW01hdGguY29zKG92ZXJBdmcpLCBNYXRoLnNpbihvdmVyQXZnKSwgLU1hdGguc2luKG92ZXJBdmcpLCBNYXRoLmNvcyhvdmVyQXZnKV0pO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHBhdGNoZXMgYW5kIHJvdGF0ZSBieSBhbmdsZVxuICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNbaV07XG4gICAgICAgIGZvciAoIGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7eDogMCwgeTogMX0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmluZCBib3VuZGluZyBib3hcbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA8IG1pbngpIHtcbiAgICAgICAgICAgICAgICBtaW54ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVswXSA+IG1heHgpIHtcbiAgICAgICAgICAgICAgICBtYXh4ID0gcGF0Y2guYm94W2pdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA8IG1pbnkpIHtcbiAgICAgICAgICAgICAgICBtaW55ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGNoLmJveFtqXVsxXSA+IG1heHkpIHtcbiAgICAgICAgICAgICAgICBtYXh5ID0gcGF0Y2guYm94W2pdWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm94ID0gW1ttaW54LCBtaW55XSwgW21heHgsIG1pbnldLCBbbWF4eCwgbWF4eV0sIFttaW54LCBtYXh5XV07XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd1RyYW5zZm9ybWVkQm94KSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7eDogMCwgeTogMX0sIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSwge2NvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMn0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yICggaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgdmVjMi50cmFuc2Zvcm1NYXQyKGJveFtqXSwgYm94W2pdLCB0cmFuc01hdCk7XG4gICAgfVxuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLmJveEZyb21QYXRjaGVzLnNob3dCQikge1xuICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwge3g6IDAsIHk6IDF9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHtjb2xvcjogJyNmZjAwMDAnLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICB9XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnNjYWxlKGJveFtqXSwgYm94W2pdLCBzY2FsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJveDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmluYXJ5IGltYWdlIG9mIHRoZSBjdXJyZW50IGltYWdlXG4gKi9cbmZ1bmN0aW9uIGJpbmFyaXplSW1hZ2UoKSB7XG4gICAgb3RzdVRocmVzaG9sZChfY3VycmVudEltYWdlV3JhcHBlciwgX2JpbmFyeUltYWdlV3JhcHBlcik7XG4gICAgX2JpbmFyeUltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dDYW52YXMpIHtcbiAgICAgICAgX2JpbmFyeUltYWdlV3JhcHBlci5zaG93KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMjU1KTtcbiAgICB9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgaW1hZ2VcbiAqIGV4dHJhY3QgcGF0Y2hlc1xuICovXG5mdW5jdGlvbiBmaW5kUGF0Y2hlcygpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgbW9tZW50cyxcbiAgICAgICAgcGF0Y2hlc0ZvdW5kID0gW10sXG4gICAgICAgIHJhc3Rlcml6ZXIsXG4gICAgICAgIHJhc3RlclJlc3VsdCxcbiAgICAgICAgcGF0Y2g7XG4gICAgZm9yIChpID0gMDsgaSA8IF9udW1QYXRjaGVzLng7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX251bVBhdGNoZXMueTsgaisrKSB7XG4gICAgICAgICAgICB4ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnggKiBpO1xuICAgICAgICAgICAgeSA9IF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55ICogajtcblxuICAgICAgICAgICAgLy8gc2VwZXJhdGUgcGFydHNcbiAgICAgICAgICAgIHNrZWxldG9uaXplKHgsIHkpO1xuXG4gICAgICAgICAgICAvLyBSYXN0ZXJpemUsIGZpbmQgaW5kaXZpZHVhbCBiYXJzXG4gICAgICAgICAgICBfc2tlbEltYWdlV3JhcHBlci56ZXJvQm9yZGVyKCk7XG4gICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KF9sYWJlbEltYWdlV3JhcHBlci5kYXRhLCAwKTtcbiAgICAgICAgICAgIHJhc3Rlcml6ZXIgPSBSYXN0ZXJpemVyLmNyZWF0ZShfc2tlbEltYWdlV3JhcHBlciwgX2xhYmVsSW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIHJhc3RlclJlc3VsdCA9IHJhc3Rlcml6ZXIucmFzdGVyaXplKDApO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0xhYmVscykge1xuICAgICAgICAgICAgICAgIF9sYWJlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgTWF0aC5mbG9vcigzNjAgLyByYXN0ZXJSZXN1bHQuY291bnQpLFxuICAgICAgICAgICAgICAgICAgICB7eDogeCwgeTogeX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgbW9tZW50cyBmcm9tIHRoZSBza2VsZXRvbml6ZWQgcGF0Y2hcbiAgICAgICAgICAgIG1vbWVudHMgPSBfbGFiZWxJbWFnZVdyYXBwZXIubW9tZW50cyhyYXN0ZXJSZXN1bHQuY291bnQpO1xuXG4gICAgICAgICAgICAvLyBleHRyYWN0IGVsaWdpYmxlIHBhdGNoZXNcbiAgICAgICAgICAgIHBhdGNoZXNGb3VuZCA9IHBhdGNoZXNGb3VuZC5jb25jYXQoZGVzY3JpYmVQYXRjaChtb21lbnRzLCBbaSwgal0sIHgsIHkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93Rm91bmRQYXRjaGVzKSB7XG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7Y29sb3I6IFwiIzk5ZmYwMFwiLCBsaW5lV2lkdGg6IDJ9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCl7XG4gICAgdmFyIGksXG4gICAgICAgIHN1bSxcbiAgICAgICAgbGFiZWxIaXN0ID0gW10sXG4gICAgICAgIHRvcExhYmVscyA9IFtdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBsYWJlbDogaWR4ICsgMVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYi52YWwgLSBhLnZhbDtcbiAgICB9KTtcblxuICAgIC8vIGV4dHJhY3QgdG9wIGFyZWFzIHdpdGggYXQgbGVhc3QgNiBwYXRjaGVzIHByZXNlbnRcbiAgICB0b3BMYWJlbHMgPSBsYWJlbEhpc3QuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC52YWwgPj0gNTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0b3BMYWJlbHM7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBwYXRjaGVzID0gW10sXG4gICAgICAgIHBhdGNoLFxuICAgICAgICBib3gsXG4gICAgICAgIGJveGVzID0gW10sXG4gICAgICAgIGhzdiA9IFswLCAxLCAxXSxcbiAgICAgICAgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB0b3BMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3VtID0gX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoO1xuICAgICAgICBwYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHdoaWxlIChzdW0tLSkge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gPT09IHRvcExhYmVsc1tpXS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtzdW1dO1xuICAgICAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm94ID0gYm94RnJvbVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICAgIGJveGVzLnB1c2goYm94KTtcblxuICAgICAgICAgICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBwYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGNoID0gcGF0Y2hlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaHN2WzBdID0gKHRvcExhYmVsc1tpXS5sYWJlbCAvIChtYXhMYWJlbCArIDEpKSAqIDM2MDtcbiAgICAgICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvcjogXCJyZ2IoXCIgKyByZ2Iuam9pbihcIixcIikgKyBcIilcIiwgbGluZVdpZHRoOiAyfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcztcbn1cblxuLyoqXG4gKiBGaW5kIHNpbWlsYXIgbW9tZW50cyAodmlhIGNsdXN0ZXIpXG4gKiBAcGFyYW0ge09iamVjdH0gbW9tZW50c1xuICovXG5mdW5jdGlvbiBzaW1pbGFyTW9tZW50cyhtb21lbnRzKSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICB2YXIgdG9wQ2x1c3RlciA9IHRvcEdlbmVyaWMoY2x1c3RlcnMsIDEsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuZ2V0UG9pbnRzKCkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHZhciBwb2ludHMgPSBbXSwgcmVzdWx0ID0gW107XG4gICAgaWYgKHRvcENsdXN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBvaW50cyA9IHRvcENsdXN0ZXJbMF0uaXRlbS5nZXRQb2ludHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBvaW50c1tpXS5wb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2tlbGV0b25pemUoeCwgeSkge1xuICAgIF9iaW5hcnlJbWFnZVdyYXBwZXIuc3ViSW1hZ2VBc0NvcHkoX3N1YkltYWdlV3JhcHBlciwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIF9za2VsZXRvbml6ZXIuc2tlbGV0b25pemUoKTtcblxuICAgIC8vIFNob3cgc2tlbGV0b24gaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dTa2VsZXRvbikge1xuICAgICAgICBfc2tlbEltYWdlV3JhcHBlci5vdmVybGF5KF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSwgMzYwLCBpbWFnZVJlZih4LCB5KSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGFuZCBkZXNjcmliZXMgdGhvc2UgcGF0Y2hlcyB3aGljaCBzZWVtIHRvIGNvbnRhaW4gYSBiYXJjb2RlIHBhdHRlcm5cbiAqIEBwYXJhbSB7QXJyYXl9IG1vbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaFBvcyxcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybnMge0FycmF5fSBsaXN0IG9mIHBhdGNoZXNcbiAqL1xuZnVuY3Rpb24gZGVzY3JpYmVQYXRjaChtb21lbnRzLCBwYXRjaFBvcywgeCwgeSkge1xuICAgIHZhciBrLFxuICAgICAgICBhdmcsXG4gICAgICAgIGVsaWdpYmxlTW9tZW50cyA9IFtdLFxuICAgICAgICBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgIHBhdGNoLFxuICAgICAgICBwYXRjaGVzRm91bmQgPSBbXSxcbiAgICAgICAgbWluQ29tcG9uZW50V2VpZ2h0ID0gTWF0aC5jZWlsKF9wYXRjaFNpemUueCAvIDMpO1xuXG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgLy8gb25seSBjb2xsZWN0IG1vbWVudHMgd2hpY2gncyBhcmVhIGNvdmVycyBhdCBsZWFzdCBtaW5Db21wb25lbnRXZWlnaHQgcGl4ZWxzLlxuICAgICAgICBmb3IgKCBrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yICggayA9IDA7IGsgPCBtYXRjaGluZ01vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBhdmcgKz0gbWF0Y2hpbmdNb21lbnRzW2tdLnJhZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB0d28gb2YgdGhlIG1vbWVudHMgYXJlIGFsbG93ZWQgbm90IHRvIGZpdCBpbnRvIHRoZSBlcXVhdGlvblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBwYXRjaCB0byB0aGUgc2V0XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICAgICAgICAgJiYgbWF0Y2hpbmdNb21lbnRzLmxlbmd0aCA+PSAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCAvIDQpICogM1xuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gbW9tZW50cy5sZW5ndGggLyA0KSB7XG4gICAgICAgICAgICAgICAgYXZnIC89IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXRjaFBvc1sxXSAqIF9udW1QYXRjaGVzLnggKyBwYXRjaFBvc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudHM6IG1hdGNoaW5nTW9tZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcmFkOiBhdmcsXG4gICAgICAgICAgICAgICAgICAgIHZlYzogdmVjMi5jbG9uZShbTWF0aC5jb3MoYXZnKSwgTWF0aC5zaW4oYXZnKV0pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzRm91bmQucHVzaChwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGNoZXNGb3VuZDtcbn1cblxuLyoqXG4gKiBmaW5kcyBwYXRjaGVzIHdoaWNoIGFyZSBjb25uZWN0ZWQgYW5kIHNoYXJlIHRoZSBzYW1lIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hlc0ZvdW5kXG4gKi9cbmZ1bmN0aW9uIHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCkge1xuICAgIHZhciBsYWJlbCA9IDAsXG4gICAgICAgIHRocmVzaG9sZCA9IDAuOTUsXG4gICAgICAgIGN1cnJJZHggPSAwLFxuICAgICAgICBqLFxuICAgICAgICBwYXRjaCxcbiAgICAgICAgaHN2ID0gWzAsIDEsIDFdLFxuICAgICAgICByZ2IgPSBbMCwgMCwgMF07XG5cbiAgICBmdW5jdGlvbiBub3RZZXRQcm9jZXNzZWQoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbaV0gPT09IDAgJiYgX3BhdGNoR3JpZC5kYXRhW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9wYXRjaExhYmVsR3JpZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhY2UoY3VycmVudElkeCkge1xuICAgICAgICB2YXIgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBjdXJyZW50UGF0Y2gsXG4gICAgICAgICAgICBpZHgsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN1cnJlbnRJZHggJSBfcGF0Y2hMYWJlbEdyaWQuc2l6ZS54LFxuICAgICAgICAgICAgICAgIHk6IChjdXJyZW50SWR4IC8gX3BhdGNoTGFiZWxHcmlkLnNpemUueCkgfCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2ltaWxhcml0eTtcblxuICAgICAgICBpZiAoY3VycmVudElkeCA8IF9wYXRjaExhYmVsR3JpZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY3VycmVudFBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtjdXJyZW50SWR4XTtcbiAgICAgICAgICAgIC8vIGFzc2lnbiBsYWJlbFxuICAgICAgICAgICAgX3BhdGNoTGFiZWxHcmlkLmRhdGFbY3VycmVudElkeF0gPSBsYWJlbDtcbiAgICAgICAgICAgIGZvciAoIGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2ltaWxhcml0eSA9IE1hdGguYWJzKHZlYzIuZG90KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbaWR4XS52ZWMsIGN1cnJlbnRQYXRjaC52ZWMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpbWlsYXJpdHkgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKGlkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIGZvciBmaW5kaW5nIHRoZSByaWdodCBwYXRjaGVzXG4gICAgQXJyYXlIZWxwZXIuaW5pdChfcGF0Y2hHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoTGFiZWxHcmlkLmRhdGEsIDApO1xuICAgIEFycmF5SGVscGVyLmluaXQoX2ltYWdlVG9QYXRjaEdyaWQuZGF0YSwgbnVsbCk7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICB3aGlsZSAoKCBjdXJySWR4ID0gbm90WWV0UHJvY2Vzc2VkKCkpIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGxhYmVsKys7XG4gICAgICAgIHRyYWNlKGN1cnJJZHgpO1xuICAgIH1cblxuICAgIC8vIGRyYXcgcGF0Y2gtbGFiZWxzIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgZm9yICggaiA9IDA7IGogPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdID4gMCAmJiBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA8PSBsYWJlbCkge1xuICAgICAgICAgICAgICAgIHBhdGNoID0gX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtqXTtcbiAgICAgICAgICAgICAgICBoc3ZbMF0gPSAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gLyAobGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgaHN2MnJnYihoc3YsIHJnYik7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LFxuICAgICAgICAgICAgICAgICAgICB7Y29sb3I6IFwicmdiKFwiICsgcmdiLmpvaW4oXCIsXCIpICsgXCIpXCIsIGxpbmVXaWR0aDogMn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgaW5pdDogZnVuY3Rpb24oaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRjaGVzRm91bmQsXG4gICAgICAgICAgICB0b3BMYWJlbHMsXG4gICAgICAgICAgICBib3hlcztcblxuICAgICAgICBpZiAoX2NvbmZpZy5oYWxmU2FtcGxlKSB7XG4gICAgICAgICAgICBoYWxmU2FtcGxlKF9pbnB1dEltYWdlV3JhcHBlciwgX2N1cnJlbnRJbWFnZVdyYXBwZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmluYXJpemVJbWFnZSgpO1xuICAgICAgICBwYXRjaGVzRm91bmQgPSBmaW5kUGF0Y2hlcygpO1xuICAgICAgICAvLyByZXR1cm4gdW5sZXNzIDUlIG9yIG1vcmUgcGF0Y2hlcyBhcmUgZm91bmRcbiAgICAgICAgaWYgKHBhdGNoZXNGb3VuZC5sZW5ndGggPCBfbnVtUGF0Y2hlcy54ICogX251bVBhdGNoZXMueSAqIDAuMDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFzdGVycml6ZSBhcmVhIGJ5IGNvbXBhcmluZyBhbmd1bGFyIHNpbWlsYXJpdHk7XG4gICAgICAgIHZhciBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50czogZnVuY3Rpb24oaW5wdXRTdHJlYW0sIGNvbmZpZykge1xuICAgICAgICB2YXIgcGF0Y2hTaXplLFxuICAgICAgICAgICAgd2lkdGggPSBpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgICBoYWxmU2FtcGxlID0gY29uZmlnLmhhbGZTYW1wbGUgPyAwLjUgOiAxLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGFyZWE7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHdpZHRoIGFuZCBoZWlnaHQgYmFzZWQgb24gYXJlYVxuICAgICAgICBpZiAoaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSkge1xuICAgICAgICAgICAgYXJlYSA9IGNvbXB1dGVJbWFnZUFyZWEod2lkdGgsIGhlaWdodCwgaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCkuYXJlYSk7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zZXRUb3BSaWdodCh7eDogYXJlYS5zeCwgeTogYXJlYS5zeX0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7eDogd2lkdGgsIHk6IGhlaWdodH0pO1xuICAgICAgICAgICAgd2lkdGggPSBhcmVhLnN3O1xuICAgICAgICAgICAgaGVpZ2h0ID0gYXJlYS5zaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKHdpZHRoICogaGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIGhhbGZTYW1wbGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgcGF0Y2hTaXplID0gY2FsY3VsYXRlUGF0Y2hTaXplKGNvbmZpZy5wYXRjaFNpemUsIHNpemUpO1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhdGNoLVNpemU6IFwiICsgSlNPTi5zdHJpbmdpZnkocGF0Y2hTaXplKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyBoYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS54KSk7XG4gICAgICAgIGlucHV0U3RyZWFtLnNldEhlaWdodChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS55IC8gcGF0Y2hTaXplLnkpICogKDEgLyBoYWxmU2FtcGxlKSAqIHBhdGNoU2l6ZS55KSk7XG5cbiAgICAgICAgaWYgKChpbnB1dFN0cmVhbS5nZXRXaWR0aCgpICUgcGF0Y2hTaXplLngpID09PSAwICYmIChpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSAlIHBhdGNoU2l6ZS55KSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBjb21wbHkgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5nczogV2lkdGggKFwiICtcbiAgICAgICAgICAgIHdpZHRoICsgXCIgKWFuZCBoZWlnaHQgKFwiICsgaGVpZ2h0ICtcbiAgICAgICAgICAgIFwiKSBtdXN0IGEgbXVsdGlwbGUgb2YgXCIgKyBwYXRjaFNpemUueCk7XG4gICAgfVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sb2NhdG9yL2JhcmNvZGVfbG9jYXRvci5qcyIsImltcG9ydCBUcmFjZXIgZnJvbSAnLi90cmFjZXInO1xuXG4vKipcbiAqIGh0dHA6Ly93d3cuY29kZXByb2plY3QuY29tL1RpcHMvNDA3MTcyL0Nvbm5lY3RlZC1Db21wb25lbnQtTGFiZWxpbmctYW5kLVZlY3Rvcml6YXRpb25cbiAqL1xudmFyIFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcjogbnVsbCxcbiAgICAgICAgICAgIGluZGV4OiBudWxsLFxuICAgICAgICAgICAgZmlyc3RWZXJ0ZXg6IG51bGwsXG4gICAgICAgICAgICBpbnNpZGVDb250b3VyczogbnVsbCxcbiAgICAgICAgICAgIG5leHRwZWVyOiBudWxsLFxuICAgICAgICAgICAgcHJldnBlZXI6IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDJcbiAgICB9LFxuICAgIERJUjoge1xuICAgICAgICBPVVRTSURFX0VER0U6IC0zMjc2NyxcbiAgICAgICAgSU5TSURFX0VER0U6IC0zMjc2NlxuICAgIH0sXG4gICAgY3JlYXRlOiBmdW5jdGlvbihpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGEsXG4gICAgICAgICAgICBsYWJlbERhdGEgPSBsYWJlbFdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueCxcbiAgICAgICAgICAgIGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnksXG4gICAgICAgICAgICB0cmFjZXIgPSBUcmFjZXIuY3JlYXRlKGltYWdlV3JhcHBlciwgbGFiZWxXcmFwcGVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFzdGVyaXplOiBmdW5jdGlvbihkZXB0aGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBiYyxcbiAgICAgICAgICAgICAgICAgICAgbGMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgICAgICAgICBjeSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3JNYXAgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4LFxuICAgICAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgICAgICBjYyxcbiAgICAgICAgICAgICAgICAgICAgc2MsXG4gICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQ291bnQgPSAwLFxuICAgICAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0MDA7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xvck1hcFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29sb3JNYXBbMF0gPSBpbWFnZURhdGFbMF07XG4gICAgICAgICAgICAgICAgY2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAoIGN5ID0gMTsgY3kgPCBoZWlnaHQgLSAxOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsaW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yTWFwWzBdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKCBjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjOiBjYyxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvbm5lY3RlZENvdW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyOiBmdW5jdGlvbihjYW52YXMsIGZpcnN0Q29udG91cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gZmlyc3RDb250b3VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXEsXG4gICAgICAgICAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxID0gaXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBpcS5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBxID0gcHEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gcHEuaW5zaWRlQ29udG91cnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChxLmRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNXX0RJUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJibHVlXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuVU5LTk9XTl9ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJncmVlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcS5maXJzdFZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChwICE9PSBxLmZpcnN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSYXN0ZXJpemVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2F0b3IvcmFzdGVyaXplci5qcyIsIi8qIEBwcmVzZXJ2ZSBBU00gQkVHSU4gKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSovXG5mdW5jdGlvbiBTa2VsZXRvbml6ZXIoc3RkbGliLCBmb3JlaWduLCBidWZmZXIpIHtcbiAgICBcInVzZSBhc21cIjtcblxuICAgIHZhciBpbWFnZXMgPSBuZXcgc3RkbGliLlVpbnQ4QXJyYXkoYnVmZmVyKSxcbiAgICAgICAgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDAsXG4gICAgICAgIGltdWwgPSBzdGRsaWIuTWF0aC5pbXVsO1xuXG4gICAgZnVuY3Rpb24gZXJvZGUoaW5JbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgaW5JbWFnZVB0ciA9IGluSW1hZ2VQdHIgfCAwO1xuICAgICAgICBvdXRJbWFnZVB0ciA9IG91dEltYWdlUHRyIHwgMDtcblxuICAgICAgICB2YXIgdiA9IDAsXG4gICAgICAgICAgICB1ID0gMCxcbiAgICAgICAgICAgIHN1bSA9IDAsXG4gICAgICAgICAgICB5U3RhcnQxID0gMCxcbiAgICAgICAgICAgIHlTdGFydDIgPSAwLFxuICAgICAgICAgICAgeFN0YXJ0MSA9IDAsXG4gICAgICAgICAgICB4U3RhcnQyID0gMCxcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICggdiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKCB1ID0gMTsgKHUgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHUgPSAodSArIDEpIHwgMCkge1xuICAgICAgICAgICAgICAgIHlTdGFydDEgPSAob2Zmc2V0IC0gc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHlTdGFydDIgPSAob2Zmc2V0ICsgc2l6ZSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDEgPSAodSAtIDEpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQyID0gKHUgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgc3VtID0gKChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQyKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDIpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIGlmICgoc3VtIHwgMCkgPT0gKDUgfCAwKSkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgb2Zmc2V0ICsgdSkgfCAwXSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciA9IGFJbWFnZVB0ciB8IDA7XG4gICAgICAgIGJJbWFnZVB0ciA9IGJJbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9XG4gICAgICAgICAgICAgICAgKChpbWFnZXNbKGFJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApIC0gKGltYWdlc1soYkltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpdHdpc2VPcihhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyID0gYUltYWdlUHRyIHwgMDtcbiAgICAgICAgYkltYWdlUHRyID0gYkltYWdlUHRyIHwgMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgPSBvdXRJbWFnZVB0ciB8IDA7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKG91dEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID1cbiAgICAgICAgICAgICAgICAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBzdW0gPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIHN1bSA9ICgoc3VtIHwgMCkgKyAoaW1hZ2VzWyhpbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHN1bSB8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXQoaW1hZ2VQdHIsIHZhbHVlKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHwgMDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyID0gaW5JbWFnZVB0ciB8IDA7XG4gICAgICAgIG91dEltYWdlUHRyID0gb3V0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB2ID0gMCxcbiAgICAgICAgICAgIHUgPSAwLFxuICAgICAgICAgICAgc3VtID0gMCxcbiAgICAgICAgICAgIHlTdGFydDEgPSAwLFxuICAgICAgICAgICAgeVN0YXJ0MiA9IDAsXG4gICAgICAgICAgICB4U3RhcnQxID0gMCxcbiAgICAgICAgICAgIHhTdGFydDIgPSAwLFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcblxuICAgICAgICBmb3IgKCB2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAoIHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA+ICgwIHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lbWNweShzcmNJbWFnZVB0ciwgZHN0SW1hZ2VQdHIpIHtcbiAgICAgICAgc3JjSW1hZ2VQdHIgPSBzcmNJbWFnZVB0ciB8IDA7XG4gICAgICAgIGRzdEltYWdlUHRyID0gZHN0SW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhkc3RJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9IChpbWFnZXNbKHNyY0ltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvQm9yZGVyKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyID0gaW1hZ2VQdHIgfCAwO1xuXG4gICAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICAgIHkgPSAwO1xuXG4gICAgICAgIGZvciAoIHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeCkgfCAwXSA9IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggeCA9IDA7ICh4IHwgMCkgPCAoc2l6ZSB8IDApOyB4ID0gKHggKyAxKSB8IDApIHtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyB5KSB8IDBdID0gMDtcbiAgICAgICAgICAgIHkgPSAoeSArIDEpIHwgMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZWxldG9uaXplKCkge1xuICAgICAgICB2YXIgc3ViSW1hZ2VQdHIgPSAwLFxuICAgICAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSAwLFxuICAgICAgICAgICAgdGVtcEltYWdlUHRyID0gMCxcbiAgICAgICAgICAgIHNrZWxJbWFnZVB0ciA9IDAsXG4gICAgICAgICAgICBzdW0gPSAwLFxuICAgICAgICAgICAgZG9uZSA9IDA7XG5cbiAgICAgICAgZXJvZGVkSW1hZ2VQdHIgPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcbiAgICAgICAgdGVtcEltYWdlUHRyID0gKGVyb2RlZEltYWdlUHRyICsgZXJvZGVkSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgc2tlbEltYWdlUHRyID0gKHRlbXBJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG5cbiAgICAgICAgLy8gaW5pdCBza2VsLWltYWdlXG4gICAgICAgIGluaXQoc2tlbEltYWdlUHRyLCAwKTtcbiAgICAgICAgemVyb0JvcmRlcihzdWJJbWFnZVB0cik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZXJvZGUoc3ViSW1hZ2VQdHIsIGVyb2RlZEltYWdlUHRyKTtcbiAgICAgICAgICAgIGRpbGF0ZShlcm9kZWRJbWFnZVB0ciwgdGVtcEltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1YnRyYWN0KHN1YkltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBiaXR3aXNlT3Ioc2tlbEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIsIHNrZWxJbWFnZVB0cik7XG4gICAgICAgICAgICBtZW1jcHkoZXJvZGVkSW1hZ2VQdHIsIHN1YkltYWdlUHRyKTtcbiAgICAgICAgICAgIHN1bSA9IGNvdW50Tm9uWmVybyhzdWJJbWFnZVB0cikgfCAwO1xuICAgICAgICAgICAgZG9uZSA9ICgoc3VtIHwgMCkgPT0gMCB8IDApO1xuICAgICAgICB9IHdoaWxlICghZG9uZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNrZWxldG9uaXplOiBza2VsZXRvbml6ZVxuICAgIH07XG59XG4vKiBAcHJlc2VydmUgQVNNIEVORCAqL1xuZXhwb3J0IGRlZmF1bHQgU2tlbGV0b25pemVyO1xuLyogZXNsaW50LWVuYWJsZSBlcWVxZXEqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmZ1bmN0aW9uIFR3b09mRml2ZVJlYWRlcihvcHRzKSB7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMsIG9wdHMpO1xuICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IFsxLCAxXTtcbn1cblxudmFyIE4gPSAxLFxuICAgIFcgPSAzLFxuICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIFNUQVJUX1BBVFRFUk46IHt2YWx1ZTogW1csIE4sIFcsIE4sIE4sIE5dfSxcbiAgICAgICAgU1RPUF9QQVRURVJOOiB7dmFsdWU6IFtXLCBOLCBOLCBOLCBXXX0sXG4gICAgICAgIENPREVfUEFUVEVSTjoge3ZhbHVlOiBbXG4gICAgICAgICAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgICAgICBbTiwgVywgTiwgTiwgV10sXG4gICAgICAgICAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgICAgICBbVywgTiwgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgICAgICBbVywgTiwgTiwgVywgTl0sXG4gICAgICAgICAgICBbTiwgVywgTiwgVywgTl1cbiAgICAgICAgXX0sXG4gICAgICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNzgsIHdyaXRhYmxlOiB0cnVlfSxcbiAgICAgICAgQVZHX0NPREVfRVJST1I6IHt2YWx1ZTogMC4zMCwgd3JpdGFibGU6IHRydWV9LFxuICAgICAgICBGT1JNQVQ6IHt2YWx1ZTogXCIyb2Y1XCJ9XG4gICAgfTtcblxuY29uc3Qgc3RhcnRQYXR0ZXJuTGVuZ3RoID0gcHJvcGVydGllcy5TVEFSVF9QQVRURVJOLnZhbHVlLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUd29PZkZpdmVSZWFkZXI7XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIpIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUjtcblxuICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KTtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBzdGFydEluZm8sXG4gICAgICAgIG5hcnJvd0JhcldpZHRoID0gMTtcblxuICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgIHN0YXJ0SW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RBUlRfUEFUVEVSTiwgb2Zmc2V0LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gc3RhcnRQYXR0ZXJuTGVuZ3RoKTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2UobGVhZGluZ1doaXRlc3BhY2VTdGFydCwgc3RhcnRJbmZvLnN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICB9XG59O1xuXG5Ud29PZkZpdmVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2ZpbmRFbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGVuZEluZm8sXG4gICAgICAgIHRtcCxcbiAgICAgICAgb2Zmc2V0O1xuXG4gICAgc2VsZi5fcm93LnJldmVyc2UoKTtcbiAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3Jvdyk7XG4gICAgZW5kSW5mbyA9IHNlbGYuX2ZpbmRQYXR0ZXJuKHNlbGYuU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICBzZWxmLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgaWYgKGVuZEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gcmV2ZXJzZSBudW1iZXJzXG4gICAgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICBlbmRJbmZvLnN0YXJ0ID0gc2VsZi5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgIGVuZEluZm8uZW5kID0gc2VsZi5fcm93Lmxlbmd0aCAtIHRtcDtcblxuICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZUNvZGUgPSBmdW5jdGlvbihjb3VudGVyKSB7XG4gICAgdmFyIGosXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdW0gPSAwLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXBzaWxvbiA9IHNlbGYuQVZHX0NPREVfRVJST1IsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9O1xuXG4gICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgIH1cbiAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgfVxufTtcblxuVHdvT2ZGaXZlUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcykge1xuICAgIHZhciBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcG9zID0gMCxcbiAgICAgICAgY291bnRlckxlbmd0aCA9IGNvdW50ZXJzLmxlbmd0aCxcbiAgICAgICAgY291bnRlciA9IFswLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgY29kZTtcblxuICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJbaV0gPSBjb3VudGVyc1twb3NdICogdGhpcy5iYXJTcGFjZVJhdGlvWzBdO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY291bnRlcik7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlICsgXCJcIik7XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29kZTtcbn07XG5cblR3b09mRml2ZVJlYWRlci5wcm90b3R5cGUuX3ZlcmlmeUNvdW50ZXJMZW5ndGggPSBmdW5jdGlvbihjb3VudGVycykge1xuICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xufTtcblxuVHdvT2ZGaXZlUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgY291bnRlcnM7XG5cbiAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgIGVuZEluZm8gPSBzZWxmLl9maW5kRW5kKCk7XG4gICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0gc2VsZi5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPCA1KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlY29kZWRDb2Rlcy5wdXNoKGVuZEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZEluZm8uZW5kLFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXNcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHdvT2ZGaXZlUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RhYmFyUmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9jb3VudGVycyA9IFtdO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBBTFBIQUJFVEhfU1RSSU5HOiB7dmFsdWU6IFwiMDEyMzQ1Njc4OS0kOi8uK0FCQ0RcIn0sXG4gICAgQUxQSEFCRVQ6IHt2YWx1ZTogWzQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LCA0NSwgMzYsIDU4LCA0NywgNDYsIDQzLCA2NSwgNjYsIDY3LCA2OF19LFxuICAgIENIQVJBQ1RFUl9FTkNPRElOR1M6IHt2YWx1ZTogWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV19LFxuICAgIFNUQVJUX0VORDoge3ZhbHVlOiBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdfSxcbiAgICBNSU5fRU5DT0RFRF9DSEFSUzoge3ZhbHVlOiA0fSxcbiAgICBNQVhfQUNDRVBUQUJMRToge3ZhbHVlOiAyLjB9LFxuICAgIFBBRERJTkc6IHt2YWx1ZTogMS41fSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RhYmFyXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RhYmFyUmVhZGVyO1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGRlY29kZWRDaGFyLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBuZXh0U3RhcnQsXG4gICAgICAgIGVuZDtcblxuICAgIHRoaXMuX2NvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKCk7XG4gICAgc3RhcnQgPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBuZXh0U3RhcnQgPSBzdGFydC5zdGFydENvdW50ZXI7XG5cbiAgICBkbyB7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ2hhciA9IHNlbGYuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgIGlmIChkZWNvZGVkQ2hhciA8IDApe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goZGVjb2RlZENoYXIpO1xuICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAxICYmIHNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAobmV4dFN0YXJ0IDwgc2VsZi5fY291bnRlcnMubGVuZ3RoKTtcblxuICAgIC8vIHZlcmlmeSBlbmRcbiAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IHNlbGYuTUlOX0VOQ09ERURfQ0hBUlMgfHwgIXNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5IGVuZCB3aGl0ZSBzcGFjZVxuICAgIGlmICghc2VsZi5fdmVyaWZ5V2hpdGVzcGFjZShzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLl92YWxpZGF0ZVJlc3VsdChyZXN1bHQsIHN0YXJ0LnN0YXJ0Q291bnRlcikpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiBzZWxmLl9jb3VudGVycy5sZW5ndGggPyBzZWxmLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgZW5kID0gc3RhcnQuc3RhcnQgKyBzZWxmLl9zdW1Db3VudGVycyhzdGFydC5zdGFydENvdW50ZXIsIG5leHRTdGFydCAtIDgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIHN0YXJ0SW5mbzogc3RhcnQsXG4gICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0XG4gICAgfTtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlXaGl0ZXNwYWNlID0gZnVuY3Rpb24oc3RhcnRDb3VudGVyLCBlbmRDb3VudGVyKSB7XG4gICAgaWYgKChzdGFydENvdW50ZXIgLSAxIDw9IDApXG4gICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tzdGFydENvdW50ZXIgLSAxXSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChzdGFydENvdW50ZXIpIC8gMi4wKSkge1xuICAgICAgICBpZiAoKGVuZENvdW50ZXIgKyA4ID49IHRoaXMuX2NvdW50ZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9jb3VudGVyc1tlbmRDb3VudGVyICsgN10gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoZW5kQ291bnRlcikgLyAyLjApKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgIHZhciBpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgZm9yIChpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgIHN1bSArPSB0aGlzLl9jb3VudGVyc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4gPSBmdW5jdGlvbihyZXN1bHQsIHN0YXJ0Q291bnRlcil7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBjYXRlZ29yaXphdGlvbiA9IHtcbiAgICAgICAgICAgIHNwYWNlOiB7XG4gICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUV9LFxuICAgICAgICAgICAgICAgIHdpZGU6IHtzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhcjoge1xuICAgICAgICAgICAgICAgIG5hcnJvdzogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFfSxcbiAgICAgICAgICAgICAgICB3aWRlOiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGtpbmQsXG4gICAgICAgIGNhdCxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgcG9zID0gc3RhcnRDb3VudGVyLFxuICAgICAgICBwYXR0ZXJuO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgIGZvciAoaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgY2F0ID0gKHBhdHRlcm4gJiAxKSA9PT0gMSA/IGtpbmQud2lkZSA6IGtpbmQubmFycm93O1xuICAgICAgICAgICAgY2F0LnNpemUgKz0gc2VsZi5fY291bnRlcnNbcG9zICsgal07XG4gICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICBwYXR0ZXJuID4+PSAxO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSA4O1xuICAgIH1cblxuICAgIFtcInNwYWNlXCIsIFwiYmFyXCJdLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBuZXdraW5kID0gY2F0ZWdvcml6YXRpb25ba2V5XTtcbiAgICAgICAgbmV3a2luZC53aWRlLm1pbiA9XG4gICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICBuZXdraW5kLm5hcnJvdy5tYXggPSBNYXRoLmNlaWwobmV3a2luZC53aWRlLm1pbik7XG4gICAgICAgIG5ld2tpbmQud2lkZS5tYXggPSBNYXRoLmNlaWwoKG5ld2tpbmQud2lkZS5zaXplICogc2VsZi5NQVhfQUNDRVBUQUJMRSArIHNlbGYuUEFERElORykgLyBuZXdraW5kLndpZGUuY291bnRzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9jaGFyVG9QYXR0ZXJuID0gZnVuY3Rpb24oY2hhcikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgY2hhckNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VsZi5BTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5BTFBIQUJFVFtpXSA9PT0gY2hhckNvZGUpe1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMHgwO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3ZhbGlkYXRlUmVzdWx0ID0gZnVuY3Rpb24ocmVzdWx0LCBzdGFydENvdW50ZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHRocmVzaG9sZHMgPSBzZWxmLl90aHJlc2hvbGRSZXN1bHRQYXR0ZXJuKHJlc3VsdCwgc3RhcnRDb3VudGVyKSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAga2luZCxcbiAgICAgICAgY2F0LFxuICAgICAgICBzaXplLFxuICAgICAgICBwb3MgPSBzdGFydENvdW50ZXIsXG4gICAgICAgIHBhdHRlcm47XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdHRlcm4gPSBzZWxmLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgIGZvciAoaiA9IDY7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgIGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgIHNpemUgPSBzZWxmLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IDg7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3BhdHRlcm5Ub0NoYXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmLkFMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkID0gZnVuY3Rpb24ob2Zmc2V0LCBlbmQpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbWluID0gTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgY291bnRlcjtcblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGVuZDsgaSArPSAyKXtcbiAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICBpZiAoY291bnRlciA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnRlciA8IG1pbikge1xuICAgICAgICAgICAgbWluID0gY291bnRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKG1pbiArIG1heCkgLyAyLjApIHwgMDtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl90b1BhdHRlcm4gPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICB2YXIgbnVtQ291bnRlcnMgPSA3LFxuICAgICAgICBlbmQgPSBvZmZzZXQgKyBudW1Db3VudGVycyxcbiAgICAgICAgYmFyVGhyZXNob2xkLFxuICAgICAgICBzcGFjZVRocmVzaG9sZCxcbiAgICAgICAgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSksXG4gICAgICAgIHBhdHRlcm4gPSAwLFxuICAgICAgICBpLFxuICAgICAgICB0aHJlc2hvbGQ7XG5cbiAgICBpZiAoZW5kID4gdGhpcy5fY291bnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICBiYXJUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0LCBlbmQpO1xuICAgIHNwYWNlVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCArIDEsIGVuZCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKyl7XG4gICAgICAgIHRocmVzaG9sZCA9IChpICYgMSkgPT09IDAgPyBiYXJUaHJlc2hvbGQgOiBzcGFjZVRocmVzaG9sZDtcbiAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJzW29mZnNldCArIGldID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgIH1cbiAgICAgICAgYml0bWFzayA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG5cbkNvZGFiYXJSZWFkZXIucHJvdG90eXBlLl9pc1N0YXJ0RW5kID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuU1RBUlRfRU5ELmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLlNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuQ29kYWJhclJlYWRlci5wcm90b3R5cGUuX3N1bUNvdW50ZXJzID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBpLFxuICAgICAgICBzdW0gPSAwO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59O1xuXG5Db2RhYmFyUmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBpLFxuICAgICAgICBwYXR0ZXJuLFxuICAgICAgICBzdGFydCA9IHNlbGYuX25leHRVbnNldChzZWxmLl9yb3cpLFxuICAgICAgICBlbmQ7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5fY291bnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0dGVybiA9IHNlbGYuX3RvUGF0dGVybihpKTtcbiAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHNlbGYuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IExvb2sgZm9yIHdoaXRlc3BhY2UgYWhlYWRcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYuX3N1bUNvdW50ZXJzKDAsIGkpO1xuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyBzZWxmLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICBzdGFydENvdW50ZXI6IGksXG4gICAgICAgICAgICAgICAgZW5kQ291bnRlcjogaSArIDhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb2RhYmFyUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RlMTI4UmVhZGVyKCkge1xuICAgIEJhcmNvZGVSZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQ09ERV9TSElGVDoge3ZhbHVlOiA5OH0sXG4gICAgQ09ERV9DOiB7dmFsdWU6IDk5fSxcbiAgICBDT0RFX0I6IHt2YWx1ZTogMTAwfSxcbiAgICBDT0RFX0E6IHt2YWx1ZTogMTAxfSxcbiAgICBTVEFSVF9DT0RFX0E6IHt2YWx1ZTogMTAzfSxcbiAgICBTVEFSVF9DT0RFX0I6IHt2YWx1ZTogMTA0fSxcbiAgICBTVEFSVF9DT0RFX0M6IHt2YWx1ZTogMTA1fSxcbiAgICBTVE9QX0NPREU6IHt2YWx1ZTogMTA2fSxcbiAgICBDT0RFX1BBVFRFUk46IHt2YWx1ZTogW1xuICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXG4gICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgWzIsIDIsIDIsIDIsIDIsIDFdLFxuICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXG4gICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgWzEsIDMsIDEsIDIsIDIsIDJdLFxuICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXG4gICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgWzEsIDMsIDIsIDIsIDEsIDJdLFxuICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXG4gICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgWzIsIDMsIDEsIDIsIDEsIDJdLFxuICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXG4gICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgWzEsIDIsIDIsIDIsIDMsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXG4gICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgWzEsIDIsIDMsIDIsIDIsIDFdLFxuICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgWzIsIDIsIDEsIDIsIDMsIDFdLFxuICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXG4gICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgWzMsIDEsIDIsIDEsIDMsIDFdLFxuICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXG4gICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgWzMsIDIsIDEsIDIsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXG4gICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgWzMsIDIsIDIsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXG4gICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgWzIsIDMsIDIsIDEsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXG4gICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgWzEsIDMsIDEsIDMsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXG4gICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgWzEsIDMsIDIsIDMsIDEsIDFdLFxuICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXG4gICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgWzIsIDMsIDEsIDMsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXG4gICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgWzEsIDMsIDIsIDEsIDMsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXG4gICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgWzEsIDMsIDMsIDEsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXG4gICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgWzIsIDMsIDEsIDEsIDMsIDFdLFxuICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXG4gICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDMsIDEsIDMsIDFdLFxuICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXG4gICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgWzMsIDMsIDEsIDEsIDIsIDFdLFxuICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXG4gICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgWzMsIDMsIDIsIDEsIDEsIDFdLFxuICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgWzQsIDMsIDEsIDEsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXG4gICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgWzEsIDIsIDEsIDEsIDIsIDRdLFxuICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXG4gICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgWzEsIDQsIDEsIDIsIDIsIDFdLFxuICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXG4gICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgWzEsIDIsIDIsIDEsIDEsIDRdLFxuICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXG4gICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgWzEsIDQsIDIsIDIsIDEsIDFdLFxuICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXG4gICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgWzQsIDEsIDMsIDEsIDEsIDFdLFxuICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXG4gICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDIsIDQsIDJdLFxuICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXG4gICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgWzEsIDEsIDQsIDIsIDEsIDJdLFxuICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXG4gICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgWzQsIDEsIDEsIDIsIDEsIDJdLFxuICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXG4gICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgWzIsIDEsIDIsIDEsIDQsIDFdLFxuICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXG4gICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgWzEsIDEsIDEsIDEsIDQsIDNdLFxuICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXG4gICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgWzEsIDEsIDQsIDEsIDEsIDNdLFxuICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXG4gICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgWzQsIDEsIDEsIDMsIDEsIDFdLFxuICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXG4gICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgWzMsIDEsIDEsIDEsIDQsIDFdLFxuICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXG4gICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgWzIsIDEsIDEsIDIsIDEsIDRdLFxuICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXG4gICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXVxuICAgIF19LFxuICAgIFNJTkdMRV9DT0RFX0VSUk9SOiB7dmFsdWU6IDAuNjR9LFxuICAgIEFWR19DT0RFX0VSUk9SOiB7dmFsdWU6IDAuMzB9LFxuICAgIEZPUk1BVDoge3ZhbHVlOiBcImNvZGVfMTI4XCIsIHdyaXRlYWJsZTogZmFsc2V9LFxuICAgIE1PRFVMRV9JTkRJQ0VTOiB7dmFsdWU6IHtiYXI6IFswLCAyLCA0XSwgc3BhY2U6IFsxLCAzLCA1XX19XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQmFyY29kZVJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RlMTI4UmVhZGVyO1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlQ29kZSA9IGZ1bmN0aW9uKHN0YXJ0LCBjb3JyZWN0aW9uKSB7XG4gICAgdmFyIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBvZmZzZXQgPSBzdGFydCxcbiAgICAgICAgaXNXaGl0ZSA9ICFzZWxmLl9yb3dbb2Zmc2V0XSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgICAgIGJhcjogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2RlLFxuICAgICAgICBlcnJvcjtcblxuICAgIGZvciAoIGkgPSBvZmZzZXQ7IGkgPCBzZWxmLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNlbGYuX3Jvd1tpXSBeIGlzV2hpdGUpIHtcbiAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jb3JyZWN0KGNvdW50ZXIsIGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgc2VsZi5DT0RFX1BBVFRFUk4ubGVuZ3RoOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gc2VsZi5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IGNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fY29ycmVjdCA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvcnJlY3Rpb24pIHtcbiAgICB0aGlzLl9jb3JyZWN0QmFycyhjb3VudGVyLCBjb3JyZWN0aW9uLmJhciwgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgIHRoaXMuX2NvcnJlY3RCYXJzKGNvdW50ZXIsIGNvcnJlY3Rpb24uc3BhY2UsIHRoaXMuTU9EVUxFX0lORElDRVMuc3BhY2UpO1xufTtcblxuQ29kZTEyOFJlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICBpLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBpc1doaXRlID0gZmFsc2UsXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBqLFxuICAgICAgICBzdW07XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29kZSA9IHNlbGYuU1RBUlRfQ09ERV9BOyBjb2RlIDw9IHNlbGYuU1RBUlRfQ09ERV9DOyBjb2RlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzZWxmLl9tYXRjaFBhdHRlcm4oY291bnRlciwgc2VsZi5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBzZWxmLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSBjYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5iYXIpO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IGNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlMTI4UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKSxcbiAgICAgICAgY29kZSA9IG51bGwsXG4gICAgICAgIGRvbmUgPSBmYWxzZSxcbiAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIG11bHRpcGxpZXIgPSAwLFxuICAgICAgICBjaGVja3N1bSA9IDAsXG4gICAgICAgIGNvZGVzZXQsXG4gICAgICAgIHJhd1Jlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIHVuc2hpZnQsXG4gICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuXG4gICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29kZSA9IHtcbiAgICAgICAgY29kZTogc3RhcnRJbmZvLmNvZGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8uc3RhcnQsXG4gICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgY29ycmVjdGlvbjoge1xuICAgICAgICAgICAgYmFyOiBzdGFydEluZm8uY29ycmVjdGlvbi5iYXIsXG4gICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24uc3BhY2VcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgY2hlY2tzdW0gPSBjb2RlLmNvZGU7XG4gICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICBjYXNlIHNlbGYuU1RBUlRfQ09ERV9BOlxuICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0E7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2Ugc2VsZi5TVEFSVF9DT0RFX0I6XG4gICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBzZWxmLlNUQVJUX0NPREVfQzpcbiAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9DO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgdW5zaGlmdCA9IHNoaWZ0TmV4dDtcbiAgICAgICAgc2hpZnROZXh0ID0gZmFsc2U7XG4gICAgICAgIGNvZGUgPSBzZWxmLl9kZWNvZGVDb2RlKGNvZGUuZW5kLCBjb2RlLmNvcnJlY3Rpb24pO1xuICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICByYXdSZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICBjaGVja3N1bSArPSBtdWx0aXBsaWVyICogY29kZS5jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY29kZXNldCkge1xuICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQTpcbiAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGNvZGUuY29kZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHNlbGYuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdE5leHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9CO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLkNPREVfQzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSA8IDk2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlICE9PSBzZWxmLlNUT1BfQ09ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX1NISUZUOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBzZWxmLkNPREVfQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9DOlxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlIDwgMTAgPyBcIjBcIiArIGNvZGUuY29kZSA6IGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gc2VsZi5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHNlbGYuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gc2VsZi5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgY29kZXNldCA9IGNvZGVzZXQgPT09IHNlbGYuQ09ERV9BID8gc2VsZi5DT0RFX0IgOiBzZWxmLkNPREVfQTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvZGUuZW5kID0gc2VsZi5fbmV4dFVuc2V0KHNlbGYuX3JvdywgY29kZS5lbmQpO1xuICAgIGlmICghc2VsZi5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGNvZGUpKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY2hlY2tzdW0gLT0gbXVsdGlwbGllciAqIHJhd1Jlc3VsdFtyYXdSZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICBpZiAocmVtb3ZlTGFzdENoYXJhY3Rlcikge1xuICAgICAgICByZXN1bHQuc3BsaWNlKHJlc3VsdC5sZW5ndGggLSAxLCAxKTtcbiAgICB9XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICBlbmQ6IGNvZGUuZW5kLFxuICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0SW5mbyxcbiAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZEluZm86IGNvZGVcbiAgICB9O1xufTtcblxuXG5CYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlID0gZnVuY3Rpb24oZW5kSW5mbykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgc2VsZi5fcm93Lmxlbmd0aCkge1xuICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBjYWxjdWxhdGVDb3JyZWN0aW9uKGV4cGVjdGVkLCBub3JtYWxpemVkLCBpbmRpY2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGluZGljZXMubGVuZ3RoLFxuICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgc3VtRXhwZWN0ZWQgPSAwO1xuXG4gICAgd2hpbGUobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtRXhwZWN0ZWQgKz0gZXhwZWN0ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgc3VtTm9ybWFsaXplZCArPSBub3JtYWxpemVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgfVxuICAgIHJldHVybiBzdW1FeHBlY3RlZC9zdW1Ob3JtYWxpemVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMTI4UmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIuanMiLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuXG5mdW5jdGlvbiBDb2RlMzlWSU5SZWFkZXIoKSB7XG4gICAgQ29kZTM5UmVhZGVyLmNhbGwodGhpcyk7XG59XG5cbnZhciBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vXG59O1xuXG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb2RlMzlSZWFkZXIucHJvdG90eXBlKTtcbkNvZGUzOVZJTlJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb2RlMzlWSU5SZWFkZXI7XG5cbi8vIENyaWJiZWQgZnJvbTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96eGluZy96eGluZy9ibG9iL21hc3Rlci9jb3JlL3NyYy9tYWluL2phdmEvY29tL2dvb2dsZS96eGluZy9jbGllbnQvcmVzdWx0L1ZJTlJlc3VsdFBhcnNlci5qYXZhXG5Db2RlMzlWSU5SZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmFwcGx5KHRoaXMpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29kZSA9IGNvZGUucmVwbGFjZShwYXR0ZXJucy5JT1EsICcnKTtcblxuICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIEFaMDkgcGF0dGVybiBjb2RlOicsIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNvZGUzOVZJTlJlYWRlci5wcm90b3R5cGUuX2NoZWNrQ2hlY2tzdW0gPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiAhIWNvZGU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2NvZGVfMzlfdmluX3JlYWRlci5qcyIsImltcG9ydCBCYXJjb2RlUmVhZGVyIGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEFycmF5SGVscGVyIGZyb20gJy4uL2NvbW1vbi9hcnJheV9oZWxwZXInO1xuXG5mdW5jdGlvbiBDb2RlOTNSZWFkZXIoKSB7XG4gICAgQmFyY29kZVJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG5jb25zdCBBTFBIQUJFVEhfU1RSSU5HID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZCpcIjtcblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQUxQSEFCRVRIX1NUUklORzoge3ZhbHVlOiBBTFBIQUJFVEhfU1RSSU5HfSxcbiAgICBBTFBIQUJFVDoge3ZhbHVlOiBBTFBIQUJFVEhfU1RSSU5HLnNwbGl0KCcnKS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpfSxcbiAgICBDSEFSQUNURVJfRU5DT0RJTkdTOiB7dmFsdWU6IFtcbiAgICAgICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgICAgIDB4MUE4LCAweDFBNCwgMHgxQTIsIDB4MTk0LCAweDE5MiwgMHgxOEEsIDB4MTY4LCAweDE2NCwgMHgxNjIsIDB4MTM0LFxuICAgICAgICAweDExQSwgMHgxNTgsIDB4MTRDLCAweDE0NiwgMHgxMkMsIDB4MTE2LCAweDFCNCwgMHgxQjIsIDB4MUFDLCAweDFBNixcbiAgICAgICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgICAgIDB4MTZFLCAweDE3NiwgMHgxQUUsIDB4MTI2LCAweDFEQSwgMHgxRDYsIDB4MTMyLCAweDE1RVxuICAgIF19LFxuICAgIEFTVEVSSVNLOiB7dmFsdWU6IDB4MTVFfSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJjb2RlXzkzXCIsIHdyaXRlYWJsZTogZmFsc2V9XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCYXJjb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29kZTkzUmVhZGVyO1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvdW50ZXJzID0gWzAsIDAsIDAsIDAsIDAsIDBdLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgc3RhcnQgPSBzZWxmLl9maW5kU3RhcnQoKSxcbiAgICAgICAgZGVjb2RlZENoYXIsXG4gICAgICAgIGxhc3RTdGFydCxcbiAgICAgICAgcGF0dGVybixcbiAgICAgICAgbmV4dFN0YXJ0O1xuXG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICBkbyB7XG4gICAgICAgIGNvdW50ZXJzID0gc2VsZi5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKTtcbiAgICAgICAgcGF0dGVybiA9IHNlbGYuX3RvUGF0dGVybihjb3VudGVycyk7XG4gICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENoYXIgPSBzZWxmLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICBpZiAoZGVjb2RlZENoYXIgPCAwKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xuICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3csIG5leHRTdGFydCk7XG4gICAgfSB3aGlsZSAoZGVjb2RlZENoYXIgIT09ICcqJyk7XG4gICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5fdmVyaWZ5RW5kKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgIGlmICgocmVzdWx0ID0gc2VsZi5fZGVjb2RlRXh0ZW5kZWQocmVzdWx0KSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBzdGFydDogc3RhcnQuc3RhcnQsXG4gICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICBkZWNvZGVkQ29kZXM6IHJlc3VsdFxuICAgIH07XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlFbmQgPSBmdW5jdGlvbihsYXN0U3RhcnQsIG5leHRTdGFydCkge1xuICAgIGlmIChsYXN0U3RhcnQgPT09IG5leHRTdGFydCB8fCAhdGhpcy5fcm93W25leHRTdGFydF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX3BhdHRlcm5Ub0NoYXIgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlbGYuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5DSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzZWxmLkFMUEhBQkVUW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl90b1BhdHRlcm4gPSBmdW5jdGlvbihjb3VudGVycykge1xuICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJzW2ldO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICBsZXQgbm9ybWFsaXplZCA9IE1hdGgucm91bmQoY291bnRlcnNbaV0gKiA5IC8gc3VtKTtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWQgPCAxIHx8IG5vcm1hbGl6ZWQgPiA0KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA9IChwYXR0ZXJuIDw8IDEpIHwgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPDw9IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX2ZpbmRTdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgb2Zmc2V0ID0gc2VsZi5fbmV4dFNldChzZWxmLl9yb3cpLFxuICAgICAgICBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQsXG4gICAgICAgIGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvdW50ZXJQb3MgPSAwLFxuICAgICAgICBpc1doaXRlID0gZmFsc2UsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIHdoaXRlU3BhY2VNdXN0U3RhcnQ7XG5cbiAgICBmb3IgKCBpID0gb2Zmc2V0OyBpIDwgc2VsZi5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzZWxmLl9yb3dbaV0gXiBpc1doaXRlKSB7XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gc2VsZi5BU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2pdID0gY291bnRlcltqICsgMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbNV0gPSAwO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVFeHRlbmRlZCA9IGZ1bmN0aW9uKGNoYXJBcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGNoYXJBcnJheS5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gY2hhckFycmF5W2ldO1xuICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgIGlmIChpID4gKGxlbmd0aCAtIDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGNoYXJBcnJheVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gbmV4dENoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDY0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdFJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0YnICYmIG5leHRDaGFyIDw9ICdKJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMTYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1AnICYmIG5leHRDaGFyIDw9ICdTJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ1QnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPT09ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICc6JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Db2RlOTNSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlDaGVja3N1bXMgPSBmdW5jdGlvbihjaGFyQXJyYXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF0Y2hDaGVja0NoYXIoY2hhckFycmF5LCBjaGFyQXJyYXkubGVuZ3RoIC0gMiwgMjApXG4gICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbn07XG5cbkNvZGU5M1JlYWRlci5wcm90b3R5cGUuX21hdGNoQ2hlY2tDaGFyID0gZnVuY3Rpb24oY2hhckFycmF5LCBpbmRleCwgbWF4V2VpZ2h0KSB7XG4gICAgY29uc3QgYXJyYXlUb0NoZWNrID0gY2hhckFycmF5LnNsaWNlKDAsIGluZGV4KTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheVRvQ2hlY2subGVuZ3RoO1xuICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSAoKChpICogLTEpICsgKGxlbmd0aCAtIDEpKSAlIG1heFdlaWdodCkgKyAxO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuQUxQSEFCRVQuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICByZXR1cm4gc3VtICsgKHdlaWdodCAqIHZhbHVlKTtcbiAgICB9LCAwKTtcblxuICAgIGNvbnN0IGNoZWNrQ2hhciA9IHRoaXMuQUxQSEFCRVRbKHdlaWdodGVkU3VtcyAlIDQ3KV07XG4gICAgcmV0dXJuIGNoZWNrQ2hhciA9PT0gY2hhckFycmF5W2luZGV4XS5jaGFyQ29kZUF0KDApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29kZTkzUmVhZGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9jb2RlXzkzX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gRUFOMlJlYWRlcigpIHtcbiAgICBFQU5SZWFkZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgRk9STUFUOiB7dmFsdWU6IFwiZWFuXzJcIiwgd3JpdGVhYmxlOiBmYWxzZX1cbn07XG5cbkVBTjJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFQU5SZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkVBTjJSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRUFOMlJlYWRlcjtcblxuRUFOMlJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24ocm93LCBzdGFydCkge1xuICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICB2YXIgY291bnRlcnMgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgIGNvZGVGcmVxdWVuY3kgPSAwLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnQsXG4gICAgICAgIGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGgsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCAyICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG9mZnNldCk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgaWYgKGNvZGUuY29kZSA+PSB0aGlzLkNPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICgxIC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSAyIHx8IChwYXJzZUludChyZXN1bHQuam9pbihcIlwiKSkgJSA0KSAgIT09IGNvZGVGcmVxdWVuY3kpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgIGVuZDogY29kZS5lbmRcbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOMlJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzJfcmVhZGVyLmpzIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuXG5mdW5jdGlvbiBFQU41UmVhZGVyKCkge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJlYW5fNVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuY29uc3QgQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzI0LCAyMCwgMTgsIDE3LCAxMiwgNiwgMywgMTAsIDksIDVdO1xuXG5FQU41UmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRUFOUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5FQU41UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVBTjVSZWFkZXI7XG5cbkVBTjVSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHJvdywgc3RhcnQpIHtcbiAgICB0aGlzLl9yb3cgPSByb3c7XG4gICAgdmFyIGNvdW50ZXJzID0gWzAsIDAsIDAsIDBdLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMCxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIG9mZnNldCA9IHN0YXJ0LFxuICAgICAgICBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoLFxuICAgICAgICBjb2RlLFxuICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNSAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gdGhpcy5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoNCAtIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpICE9IDQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0VW5zZXQodGhpcy5fcm93LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggIT0gNSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0KSAhPT0gZGV0ZXJtaW5lQ2hlY2tEaWdpdChjb2RlRnJlcXVlbmN5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oXCJcIiksXG4gICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgZW5kOiBjb2RlLmVuZFxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gQ0hFQ0tfRElHSVRfRU5DT0RJTkdTW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIHJldHVybiBzdW0gJSAxMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFONVJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzVfcmVhZGVyLmpzIiwiaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuL2Vhbl9yZWFkZXInO1xuXG5mdW5jdGlvbiBFQU44UmVhZGVyKG9wdHMsIHN1cHBsZW1lbnRzKSB7XG4gICAgRUFOUmVhZGVyLmNhbGwodGhpcywgb3B0cywgc3VwcGxlbWVudHMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJlYW5fOFwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuRUFOOFJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuRUFOOFJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFQU44UmVhZGVyO1xuXG5FQU44UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQsIHNlbGYuQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICB9XG5cbiAgICBjb2RlID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5NSURETEVfUEFUVEVSTiwgY29kZS5lbmQsIHRydWUsIGZhbHNlKTtcbiAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBjb2RlID0gc2VsZi5fZGVjb2RlQ29kZShjb2RlLmVuZCwgc2VsZi5DT0RFX0dfU1RBUlQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2RlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9yZWFkZXIvZWFuXzhfcmVhZGVyLmpzIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQge21lcmdlfSBmcm9tICdsb2Rhc2gnO1xuXG5mdW5jdGlvbiBJMm9mNVJlYWRlcihvcHRzKSB7XG4gICAgb3B0cyA9IG1lcmdlKGdldERlZmF1bENvbmZpZygpLCBvcHRzKTtcbiAgICBCYXJjb2RlUmVhZGVyLmNhbGwodGhpcywgb3B0cyk7XG4gICAgdGhpcy5iYXJTcGFjZVJhdGlvID0gWzEsIDFdO1xuICAgIGlmIChvcHRzLm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgpIHtcbiAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XG4gICAgICAgIHRoaXMuQVZHX0NPREVfRVJST1IgPSAwLjA5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsQ29uZmlnKCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKEkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBjb25maWdba2V5XSA9IEkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTW2tleV0uZGVmYXVsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG52YXIgTiA9IDEsXG4gICAgVyA9IDMsXG4gICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgU1RBUlRfUEFUVEVSTjoge3ZhbHVlOiBbTiwgTiwgTiwgTl19LFxuICAgICAgICBTVE9QX1BBVFRFUk46IHt2YWx1ZTogW04sIE4sIFddfSxcbiAgICAgICAgQ09ERV9QQVRURVJOOiB7dmFsdWU6IFtcbiAgICAgICAgICAgIFtOLCBOLCBXLCBXLCBOXSxcbiAgICAgICAgICAgIFtXLCBOLCBOLCBOLCBXXSxcbiAgICAgICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICAgICAgICAgIFtXLCBXLCBOLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBOLCBXLCBOLCBXXSxcbiAgICAgICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBXLCBXLCBOLCBOXSxcbiAgICAgICAgICAgIFtOLCBOLCBOLCBXLCBXXSxcbiAgICAgICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICAgICAgICAgIFtOLCBXLCBOLCBXLCBOXVxuICAgICAgICBdfSxcbiAgICAgICAgU0lOR0xFX0NPREVfRVJST1I6IHt2YWx1ZTogMC43OCwgd3JpdGFibGU6IHRydWV9LFxuICAgICAgICBBVkdfQ09ERV9FUlJPUjoge3ZhbHVlOiAwLjM4LCB3cml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIE1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjoge3ZhbHVlOiA1fSxcbiAgICAgICAgRk9STUFUOiB7dmFsdWU6IFwiaTJvZjVcIn1cbiAgICB9O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEkyb2Y1UmVhZGVyO1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX21hdGNoUGF0dGVybiA9IGZ1bmN0aW9uKGNvdW50ZXIsIGNvZGUpIHtcbiAgICBpZiAodGhpcy5jb25maWcubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGNvdW50ZXJTdW0gPSBbMCwgMF0sXG4gICAgICAgICAgICBjb2RlU3VtID0gWzAsIDBdLFxuICAgICAgICAgICAgY29ycmVjdGlvbiA9IFswLCAwXSxcbiAgICAgICAgICAgIGNvcnJlY3Rpb25SYXRpbyA9IHRoaXMuTUFYX0NPUlJFQ1RJT05fRkFDVE9SLFxuICAgICAgICAgICAgY29ycmVjdGlvblJhdGlvSW52ZXJzZSA9IDEgLyBjb3JyZWN0aW9uUmF0aW87XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXJTdW1baSAlIDJdICs9IGNvdW50ZXJbaV07XG4gICAgICAgICAgICBjb2RlU3VtW2kgJSAyXSArPSBjb2RlW2ldO1xuICAgICAgICB9XG4gICAgICAgIGNvcnJlY3Rpb25bMF0gPSBjb2RlU3VtWzBdIC8gY291bnRlclN1bVswXTtcbiAgICAgICAgY29ycmVjdGlvblsxXSA9IGNvZGVTdW1bMV0gLyBjb3VudGVyU3VtWzFdO1xuXG4gICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgY29ycmVjdGlvblsxXSA9IE1hdGgubWF4KE1hdGgubWluKGNvcnJlY3Rpb25bMV0sIGNvcnJlY3Rpb25SYXRpbyksIGNvcnJlY3Rpb25SYXRpb0ludmVyc2UpO1xuICAgICAgICB0aGlzLmJhclNwYWNlUmF0aW8gPSBjb3JyZWN0aW9uO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnRlcltpXSAqPSB0aGlzLmJhclNwYWNlUmF0aW9baSAlIDJdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCYXJjb2RlUmVhZGVyLnByb3RvdHlwZS5fbWF0Y2hQYXR0ZXJuLmNhbGwodGhpcywgY291bnRlciwgY29kZSk7XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2ZpbmRQYXR0ZXJuID0gZnVuY3Rpb24ocGF0dGVybiwgb2Zmc2V0LCBpc1doaXRlLCB0cnlIYXJkZXIpIHtcbiAgICB2YXIgY291bnRlciA9IFtdLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgaSxcbiAgICAgICAgY291bnRlclBvcyA9IDAsXG4gICAgICAgIGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaixcbiAgICAgICAgc3VtLFxuICAgICAgICBub3JtYWxpemVkLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUjtcblxuICAgIGlzV2hpdGUgPSBpc1doaXRlIHx8IGZhbHNlO1xuICAgIHRyeUhhcmRlciA9IHRyeUhhcmRlciB8fCBmYWxzZTtcblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYuX25leHRTZXQoc2VsZi5fcm93KTtcbiAgICB9XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IHBhdHRlcm4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnRlcltpXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICggaSA9IG9mZnNldDsgaSA8IHNlbGYuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZi5fcm93W2ldIF4gaXNXaGl0ZSkge1xuICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN1bSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICggaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY291bnRlci5sZW5ndGggLSAyOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZmluZFN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LFxuICAgICAgICBvZmZzZXQgPSBzZWxmLl9uZXh0U2V0KHNlbGYuX3JvdyksXG4gICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgbmFycm93QmFyV2lkdGggPSAxO1xuXG4gICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgc3RhcnRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogMTA7XG4gICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0SW5mby5lbmQ7XG4gICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgfVxufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgdG1wO1xuXG4gICAgc2VsZi5fcm93LnJldmVyc2UoKTtcbiAgICBlbmRJbmZvID0gc2VsZi5fZmluZFBhdHRlcm4oc2VsZi5TVE9QX1BBVFRFUk4pO1xuICAgIHNlbGYuX3Jvdy5yZXZlcnNlKCk7XG5cbiAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgIGVuZEluZm8uc3RhcnQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gZW5kSW5mby5lbmQ7XG4gICAgZW5kSW5mby5lbmQgPSBzZWxmLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyBzZWxmLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVQYWlyID0gZnVuY3Rpb24oY291bnRlclBhaXIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgY29kZSxcbiAgICAgICAgY29kZXMgPSBbXSxcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnRlclBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY291bnRlclBhaXJbaV0pO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2Rlcztcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlQ29kZSA9IGZ1bmN0aW9uKGNvdW50ZXIpIHtcbiAgICB2YXIgaixcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIG5vcm1hbGl6ZWQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcHNpbG9uID0gc2VsZi5BVkdfQ09ERV9FUlJPUixcbiAgICAgICAgY29kZSxcbiAgICAgICAgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiAwXG4gICAgICAgIH07XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IGNvdW50ZXJbal07XG4gICAgfVxuICAgIGZvciAoY29kZSA9IDA7IGNvZGUgPCBzZWxmLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICBlcnJvciA9IHNlbGYuX21hdGNoUGF0dGVybihjb3VudGVyLCBzZWxmLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJlc3RNYXRjaC5lcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICB9XG59O1xuXG5JMm9mNVJlYWRlci5wcm90b3R5cGUuX2RlY29kZVBheWxvYWQgPSBmdW5jdGlvbihjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIHBvcyA9IDAsXG4gICAgICAgIGNvdW50ZXJMZW5ndGggPSBjb3VudGVycy5sZW5ndGgsXG4gICAgICAgIGNvdW50ZXJQYWlyID0gW1swLCAwLCAwLCAwLCAwXSwgWzAsIDAsIDAsIDAsIDBdXSxcbiAgICAgICAgY29kZXM7XG5cbiAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyUGFpclswXVtpXSA9IGNvdW50ZXJzW3Bvc10gKiB0aGlzLmJhclNwYWNlUmF0aW9bMF07XG4gICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xuICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXMgPSBzZWxmLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgaWYgKCFjb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgXCJcIik7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2Rlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvZGVzO1xufTtcblxuSTJvZjVSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlDb3VudGVyTGVuZ3RoID0gZnVuY3Rpb24oY291bnRlcnMpIHtcbiAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbn07XG5cbkkyb2Y1UmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YXJ0SW5mbyxcbiAgICAgICAgZW5kSW5mbyxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNvZGUsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBkZWNvZGVkQ29kZXMgPSBbXSxcbiAgICAgICAgY291bnRlcnM7XG5cbiAgICBzdGFydEluZm8gPSBzZWxmLl9maW5kU3RhcnQoKTtcbiAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgIGVuZEluZm8gPSBzZWxmLl9maW5kRW5kKCk7XG4gICAgaWYgKCFlbmRJbmZvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvdW50ZXJzID0gc2VsZi5fZmlsbENvdW50ZXJzKHN0YXJ0SW5mby5lbmQsIGVuZEluZm8uc3RhcnQsIGZhbHNlKTtcbiAgICBpZiAoIXNlbGYuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb2RlID0gc2VsZi5fZGVjb2RlUGF5bG9hZChjb3VudGVycywgcmVzdWx0LCBkZWNvZGVkQ29kZXMpO1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyICE9PSAwIHx8XG4gICAgICAgICAgICByZXN1bHQubGVuZ3RoIDwgNikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBkZWNvZGVkQ29kZXMucHVzaChlbmRJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiByZXN1bHQuam9pbihcIlwiKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8sXG4gICAgICAgIGRlY29kZWRDb2RlczogZGVjb2RlZENvZGVzXG4gICAgfTtcbn07XG5cbkkyb2Y1UmVhZGVyLkNPTkZJR19LRVlTID0ge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IHtcbiAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICdkZWZhdWx0JzogZmFsc2UsXG4gICAgICAgICdkZXNjcmlwdGlvbic6ICdJZiB0cnVlLCB0aGUgcmVhZGVyIHRyaWVzIHRvIG5vcm1hbGl6ZSB0aGUnICtcbiAgICAgICAgJ3dpZHRoLWRpZmZlcmVuY2UgYmV0d2VlbiBiYXJzIGFuZCBzcGFjZXMnXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgSTJvZjVSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL2kyb2Y1X3JlYWRlci5qcyIsImltcG9ydCBRckNvZGUgZnJvbSAnLi4vbGliL3FyY29kZS1yZWFkZXInO1xuXG52YXIgcXIgPSBuZXcgUXJDb2RlKCk7XG5cbnZhciBwcm9wZXJ0aWVzID0ge1xuICAgIEZPUk1BVDogeyB2YWx1ZTogXCJxcl9jb2RlXCIsIHdyaXRlYWJsZTogZmFsc2UgfVxufTtcblxuUXJDb2RlUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5RckNvZGVSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXJDb2RlUmVhZGVyO1xuXG5mdW5jdGlvbiBRckNvZGVSZWFkZXIoY29uZmlnLCBzdXBwbGVtZW50cykge1xuICAgIHRoaXMuX3JvdyA9IFtdO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuc3VwcGxlbWVudHMgPSBzdXBwbGVtZW50cztcbiAgICByZXR1cm4gdGhpcztcbn1cblxuUXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVQYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4sIGlucHV0SW1hZ2VXcmFwcGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHFyLmRlY29kZSh7IHdpZHRoOiBpbnB1dEltYWdlV3JhcHBlci5zaXplLngsIGhlaWdodDogaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IH0sIGlucHV0SW1hZ2VXcmFwcGVyLmRhdGEpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IGNvZGU6IHJlc3VsdCAmJiByZXN1bHQucmVzdWx0IH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBRckNvZGVSZWFkZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3JlYWRlci9xcl9jb2RlX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gVVBDRVJlYWRlcihvcHRzLCBzdXBwbGVtZW50cykge1xuICAgIEVBTlJlYWRlci5jYWxsKHRoaXMsIG9wdHMsIHN1cHBsZW1lbnRzKTtcbn1cblxudmFyIHByb3BlcnRpZXMgPSB7XG4gICAgQ09ERV9GUkVRVUVOQ1k6IHt2YWx1ZTogW1xuICAgICAgICBbIDU2LCA1MiwgNTAsIDQ5LCA0NCwgMzgsIDM1LCA0MiwgNDEsIDM3IF0sXG4gICAgICAgIFs3LCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XV19LFxuICAgIFNUT1BfUEFUVEVSTjogeyB2YWx1ZTogWzEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDddfSxcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJ1cGNfZVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVBTlJlYWRlci5wcm90b3R5cGUsIHByb3BlcnRpZXMpO1xuVVBDRVJlYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVUENFUmVhZGVyO1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uKGNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKSB7XG4gICAgdmFyIGksXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgY29kZSA9IHNlbGYuX2RlY29kZUNvZGUoY29kZS5lbmQpO1xuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlLmNvZGUgPj0gc2VsZi5DT0RFX0dfU1RBUlQpIHtcbiAgICAgICAgICAgIGNvZGUuY29kZSA9IGNvZGUuY29kZSAtIHNlbGYuQ09ERV9HX1NUQVJUO1xuICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg1IC0gaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY29kZS5jb2RlKTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgfVxuICAgIGlmICghc2VsZi5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGU7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZGV0ZXJtaW5lUGFyaXR5ID0gZnVuY3Rpb24oY29kZUZyZXF1ZW5jeSwgcmVzdWx0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIG5yU3lzdGVtO1xuXG4gICAgZm9yIChuclN5c3RlbSA9IDA7IG5yU3lzdGVtIDwgdGhpcy5DT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IG5yU3lzdGVtKyspe1xuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29kZUZyZXF1ZW5jeSA9PT0gdGhpcy5DT0RFX0ZSRVFVRU5DWVtuclN5c3RlbV1baV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChuclN5c3RlbSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuVVBDRVJlYWRlci5wcm90b3R5cGUuX2NvbnZlcnRUb1VQQ0EgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICB2YXIgdXBjYSA9IFtyZXN1bHRbMF1dLFxuICAgICAgICBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgaWYgKGxhc3REaWdpdCA8PSAyKSB7XG4gICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgMykpXG4gICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoMywgNikpO1xuICAgIH0gZWxzZSBpZiAobGFzdERpZ2l0ID09PSAzKSB7XG4gICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwXSlcbiAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDQsIDYpKTtcbiAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICB1cGNhID0gdXBjYS5jb25jYXQocmVzdWx0LnNsaWNlKDEsIDUpKVxuICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMCwgcmVzdWx0WzVdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA2KSlcbiAgICAgICAgICAgIC5jb25jYXQoWzAsIDAsIDAsIDAsIGxhc3REaWdpdF0pO1xuICAgIH1cblxuICAgIHVwY2EucHVzaChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdKTtcbiAgICByZXR1cm4gdXBjYTtcbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlLl9jaGVja3N1bSA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIHJldHVybiBFQU5SZWFkZXIucHJvdG90eXBlLl9jaGVja3N1bS5jYWxsKHRoaXMsIHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG59O1xuXG5VUENFUmVhZGVyLnByb3RvdHlwZS5fZmluZEVuZCA9IGZ1bmN0aW9uKG9mZnNldCwgaXNXaGl0ZSkge1xuICAgIGlzV2hpdGUgPSB0cnVlO1xuICAgIHJldHVybiBFQU5SZWFkZXIucHJvdG90eXBlLl9maW5kRW5kLmNhbGwodGhpcywgb2Zmc2V0LCBpc1doaXRlKTtcbn07XG5cblVQQ0VSZWFkZXIucHJvdG90eXBlLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UgPSBmdW5jdGlvbihlbmRJbmZvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQ7XG5cbiAgICB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzZWxmLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVQQ0VSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL3VwY19lX3JlYWRlci5qcyIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcblxuZnVuY3Rpb24gVVBDUmVhZGVyKG9wdHMsIHN1cHBsZW1lbnRzKSB7XG4gICAgRUFOUmVhZGVyLmNhbGwodGhpcywgb3B0cywgc3VwcGxlbWVudHMpO1xufVxuXG52YXIgcHJvcGVydGllcyA9IHtcbiAgICBGT1JNQVQ6IHt2YWx1ZTogXCJ1cGNfYVwiLCB3cml0ZWFibGU6IGZhbHNlfVxufTtcblxuVVBDUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRUFOUmVhZGVyLnByb3RvdHlwZSwgcHJvcGVydGllcyk7XG5VUENSZWFkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVVBDUmVhZGVyO1xuXG5VUENSZWFkZXIucHJvdG90eXBlLl9kZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5jb2RlICYmIHJlc3VsdC5jb2RlLmxlbmd0aCA9PT0gMTMgJiYgcmVzdWx0LmNvZGUuY2hhckF0KDApID09PSBcIjBcIikge1xuICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHlcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MiB0byBhbm90aGVyXG4gKlxuICogQGFsaWFzIG1hdDIuY29weVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdXG4gIG91dFsxXSA9IGFbMV1cbiAgb3V0WzJdID0gYVsyXVxuICBvdXRbM10gPSBhWzNdXG4gIHJldHVybiBvdXRcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC1tYXQyL2NvcHkuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLW1hdDIvY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydFxuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuaW52ZXJ0XG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGEzID0gYVszXVxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTFcblxuICBpZiAoIWRldCkgcmV0dXJuIG51bGxcbiAgZGV0ID0gMS4wIC8gZGV0XG5cbiAgb3V0WzBdID0gIGEzICogZGV0XG4gIG91dFsxXSA9IC1hMSAqIGRldFxuICBvdXRbMl0gPSAtYTIgKiBkZXRcbiAgb3V0WzNdID0gIGEwICogZGV0XG5cbiAgcmV0dXJuIG91dFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLW1hdDIvaW52ZXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlXG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICByZXR1cm4gb3V0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzIvc2NhbGUuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MlxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHlcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5XG4gICAgcmV0dXJuIG91dFxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbC12ZWMyL3RyYW5zZm9ybU1hdDIuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjbG9uZShhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dsLXZlYzMvY2xvbmUuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fSGFzaC5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19TdGFjay5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2FwcGx5LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVRpbWVzID0gcmVxdWlyZSgnLi9fYmFzZVRpbWVzJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19hcnJheVB1c2guanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUZsYXR0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGb3IuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlSGFzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VLZXlzSW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBiYXNlTWVyZ2VEZWVwID0gcmVxdWlyZSgnLi9fYmFzZU1lcmdlRGVlcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZU1lcmdlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc2lnbk1lcmdlVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25NZXJnZVZhbHVlJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGluaXRDbG9uZU9iamVjdCA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZU9iamVjdCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoJy4vaXNQbGFpbk9iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5JyksXG4gICAgc2FmZUdldCA9IHJlcXVpcmUoJy4vX3NhZmVHZXQnKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi90b1BsYWluT2JqZWN0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICogIGNvdW50ZXJwYXJ0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICBzdGFja2VkID0gc3RhY2suZ2V0KHNyY1ZhbHVlKTtcblxuICBpZiAoc3RhY2tlZCkge1xuICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgIGlzVHlwZWQgPSAhaXNBcnIgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkoc3JjVmFsdWUpO1xuXG4gICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgIGlmIChpc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2VPYmplY3Qob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQnVmZikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZVR5cGVkQXJyYXkoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzKHNyY1ZhbHVlKSkge1xuICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSB0b1BsYWluT2JqZWN0KG9ialZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgKHNyY0luZGV4ICYmIGlzRnVuY3Rpb24ob2JqVmFsdWUpKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZU1lcmdlRGVlcC5qc1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlUGlja0J5ID0gcmVxdWlyZSgnLi9fYmFzZVBpY2tCeScpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVBpY2s7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlUGljay5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTZXQgPSByZXF1aXJlKCcuL19iYXNlU2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVBpY2tCeS5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2Jhc2VSZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlVGltZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19iYXNlVG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY2xvbmVCdWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jb3B5QXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbmV3VmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5T2JqZWN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fY29weU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jb3JlSnNEYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXNzaWduZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19mbGF0UmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc1BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2hhc2hEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaEdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19oYXNoSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faGFzaFNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNLZXkuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19pc01hc2tlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlR2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUhhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZVNldC5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbm9kZVV0aWw7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fb3ZlckFyZy5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3Nob3J0T3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0NsZWFyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0dldC5qc1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL19zdGFja0hhcy5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9fc3RhY2tTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbWVtb2l6ZUNhcHBlZCA9IHJlcXVpcmUoJy4vX21lbW9pemVDYXBwZWQnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1RvUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvX3RvU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2NvbnN0YW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKTtcblxuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYmFzZUZsYXR0ZW4oYXJyYXksIDEpIDogW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvZmxhdHRlbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL2hhc0luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQbGFpbk9iamVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9tZW1vaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvZGFzaC9waWNrLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gKi9cbmZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvUGxhaW5PYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbG9kYXNoL3RvUGxhaW5PYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gvdG9TdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY3X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJnZXQtcGl4ZWxzXCJcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY4X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJuZGFycmF5XCJcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMTY5X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJuZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZVwiXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==